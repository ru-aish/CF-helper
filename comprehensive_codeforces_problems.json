{
  "2128A": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128A",
    "problem_title": "2128A - Центр переработки",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's say a bag is expensive if $$$a_i > c$$$ and free if $$$a_i \\leq c$$$.First, observe that as long as there is at least one free bag remaining, we should destroy a free bag. We will perform all expensive destructions at the end. The goal is to perform as much free destructions as possible.When there are multiple free bags, which one to choose? The bigger a bag is, the less time you have to destroy it before it becomes expensive. Hence, at each second, you should destroy the biggest remaining free bag.This process can be naively simulated in $$$\\mathcal{O}(n^2)$$$, which was sufficient under given constraints. If you sort the array beforehand and keep the current multiplier in a separate variable (instead of multiplying all weights), it can be done in $$$\\mathcal{O}(n \\log n)$$$ time.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199790",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n\n\n\n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128B": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128B",
    "problem_title": "2128B - Процесс на Деке",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Instead of taking either the leftmost or rightmost element, think about taking either the minimum or maximum element.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "It's possible to ensure that $$$q_1 < q_2 > q_3 < q_4 > q_5 \\ldots$$$",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's number turns from $$$1$$$ to $$$n$$$. On odd turns, we take the minimum element and on even turns, we take the maximum element. We claim that $$$q_1 < q_2 > q_3 < q_4 > q_5 \\ldots$$$ (which is actually stronger than what the statement asked).Proof: consider taking the minimum on an odd turn : $$$q_i = \\min(p_l, p_r)$$$ where $$$l, r$$$ were the endpoints of the remaining array at turn $$$i$$$. Suppose without loss of generality the minimum was on the left, i.e. $$$q_i = p_l < p_r$$$. Then at the next turn, $$$p_r$$$ is still available:  $$$q_{i+1} = \\max(p_{l+1}, p_r) \\geq p_r > p_l = q_i$$$For example, if the remaining array at an odd turn is $$$[5, ?, \\ldots, 10]$$$, we take the minimum $$$5$$$, and then no matter what the $$$?$$$ is, we take at least $$$10$$$ which is greater than $$$5$$$. This proves $$$q_i < q_{i+1}$$$ when $$$i$$$ is odd. Similarly, we can prove $$$q_i > q_{i+1}$$$ when $$$i$$$ is even.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199677",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128C": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128C",
    "problem_title": "2128C - Самый левый меньший",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "Try to come up with a sufficient condition first, then prove it's necessary. Doing some examples with $$$n = 3$$$ might be useful.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let $$$m_i = \\min(b_1, \\ldots, b_{i-1})$$$ for every $$$2 \\leq i \\leq n$$$, which can be computed in linear time. We claim we can achieve $$$a = b$$$ if and only if $$$b_i - m_i < m_i$$$ for every $$$2 \\leq i \\leq n$$$.Proof that it's sufficient: we can build the array from left to right. For every $$$i$$$, if $$$b_i < m_i$$$ then we directly add $$$b_i$$$. Otherwise, we first add $$$b_i - m_i$$$, then $$$m_i$$$.Proof that it's necessary: suppose we managed to reach $$$b$$$. At every step, $$$a_i \\leq b_i$$$ for every $$$i$$$. Consider the last operation $$$x$$$ that incremented $$$a_i$$$. Then, by the definition of $$$i$$$, we must have  $$$a_i < x \\leq \\min(a_1, \\ldots, a_{i-1}) \\leq \\min(b_1, \\ldots, b_{i-1}).$$$Hence, $$$b_i = a_i + x \\leq 2x-1 \\leq 2m_i - 1$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199604",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128E1": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128E1",
    "problem_title": "2128E1 - Подмедианы (легкая версия)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "You can use binary search on the answer. Why ?",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "Let's start with a, perhaps, more natural task: finding whether or not $$$v$$$ is a submedian. To do so, we create an array $$$\\text{big}$$$ such that $$$\\text{big}[i] = 1 \\text{ if } \\text{a}[i] \\geq v \\text{ else } -1$$$We also create an array $$$\\text{small}$$$ such that $$$\\text{small}[i] = 1 \\text{ if } \\text{a}[i] \\leq v \\text{ else } -1$$$Knowing whether v is a submedian or not requires using both $$$\\mathrm{big}$$$ and $$$\\mathrm{small}$$$ ; when you want to know if the largest submedian is larger than or equal to v, do you actually need both arrays?",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Solve the relaxed problem where we only consider the first three constraints (and neglect the constraint on $$$\\mathrm{small}$$$) i.e finding the largest $$$v$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$",
        "codes": []
      },
      {
        "title": "hint4",
        "text": "Use binary search and prefix sums to rewrite the constraint on $$$\\text{big}$$$",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "Is the resulting value a submedian ?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "First, note that the predicate ``there exists a submedian $$$\\geq v$$$'' is monotonic. That is, if there exists a submedian $$$\\geq v$$$, then for all $$$v' < v$$$, there exists a submedian $$$\\geq v$$$. Thus, we can binary search to find the largest $$$v$$$ such that there exists a submedian $$$\\geq v$$$. Such a $$$v$$$ will be the largest submedian.Now, what is left is to check is, for a fixed $$$v$$$, whether or not there exists a submedian $$$\\geq v$$$. Let's start with a, perhaps, more natural task: finding whether or not $$$v$$$ is a submedian. To do so, we create an array $$$\\text{big}$$$ such that $$$\\text{big}[i] = 1 \\text{ if } \\text{a}[i] \\geq v \\text{ else } -1$$$We also create an array $$$\\text{small}$$$ such that $$$\\text{small}[i] = 1 \\text{ if } \\text{a}[i] \\leq v \\text{ else } -1$$$Using these notations, $$$v$$$ is a submedian iff there exists $$$(l, r)$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ $$$\\text{small}[l] + \\dots + \\text{small}[r] \\geq 0$$$ Let's try to solve a relaxed problem where we only consider the first three constraints (and neglect the constraint on $$$\\text{small}$$$ i.e finding the largest $$$v$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ Such a problem is standard and can be easily solved in $$$\\mathcal{O}(n \\log n)$$$ by binary search and prefix sums. Indeed, for a fixed $$$v$$$, we can iterate over the value of $$$r$$$. Now: $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ iff $$$\\text{pref}[r] - \\text{pref}[l-1] \\geq 0$$$ i.e $$$\\text{pref}[r] \\geq \\text{pref}[l-1]$$$ so taking $$$l$$$ that minimizes $$$\\text{pref}[l-1]$$$ is optimal. Thus, it is enough to maintain such an $$$l$$$ in constant time (when you increase $$$r$$$, there is only one new candidate for $$$l$$$).Now, I claim that the value of $$$v$$$ we get happens to be the largest submedian. Indeed, if it doesn't satisfy $$$\\text{small}[l] + \\dots + \\text{small}[r] \\geq 0$$$, then $$$v + 1$$$ would still satisfy $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ which contradicts the maximality of $$$v$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199376",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128E2": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128E2",
    "problem_title": "2128E2 - Подмедианы (сложная версия)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "The set of submedians is a range. Try to prove it.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "For $$$l_1 \\leq r_1$$$ and $$$l_2, r_2$$$ such that $$$|l_1 - l_2| + |r_1 - r_2| \\leq 1$$$, both subarrays share at least one median. How to prove it ? Knowing this fact, how to prove Hint 1 ?",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Find a discretely ``continuous'' path from the subarray of the minimum submedian, to the subarray of the maximum submedian",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Read the editorial of E1 first.In such problems, it can be useful to try an easier version, for example, finding maximal/minimal values (which is why the subtask is helpful).Now, one can observe that if $$$x \\leq y$$$ are submedians, then any $$$z$$$ such that $$$x \\leq z \\leq y$$$ is also a submedian ! One can prove this using the intermediate value theorem. Let's fix $$$x \\leq z \\leq y$$$ and $$$[l_1, r_1]$$$ (resp. $$$[l_2, r_2]$$$) be a range where $$$x$$$ (resp. $$$y$$$) is a submedian. wlog, assume $$$l_1 < l_2$$$. Start by sweeping $$$r_1$$$ to $$$l_2$$$. Then $$$r_1$$$ to $$$r_2$$$. And finally, $$$l_1$$$ to $$$l_2$$$. Then one of the ranges that we covered has submedian $$$z$$$. Intuitively, when incrementing one of the ends of a range, the +1/-1 in the arrays big and small are not changing that much (the norm 1 distance is bounded by 2) so we can think of using the intermediate value theorem (see proof below). Also, note that at any time, the covered range is of length at least $$$k$$$.Thus, it is enough to find the smallest and largest submedians (using the solution of E1) and maintain the set of submedians while sweeping. One way to do that is to use a fenwick tree to simulate an ordered set (or you can also use two range sum point update queries to simulate the \\text{big} and \\text{small} arrays). Alternatively, you can use two sets (one with the lower half of the values of the current range, and one with the upper half). For each $$$[l, r]$$$ that our algorithm covers, we consider the point $$$(|{i \\in [l,r] \\mid a[i] \\geq z}| - |{i \\in [l,r] \\mid a[i] < z}|, |{i \\in [l,r] \\mid a[i] \\leq z}| - |{i \\in [l,r] \\mid a[i] > z}|)$$$ where $$$|A|$$$ is the cardinal of set $$$A$$$. Essentially, you can think of this point as an encoding of both conditions on small and big for $$$z$$$ to be a submedian.Note that, when moving one end of the range, each coordinate of the point changes by at most 1 (in absolute value). Also note that, by a simple computation, the sum of both coordinates is positive (it is equal to twice the number of $$$i$$$ such that $$$a[i] = z$$$).I claim that one of these points will have positive coordinates (thus, $$$z$$$ will be a submedian). Indeed: our path starts at a point with (negative first coordinate, positive second coordinate) and ends at a point with (positive first coordinate, negative second coordinate). Each move allows moving to a point at distance at most 2. However, you can see on the drawing below that one must pass through points with positive coordinates to achieve this (otherwise, you would be stuck in (negative first coordinate, positive second coordinate)).In red, the area with points such that $$$x+y \\geq 0$$$, below the green line are forbidden points. The blue points are our starting and ending points. Finally, the arrows are the possible moves after incrementing/decrementing one end of the range.",
        "codes": []
      },
      {
        "title": "code",
        "text": "Fenwick tree solution: 331199080 Two sets solution: 331198693",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128F": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128F",
    "problem_title": "2128F - Строгий треугольник",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Hint1aSay an edge is green if its weight is $$$l_i$$$ and red if its weight is $$$r_i$$$. If the answer is YES, prove there exists a solution that colors a path from $$$1$$$ to $$$n$$$ in green and the rest of the edges in red. Hint1bConsider an arbitrary solution $$$w$$$ and let $$$P$$$ be the shortest path from $$$1$$$ to $$$n$$$ with respect to $$$w$$$. Decreasing the weight of an edge in $$$P$$$ will decrease $$$d(1, n)$$$ by exactly one and will decrease $$$d(1, k) + d(k, n)$$$ by at most one. Increasing the weight of an edge outside $$$P$$$ will not increase $$$d(1, n)$$$ and will not decrease $$$d(1, k) + d(k, n)$$$. By repeating these operations, we can make $$$P$$$ green and the rest red.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "Hint2aLet $$$P$$$ be the chosen green path. Find a necessary condition for the corresponding weight assignment to be correct. Then, prove if it's sufficient. Hint2bThe condition is $$$d_L(u, v) < d_R(u, k) + d_R(k, v)$$$ for all $$$u, v \\in P$$$. Hint2cIt's obviously necessary; otherwise, $$$1 \\rightarrow_L u \\rightarrow_R k \\rightarrow_R v \\rightarrow_L n$$$ would have length $$$d(1, n)$$$. Conversely, if there exists a $$$1-n$$$ shortest path going through $$$k$$$, if you consider the last node in $$$P$$$ you visited before reaching $$$k$$$ and the first node in $$$P$$$ you visited after reaching $$$k$$$, this pair of nodes will violate the condition.",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Try to build a correct path using a Dijkstra-like algorithm. It might be helpful to have an intuitive understanding of the condition found in the previous hint in order to quantify with a single integer how good the current path is. Imagine you're a robber going from $$$1$$$ to $$$n$$$ and you don't want to be caught by cops.",
        "codes": []
      },
      {
        "title": "hint4",
        "text": "Imagine nodes are cities, $$$k$$$ is a police station, and you're some robber. Traversing the $$$i$$$-th edge takes $$$l_i$$$ seconds for the robber, and $$$r_i$$$ seconds for the citizens and the cops.Each time you go through a city, the citizens of this city will run to the police station to warn the cops. Once the cops are warned, they start dispatching in all directions as fast as they can to catch up to you.",
        "codes": []
      },
      {
        "title": "hint5",
        "text": "The current danger can be represented by an integer timer $$$x$$$. If $$$x < 0$$$, it means the cops will be warned in $$$-x$$$ seconds. If $$$x \\geq 0$$$, it means the cops have been warned since $$$0$$$ seconds. It's the only information you need to remember.",
        "codes": []
      },
      {
        "title": "hint6",
        "text": "Try to find for each node $$$u$$$ what is the corresponding minimum timer $$$t_u$$$. As the robber runs through the graph, the timer always increases, so you can do this with Dijkstra.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Please read all the hints first.We first make a classical Dijkstra from $$$k$$$ with $$$r$$$-weighted edges. Let $$$d_u$$$ be the distance between $$$u$$$ and $$$k$$$ for citizens/cops.We then make a modified Dijkstra, starting from the situation $$$(1, t_1)$$$ with $$$t_1 = -d_1$$$ (meaning the cops will be warned in $$$d_1$$$ seconds).When you traverse the $$$i$$$-th edge to go from $$$(u, t)$$$ to $$$v$$$, the new timer will be  $$$t' = \\max(t + l_i, -d_v).$$$We have $$$t' \\geq t+l_i$$$ because the previous timer continued to advance while the robber was traversing the edge, and $$$t' \\geq -d_v$$$ because a new citizen started running from $$$v$$$ to the police station.Each time, we take the situation with the minimum timer from the priority queue. If the node has already been processed, or if $$$d_u \\leq t_u$$$ (meaning the cops can catch up to the robber in $$$v$$$), the situation is skipped. The answer is YES if and only if we processed the node $$$n$$$.The time complexity is $$$\\mathcal{O}((n + m) \\log (n+m))$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331198575",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128D": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128D",
    "problem_title": "D. Sum of LDS",
    "time_limit": "2 seconds",
    "memory_limit": "256 megabytes",
    "statement": "You're given a permutation$$$^{\\text{∗}}$$$ $$$p_1, \\ldots, p_n$$$ such that $$$\\max(p_i, p_{i+1}) > p_{i+2}$$$ for all $$$1 \\leq i \\leq n-2$$$.Compute the sum of the length of the longest decreasing subsequence$$$^{\\text{†}}$$$ of the subarray $$$[p_l, p_{l+1}, \\ldots, p_r]$$$ over all pairs $$$1 \\leq l \\leq r \\leq n$$$.$$$^{\\text{∗}}$$$A permutation of length $$$n$$$ is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array), and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).$$$^{\\text{†}}$$$Given an array $$$b$$$ of size $$$|b|$$$, a decreasing subsequence of length $$$k$$$ is a sequence of indices $$$i_1, \\ldots, i_k$$$ such that:$$$1 \\leq i_1 < i_2 < \\ldots < i_k \\leq |b|$$$$$$b_{i_1} > b_{i_2} > \\ldots > b_{i_k}$$$\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10\\,000$$$). The description of the test cases follows.The first line of each test case contains a single integer $$$n$$$ ($$$3 \\leq n \\leq 500\\,000$$$).The second line of each test case contains $$$n$$$ integers $$$p_1, p_2, \\ldots, p_n$$$ ($$$1 \\le p_i \\le n$$$, $$$p_i$$$ are pairwise distinct).It is guaranteed that $$$\\max(p_i, p_{i+1}) > p_{i+2}$$$ for all $$$1 \\leq i \\leq n-2$$$.The sum of $$$n$$$ over all test cases does not exceed $$$500\\,000$$$.\n\nOutputFor each test case, output the sum over all subarrays of the length of its longest decreasing subsequence.",
    "sample_inputs": [
      "433 2 144 3 1 266 1 5 2 4 332 3 1"
    ],
    "sample_outputs": [
      "10\n17\n40\n8"
    ],
    "notes": "NoteFor any array $$$a$$$, we define $$$\\text{LDS}(a)$$$ as the length of the longest decreasing subsequence of $$$a$$$.In the first test case, all subarrays are decreasing.In the second one, we have$$$\\text{LDS}([4]) = \\text{LDS}([3]) = \\text{LDS}([1]) = \\text{LDS}([2]) = 1$$$$$$\\text{LDS}([4,3]) = \\text{LDS}([3,1]) = 2, \\text{LDS}([1, 2]) = 1$$$$$$\\text{LDS}([4,3,1]) = 3, \\text{LDS}([3,1,2]) = 2$$$$$$\\text{LDS}([4,3,1,2]) = 3$$$So the answer is $$$1+1+1+1+2+2+1+3+2+3=17$$$.",
    "tags": [
      "brute force",
      "combinatorics",
      "dp",
      "greedy",
      "math",
      "*1600"
    ],
    "url": "https://codeforces.com/problemset/problem/2128/D",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Let $$$b_i = \\max(a_i, a_{i+1})$$$, show that $$$b_1 \\geq b_2 \\geq \\ldots \\geq b_{n-1}$$$.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "If $$$a_i < a_{i+1}$$$, show that $$$a_{i+1} > \\max(a_{i+2}, a_{i+3}, \\ldots a_{n})$$$.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let $$${i_1, \\ldots, i_m}$$$ be the set of $$$i \\in [1, n]$$$ such that $$$a_i > a_{i+1}$$$. Let us show that the sequence $$$(i_1, \\ldots, i_m)$$$ is an LDS:  It is a decreasing subsequence: let $$$k \\in [1, m -1]$$$. If $$$i_{k+1} = i_{k}+1$$$, then $$$a_{i_k} > a_{(i_k) + 1} = a_{i_{k+1}}$$$. Else, we have $$$a_{(i_k) + 2} < \\max(a_{i_k}, a_{(i_k)+1})$$$, but $$$i_k + 1$$$ is such that $$$a_{i_{k}+2} \\geq a_{i_{k+1}}$$$, so $$$a_{(i_k) + 2} < a_{i_k}$$$. We have also $$$a_{i_k + 1} < a_{i_k}$$$ by definition so we can easily prove by induction on $$$j > 0$$$ that $$$a_{i_k + j} < a_{i_k}$$$ where it makes sense. It's optimal : let $$$E$$$ be the set of indexes taken by a LDS. For each i such that $$$a_i \\leq a_{i+1}$$$, at least one of the elements of $$${i, i+1}$$$ does not belong to $$$E$$$. Now, these sets are disjoint : if $$$a_i < a_{i+1}$$$ we cannot have $$$a_{i+2} < a_{i+1}$$$ (otherwise the condition $$$\\max(a_i, a_{i+1}) > a_{i+2}$$$ is not met. So $$$|E| \\leq m$$$. To calculate the sum of the LDS of the sub-arrays, it is therefore sufficient to count for each $$$i$$$ such that $$$a_i < a_{i+1}$$$ the number of sub-arrays $$$a[l,r]$$$ which contain $$$i$$$ and $$$i + 1$$$. It's $$$(i+1) \\cdot (n - i - 1)$$$ for $$$0$$$-indexation : a necessary and sufficient condition is that $$$l \\leq i$$$ and $$$r \\geq i + 1$$$.Note that there also exists a dp approach, see this comment.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199533",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2126A": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126A",
    "problem_title": "2126A - Only One Digit",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int x;\n    cin >> x;\n    int mn = 9;\n    while(x > 0) {\n      mn = min(mn, x % 10);\n      x/=10;\n    }\n    cout << mn << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int x;\n    cin >> x;\n    int mn = 9;\n    while(x > 0) {\n      mn = min(mn, x % 10);\n      x/=10;\n    }\n    cout << mn << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126B": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126B",
    "problem_title": "2126B - No Casino in the Mountains",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    int cnt = 0;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] == 1) {\n        ans+=(cnt + 1)/(k + 1);\n        cnt = 0;\n        continue;\n      }\n      else {\n        cnt++;\n      }\n    }\n    ans+=(cnt + 1)/(k + 1);\n    cout << ans << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    int cnt = 0;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] == 1) {\n        ans+=(cnt + 1)/(k + 1);\n        cnt = 0;\n        continue;\n      }\n      else {\n        cnt++;\n      }\n    }\n    ans+=(cnt + 1)/(k + 1);\n    cout << ans << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126C": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126C",
    "problem_title": "2126C - I Will Definitely Make It",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,p;\n    cin >> n >> p;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int cur = a[p];\n    int dist = a[p];\n    sort(a + 1,a + n + 1);\n    bool ans = true;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] < cur) continue;\n      if(a[i] &mdash; cur > dist) {\n        ans = false;\n      }\n      cur = a[i];\n    }\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,p;\n    cin >> n >> p;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int cur = a[p];\n    int dist = a[p];\n    sort(a + 1,a + n + 1);\n    bool ans = true;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] < cur) continue;\n      if(a[i] &mdash; cur > dist) {\n        ans = false;\n      }\n      cur = a[i];\n    }\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126D": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126D",
    "problem_title": "2126D - This Is the Last Time",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    pair <int,pair <int,int> > p[n + 1];\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[ыi].second.first >> p[i].second.second;\n    sort(p + 1,p + n + 1);\n    int cur = k;\n    for(int i = 1;i <= n;i++) {\n      if(p[i].first > cur) break;\n      cur = max(cur,p[i].second.second);\n    }\n    cout << cur << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    pair <int,pair <int,int> > p[n + 1];\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[ыi].second.first >> p[i].second.second;\n    sort(p + 1,p + n + 1);\n    int cur = k;\n    for(int i = 1;i <= n;i++) {\n      if(p[i].first > cur) break;\n      cur = max(cur,p[i].second.second);\n    }\n    cout << cur << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126E": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126E",
    "problem_title": "2126E - G-C-D, Unlucky!",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nmain() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long a[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        long long b[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        long long ans[n + 1];\n        for (int i = n; i >= 1; i--) {\n            ans[i] = lcm(a[i], b[i]);\n        }\n        bool ch = 1;\n        if(ans[1] != a[1]) ch = 0;\n        if(ans[n] != b[n]) ch = 0;\n        for (int i = 2; i <= n; i++) {\n            if (__gcd(a[i &mdash; 1], ans[i]) != a[i]) {\n                ch = 0;\n            }\n        }\n        for (int i = n &mdash; 1; i >= 1; i--) {\n            if (__gcd(b[i + 1], ans[i]) != b[i]) {\n                ch = 0;\n            }\n        }\n        if (ch) {\n            cout << \"YES\" << \"\\n\";\n        } else {\n            cout << \"NO\" << \"\\n\";\n        }\n    }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nmain() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long a[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        long long b[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        long long ans[n + 1];\n        for (int i = n; i >= 1; i--) {\n            ans[i] = lcm(a[i], b[i]);\n        }\n        bool ch = 1;\n        if(ans[1] != a[1]) ch = 0;\n        if(ans[n] != b[n]) ch = 0;\n        for (int i = 2; i <= n; i++) {\n            if (__gcd(a[i &mdash; 1], ans[i]) != a[i]) {\n                ch = 0;\n            }\n        }\n        for (int i = n &mdash; 1; i >= 1; i--) {\n            if (__gcd(b[i + 1], ans[i]) != b[i]) {\n                ch = 0;\n            }\n        }\n        if (ch) {\n            cout << \"YES\" << \"\\n\";\n        } else {\n            cout << \"NO\" << \"\\n\";\n        }\n    }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126F": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126F",
    "problem_title": "2126F - 1-1-1, Free Tree!",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\nint n;\nint col[B];\nlong long costt = 0;\nvector <pair <int,int> > reb[B];\nbool was[B];\nmap <int,long long> cnt[B];\nint pred[B];\nlong long zn[B];\nvoid dfs(int v) {\n  was[v] = true;\n  for(auto u:reb[v]) {\n    if(was[u.first]) {\n      pred[v] = u.first;\n      continue;\n    }\n    if(col[v] != col[u.first]) costt+=u.second;\n    dfs(u.first);\n    zn[u.first] = u.second;\n    cnt[v][col[u.first]]+=zn[u.first];\n  }\n}\nvoid update(int v,int x) {\n  if(v != 1) {\n    cnt[pred[v]][col[v]]-=zn[v];\n    if(col[pred[v]] == col[v]) costt+=zn[v];\n    cnt[pred[v]][x]+=zn[v];\n    if(col[pred[v]] == x) costt-=zn[v];\n  }\n  else {\n      \n  }\n  costt+=cnt[v][col[v]];\n  costt-=cnt[v][x];\n  col[v] = x;\n}\nvoid clr() {\n  for(int i = 1;i <= n;i++) {\n    reb[i].clear();\n    was[i] = false;\n    cnt[i].clear();\n    zn[i] = 0;\n  }\n  costt = 0;\n}\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int q;\n    cin >> n >> q;\n    for(int i = 1; i <= n; i++) cin >> col[i];\n    for(int i = 1; i < n; i++) {\n      int u, v, c;\n      cin >> u >> v >> c;\n      reb[v].push_back({u,c});\n      reb[u].push_back({v,c});\n    }\n    dfs(1);\n    while(q--) {\n      int pos,x;\n      cin >> pos >> x;\n      update(pos,x);\n      cout << costt << \"\\n\";\n    }\n    clr();\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\nint n;\nint col[B];\nlong long costt = 0;\nvector <pair <int,int> > reb[B];\nbool was[B];\nmap <int,long long> cnt[B];\nint pred[B];\nlong long zn[B];\nvoid dfs(int v) {\n  was[v] = true;\n  for(auto u:reb[v]) {\n    if(was[u.first]) {\n      pred[v] = u.first;\n      continue;\n    }\n    if(col[v] != col[u.first]) costt+=u.second;\n    dfs(u.first);\n    zn[u.first] = u.second;\n    cnt[v][col[u.first]]+=zn[u.first];\n  }\n}\nvoid update(int v,int x) {\n  if(v != 1) {\n    cnt[pred[v]][col[v]]-=zn[v];\n    if(col[pred[v]] == col[v]) costt+=zn[v];\n    cnt[pred[v]][x]+=zn[v];\n    if(col[pred[v]] == x) costt-=zn[v];\n  }\n  else {\n      \n  }\n  costt+=cnt[v][col[v]];\n  costt-=cnt[v][x];\n  col[v] = x;\n}\nvoid clr() {\n  for(int i = 1;i <= n;i++) {\n    reb[i].clear();\n    was[i] = false;\n    cnt[i].clear();\n    zn[i] = 0;\n  }\n  costt = 0;\n}\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int q;\n    cin >> n >> q;\n    for(int i = 1; i <= n; i++) cin >> col[i];\n    for(int i = 1; i < n; i++) {\n      int u, v, c;\n      cin >> u >> v >> c;\n      reb[v].push_back({u,c});\n      reb[u].push_back({v,c});\n    }\n    dfs(1);\n    while(q--) {\n      int pos,x;\n      cin >> pos >> x;\n      update(pos,x);\n      cout << costt << \"\\n\";\n    }\n    clr();\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126G1": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126G1",
    "problem_title": "2126G1 - Big Wins! (easy version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    for(int i = 1;i <= 100;i++) {\n      int b[n + 1] = {};\n      for(int j = 1;j <= n;j++) {\n        if(a[j] >= i) b[j] = 1;\n        else b[j] = -1;\n      }\n      int pref[n + 1] = {};\n      for(int j = 1; j <= n; j++) {\n        pref[j] = pref[j - 1] + b[j]; \n      }\n      int prefmn[n + 2] = {},suffmx[n + 1] = {};\n      prefmn[0] = 0,suffmx[n] = pref[n];\n      for(int j = 1; j <= n; j++) {\n        prefmn[j] = min(prefmn[j - 1],pref[j]);\n      }\n      for(int j = n - 1; j >= 1; j--) {\n        suffmx[j] = max(suffmx[j + 1],pref[j]);\n      }\n      for(int j = 1; j <= n; j++) {\n        if(prefmn[j - 1] <= pref[j] || pref[j - 1] <= suffmx[j]) {\n          ans = max(ans,i - a[j]);\n        }\n      }\n    } \n    cout << ans << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    for(int i = 1;i <= 100;i++) {\n      int b[n + 1] = {};\n      for(int j = 1;j <= n;j++) {\n        if(a[j] >= i) b[j] = 1;\n        else b[j] = -1;\n      }\n      int pref[n + 1] = {};\n      for(int j = 1; j <= n; j++) {\n        pref[j] = pref[j - 1] + b[j]; \n      }\n      int prefmn[n + 2] = {},suffmx[n + 1] = {};\n      prefmn[0] = 0,suffmx[n] = pref[n];\n      for(int j = 1; j <= n; j++) {\n        prefmn[j] = min(prefmn[j - 1],pref[j]);\n      }\n      for(int j = n - 1; j >= 1; j--) {\n        suffmx[j] = max(suffmx[j + 1],pref[j]);\n      }\n      for(int j = 1; j <= n; j++) {\n        if(prefmn[j - 1] <= pref[j] || pref[j - 1] <= suffmx[j]) {\n          ans = max(ans,i - a[j]);\n        }\n      }\n    } \n    cout << ans << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126G2": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126G2",
    "problem_title": "G2. Big Wins! (hard version)",
    "time_limit": "4 seconds",
    "memory_limit": "256 megabytes",
    "statement": "This is the hard version of the problem. The difference between the versions is that in this version $$$a_i \\leq n$$$.You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$.Your task is to find a subarray $$$a[l, r]$$$ (a continuous sequence of elements $$$a_l, a_{l + 1}, \\dots, a_r$$$) for which the value of the expression $$$\\text{med}(a[l, r]) - \\min(a[l, r])$$$ is maximized.Here:$$$\\text{med}$$$ is the median of the subarray, that is, the element at position $$$\\left\\lceil \\frac{k + 1}{2} \\right\\rceil$$$ after sorting the subarray, where $$$k$$$ is its length;$$$\\min$$$ is the minimum element of this subarray.For example, consider the array $$$a=[1, 4, 1, 5, 3, 3]$$$ and choose the subarray $$$a[2, 5] = [4, 1, 5, 3]$$$. In sorted form, it looks like $$$[1, 3, 4, 5]$$$.$$$\\text{med}(a[2, 5]) = 4$$$, since $$$\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil = $$$ the third element in the sorted subarray is $$$4$$$;$$$\\min(a[2, 5]) = 1$$$, since the minimum element is $$$1$$$.In this example, the value $$$\\text{med} - \\min = 4 - 1 = 3$$$.\n\nInputThe first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the array.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.\n\nOutputFor each test case, output one integer — the maximum possible value of $$$\\text{med} - \\min$$$ among all subarrays of the array.",
    "sample_inputs": [
      "553 2 5 3 144 1 1 376 1 3 4 6 2 744 2 3 151 2 3 4 5"
    ],
    "sample_outputs": [
      "3\n3\n5\n2\n2"
    ],
    "notes": "NoteIn the first example, consider the array: $$$a=[3,\\ 2,\\ 5,\\ 3,\\ 1]$$$ you can choose the subarray $$$a[2,\\ 3]$$$, that is, the elements $$$[2,\\ 5]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[2,\\ 5]$$$, $$$\\text{med} = 5$$$.The minimum element of the subarray: $$$\\min = 2$$$.Therefore, $$$\\text{med} - \\min = 5 - 2 = 3$$$, which is the maximum answer.In the second test, the array: $$$a=[4,\\ 1,\\ 1,\\ 3]$$$ you can choose the subarray $$$a[1,\\ 2]$$$, that is, the elements $$$[4,\\ 1]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[1,\\ 4]$$$, $$$\\text{med} = 4$$$.The minimum element of the subarray: $$$\\min = 1$$$.Therefore, $$$\\text{med} - \\min = 4 - 1 = 3$$$.It can be proven that both of these subarrays are optimal and yield the maximum value of the expression $$$\\text{med} - \\min$$$.",
    "tags": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dsu",
      "trees",
      "two pointers",
      "*2400"
    ],
    "url": "https://codeforces.com/contest/2126/problem/G2",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint a[200005 + 2];\narray<int, 4> t[800005];\narray<int, 4> merge(array<int, 4>a, array<int, 4>b) {\n    int ans = max(a[0], b[0]);\n    int mxpref = max(a[1], a[3] + b[1]);\n    int mxsuff = max(b[2], a[2] + b[3]);\n    ans = max({ans, mxpref, mxsuff});\n    int sum = a[3] + b[3];\n    return {ans, mxpref, mxsuff, sum};\n}\nvoid update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n        t[v] = {max(val, 0), max(val, 0), max(val, 0), val};\n    } else {\n        int tm = (tl + tr) >> 1;\n        if (pos <= tm) {\n            update(v * 2, tl, tm, pos, val);\n        } else {\n            update(v * 2 + 1, tm + 1, tr, pos, val);\n        }\n        t[v] = merge(t[v * 2], t[v * 2 + 1]);\n    }\n}\narray<int, 4> get(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n        return t[v];\n    } else if (l > r) {\n        return {0, 0, 0, 0};\n    } else {\n        int tm = (tl + tr) >> 1;\n        return merge(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n}\nint solve(int n, vector<int>A) {\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n        m = max(m, a[i]);\n    }\n    vector<int>ind[m + 1];\n    for (int i = 1; i <= n; i++) {\n        ind[a[i]].push_back(i);\n    }\n    stack<int>s;\n    s.push(0);\n    a[0] = -INT_MAX;\n    int l[n + 1];\n    for (int i = 1; i <= n; i++) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        l[i] = s.top() + 1;\n        s.push(i);\n    }\n    a[n + 1] = -INT_MAX;\n    s.push(n + 1);\n    int r[n + 1];\n    for (int i = n; i >= 1; i--) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        r[i] = s.top() &mdash; 1;\n        s.push(i);\n    }\n    int med = 1;\n    for (int i = 1; i <= n; i++) {\n        update(1, 1, n, i, 1);\n    }\n    for (auto u : ind[1]) {\n        update(1, 1, n, u, -1);\n    }\n    int ans = 0;\n    for (int mn = 1; mn <= m; mn++) {\n        for (auto u : ind[mn]) {\n            int lg = l[u], rg = r[u];\n            while (med < m && get(1, 1, n, lg, u &mdash; 1)[2] + get(1, 1, n, u + 1, rg)[1] + (a[u] < (med) ? -1 : 1) >= 0) {\n                med++;\n                for (auto u : ind[med]) {\n                    update(1, 1, n, u, -1);\n                }\n            }\n        }\n        // cout << med << ' ' << mn << endl;\n        ans = max(ans, med &mdash; mn);\n    }\n    return ans;\n}\nint solveslow(int n, vector<int>A) {\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        vector<int>v;\n        for (int j = i; j <= n; j++) {\n            v.push_back(a[j]);\n            sort(v.begin(), v.end());\n            mx = max(mx, v[v.size() / 2] &mdash; v[0]);\n        }\n    }\n    return mx;\n}\nint rnd() {\n    return (rand() + rand() * RAND_MAX);\n}\nmain() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while(tt--) {\n        int n;\n        cin >> n;\n        vector<int>v;\n        for (int i = 1; i <= n; i++) {\n            int x;\n            cin >> x;\n            v.push_back(x);\n        }\n        cout << solve(n, v) << endl;\n        // cout << solveslow(n, v) << endl;\n        for(int i = 0;i <= n*4;i++) {\n            t[i][0] = 0;\n            t[i][1] = 0;\n            t[i][2] = 0;\n            t[i][3] = 0;\n        }\n    }\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint a[200005 + 2];\narray<int, 4> t[800005];\narray<int, 4> merge(array<int, 4>a, array<int, 4>b) {\n    int ans = max(a[0], b[0]);\n    int mxpref = max(a[1], a[3] + b[1]);\n    int mxsuff = max(b[2], a[2] + b[3]);\n    ans = max({ans, mxpref, mxsuff});\n    int sum = a[3] + b[3];\n    return {ans, mxpref, mxsuff, sum};\n}\nvoid update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n        t[v] = {max(val, 0), max(val, 0), max(val, 0), val};\n    } else {\n        int tm = (tl + tr) >> 1;\n        if (pos <= tm) {\n            update(v * 2, tl, tm, pos, val);\n        } else {\n            update(v * 2 + 1, tm + 1, tr, pos, val);\n        }\n        t[v] = merge(t[v * 2], t[v * 2 + 1]);\n    }\n}\narray<int, 4> get(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n        return t[v];\n    } else if (l > r) {\n        return {0, 0, 0, 0};\n    } else {\n        int tm = (tl + tr) >> 1;\n        return merge(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n}\nint solve(int n, vector<int>A) {\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n        m = max(m, a[i]);\n    }\n    vector<int>ind[m + 1];\n    for (int i = 1; i <= n; i++) {\n        ind[a[i]].push_back(i);\n    }\n    stack<int>s;\n    s.push(0);\n    a[0] = -INT_MAX;\n    int l[n + 1];\n    for (int i = 1; i <= n; i++) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        l[i] = s.top() + 1;\n        s.push(i);\n    }\n    a[n + 1] = -INT_MAX;\n    s.push(n + 1);\n    int r[n + 1];\n    for (int i = n; i >= 1; i--) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        r[i] = s.top() &mdash; 1;\n        s.push(i);\n    }\n    int med = 1;\n    for (int i = 1; i <= n; i++) {\n        update(1, 1, n, i, 1);\n    }\n    for (auto u : ind[1]) {\n        update(1, 1, n, u, -1);\n    }\n    int ans = 0;\n    for (int mn = 1; mn <= m; mn++) {\n        for (auto u : ind[mn]) {\n            int lg = l[u], rg = r[u];\n            while (med < m && get(1, 1, n, lg, u &mdash; 1)[2] + get(1, 1, n, u + 1, rg)[1] + (a[u] < (med) ? -1 : 1) >= 0) {\n                med++;\n                for (auto u : ind[med]) {\n                    update(1, 1, n, u, -1);\n                }\n            }\n        }\n        // cout << med << ' ' << mn << endl;\n        ans = max(ans, med &mdash; mn);\n    }\n    return ans;\n}\nint solveslow(int n, vector<int>A) {\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        vector<int>v;\n        for (int j = i; j <= n; j++) {\n            v.push_back(a[j]);\n            sort(v.begin(), v.end());\n            mx = max(mx, v[v.size() / 2] &mdash; v[0]);\n        }\n    }\n    return mx;\n}\nint rnd() {\n    return (rand() + rand() * RAND_MAX);\n}\nmain() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while(tt--) {\n        int n;\n        cin >> n;\n        vector<int>v;\n        for (int i = 1; i <= n; i++) {\n            int x;\n            cin >> x;\n            v.push_back(x);\n        }\n        cout << solve(n, v) << endl;\n        // cout << solveslow(n, v) << endl;\n        for(int i = 0;i <= n*4;i++) {\n            t[i][0] = 0;\n            t[i][1] = 0;\n            t[i][2] = 0;\n            t[i][3] = 0;\n        }\n    }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "problemG2": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "problemG2",
    "problem_title": "G2. Big Wins! (hard version)",
    "time_limit": "4 seconds",
    "memory_limit": "256 megabytes",
    "statement": "This is the hard version of the problem. The difference between the versions is that in this version $$$a_i \\leq n$$$.You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$.Your task is to find a subarray $$$a[l, r]$$$ (a continuous sequence of elements $$$a_l, a_{l + 1}, \\dots, a_r$$$) for which the value of the expression $$$\\text{med}(a[l, r]) - \\min(a[l, r])$$$ is maximized.Here:$$$\\text{med}$$$ is the median of the subarray, that is, the element at position $$$\\left\\lceil \\frac{k + 1}{2} \\right\\rceil$$$ after sorting the subarray, where $$$k$$$ is its length;$$$\\min$$$ is the minimum element of this subarray.For example, consider the array $$$a=[1, 4, 1, 5, 3, 3]$$$ and choose the subarray $$$a[2, 5] = [4, 1, 5, 3]$$$. In sorted form, it looks like $$$[1, 3, 4, 5]$$$.$$$\\text{med}(a[2, 5]) = 4$$$, since $$$\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil = $$$ the third element in the sorted subarray is $$$4$$$;$$$\\min(a[2, 5]) = 1$$$, since the minimum element is $$$1$$$.In this example, the value $$$\\text{med} - \\min = 4 - 1 = 3$$$.\n\nInputThe first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the array.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.\n\nOutputFor each test case, output one integer — the maximum possible value of $$$\\text{med} - \\min$$$ among all subarrays of the array.",
    "sample_inputs": [
      "553 2 5 3 144 1 1 376 1 3 4 6 2 744 2 3 151 2 3 4 5"
    ],
    "sample_outputs": [
      "3\n3\n5\n2\n2"
    ],
    "notes": "NoteIn the first example, consider the array: $$$a=[3,\\ 2,\\ 5,\\ 3,\\ 1]$$$ you can choose the subarray $$$a[2,\\ 3]$$$, that is, the elements $$$[2,\\ 5]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[2,\\ 5]$$$, $$$\\text{med} = 5$$$.The minimum element of the subarray: $$$\\min = 2$$$.Therefore, $$$\\text{med} - \\min = 5 - 2 = 3$$$, which is the maximum answer.In the second test, the array: $$$a=[4,\\ 1,\\ 1,\\ 3]$$$ you can choose the subarray $$$a[1,\\ 2]$$$, that is, the elements $$$[4,\\ 1]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[1,\\ 4]$$$, $$$\\text{med} = 4$$$.The minimum element of the subarray: $$$\\min = 1$$$.Therefore, $$$\\text{med} - \\min = 4 - 1 = 3$$$.It can be proven that both of these subarrays are optimal and yield the maximum value of the expression $$$\\text{med} - \\min$$$.",
    "tags": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dsu",
      "trees",
      "two pointers",
      "*2400"
    ],
    "url": "https://codeforces.com/contest/2126/problem/G2",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [],
    "tutorials": [],
    "editorials": []
  },
  "2129E": {
    "contest_title": "Codeforces Round 1040 (Div. 1)",
    "problem_id": "2129E",
    "problem_title": "E. Induced Subgraph Queries",
    "time_limit": "5 seconds",
    "memory_limit": "512 megabytes",
    "statement": "You are given an unweighted, undirected graph $$$G$$$ with $$$n$$$ nodes and $$$m$$$ edges. The graph $$$G$$$ contains no self-loops or multiple edges.We denote the node set of $$$G$$$ as $$$V$$$. For any node subset $$$V' \\subseteq V$$$, the corresponding induced subgraph, denoted by $$$G[V']$$$, is defined as follows:$$$G[V']$$$ is the graph whose node set is $$$V'$$$, and whose edge set consists of all edges in $$$G$$$ with both endpoints in $$$V'$$$.Your task is to answer $$$q$$$ queries. Each query provides three integers $$$l$$$, $$$r$$$, and $$$k$$$. Denoting $$$V'=\\{l,l+1,\\ldots,r\\}$$$, you need to find the $$$k$$$-th smallest value among $$$f(l,G[V'])$$$, $$$f(l+1,G[V'])$$$, $$$\\ldots$$$ , $$$f(r,G[V'])$$$ (i.e., the $$$k$$$-th value in increasing order; repeated values are counted multiple times).Here, $$$f(u,G[V'])=\\bigoplus_{(u,v)\\in G[V']}v$$$. In other words, it is thebitwise XORvalue of the labels of all adjacent nodes of node $$$u$$$ in graph $$$G[V']$$$.You might want to read the notes for a better understanding.\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 1.5 \\cdot 10^4$$$). The description of the test cases follows.Each test case begins with two integers $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 1.5 \\cdot 10^5$$$, $$$1 \\leq m \\leq 1.5 \\cdot 10^5$$$) — the number of nodes and edges, respectively.The next $$$m$$$ lines each contain two integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\leq u_i, v_i \\leq n$$$, $$$u_i \\neq v_i$$$), representing an undirected edge between nodes $$$u_i$$$ and $$$v_i$$$.The next line contains a single integer $$$q$$$ ($$$1 \\leq q \\leq 1.5 \\cdot 10^5$$$) — the number of queries.Each of the next $$$q$$$ lines contains three integers $$$l$$$, $$$r$$$, and $$$k$$$ ($$$1 \\leq l \\leq r \\leq n$$$, $$$1 \\le k \\le r-l+1$$$), defining a query about the induced subgraph $$$G[\\{l,\\ldots,r\\}]$$$.It is guaranteed that the graph contains no self-loops or multiple edges.It is guaranteed that the sum of $$$n$$$,$$$m$$$, and $$$q$$$ over all test cases does not exceed $$$1.5 \\cdot 10^5$$$, respectively.\n\nOutputFor each test case, output $$$q$$$ integers, representing the answer for each query.",
    "sample_inputs": [
      "24 51 31 42 32 43 431 2 21 3 12 4 32 12 131 1 12 2 11 2 2"
    ],
    "sample_outputs": [
      "0\n3\n7\n0\n0\n2"
    ],
    "notes": "NoteIn the first test case, the input graph $$$G$$$ is the one in the following picture.The given graph $$$G$$$.In the first query, the induced subgraph $$$G[\\{1,2\\}]$$$ is the one in the following picture. We can see that nodes $$$1$$$ and $$$2$$$ have no adjacent nodes. Thus, $$$f(1,G[\\{1,2\\}])=f(2,G[\\{1,2\\}])=0$$$. The $$$2$$$-nd smallest value is $$$0$$$.$$$G[\\{1,2\\}]$$$.In the second query, the induced subgraph $$$G[\\{1,2,3\\}]$$$ is the one in the following picture. We can see that $$$f(1,G[\\{1,2,3\\}])=3$$$, $$$f(2,G[\\{1,2,3\\}])=3$$$, and $$$f(3,G[\\{1,2,3\\}])=1 \\oplus 2=3$$$. The $$$1$$$-st smallest value is $$$3$$$.$$$G[\\{1,2,3\\}]$$$.In the third query, the induced subgraph $$$G[\\{2,3,4\\}]$$$ is the one in the following picture. We can see that $$$f(2,G[\\{2,3,4\\}])=3 \\oplus 4=7$$$, $$$f(3,G[\\{2,3,4\\}])=2 \\oplus 4=6$$$, and $$$f(4,G[\\{2,3,4\\}])=2 \\oplus 3=1$$$. The $$$3$$$-rd smallest value is $$$7$$$.$$$G[\\{2,3,4\\}]$$$.",
    "tags": [
      "data structures",
      "graphs",
      "sortings",
      "*3000"
    ],
    "url": "https://codeforces.com/problemset/problem/2129/E",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1040 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145152",
          "full_url": "https://codeforces.com/blog/entry/145152"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [],
    "tutorials": [],
    "editorials": []
  },
  "2132B": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132B",
    "problem_title": "2132B - The Secret Number",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "If Vadim appends $$$k$$$ zeros to the number $$$x$$$, what will be the ratio between $$$n$$$ and $$$x$$$? Answer$$$n = x \\cdot (10^k + 1)$$$",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long r;\n        cin >> r;\n        \n        long long d = 11;\n        vector <long long> ans;\n        while (r >= d) {\n            if (r % d == 0)\n                ans.push_back(r / d);\n            d = (d - 1) * 10 + 1;\n        }\n        \n        cout << (int)ans.size() << '\\n';\n        for (int i = (int)ans.size() - 1; i >= 0; --i)\n            cout << ans[i] << ' ';\n        cout << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long r;\n        cin >> r;\n        \n        long long d = 11;\n        vector <long long> ans;\n        while (r >= d) {\n            if (r % d == 0)\n                ans.push_back(r / d);\n            d = (d - 1) * 10 + 1;\n        }\n        \n        cout << (int)ans.size() << '\\n';\n        for (int i = (int)ans.size() - 1; i >= 0; --i)\n            cout << ans[i] << ' ';\n        cout << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132C1": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132C1",
    "problem_title": "2132C1 - The Cunning Seller (easy version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Does it make sense to use the same type of deal more than 2 times?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "The solution with the minimum number of deals is unique.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "Ternary numeral system.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n;\n        cin >> n;\n        long long min_k = 0;\n        long long min_cost = 0;\n        int sz = 0;\n        while (n) {\n            min_k += n % 3;\n            min_cost += (n % 3) * cost[sz];\n            n /= 3;\n            sz++;\n        }\n        cout << min_cost << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n;\n        cin >> n;\n        long long min_k = 0;\n        long long min_cost = 0;\n        int sz = 0;\n        while (n) {\n            min_k += n % 3;\n            min_cost += (n % 3) * cost[sz];\n            n /= 3;\n            sz++;\n        }\n        cout << min_cost << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132C2": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132C2",
    "problem_title": "2132C2 - The Cunning Seller (hard version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "What is more profitable: 3 deals for $$$3^x$$$ watermelons each, or 1 deal for $$$3^{x+1}$$$ watermelons?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Recall the solution to problem C1.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n, k;\n        cin >> n >> k;\n        vector <long long> tr;\n        long long min_k = 0;\n        while (n) {\n            tr.push_back(n % 3);\n            min_k += n % 3;\n            n /= 3;\n        }\n        if (min_k > k) {\n            cout << -1 << '\\n';\n            continue;\n        }\n        k -= min_k;\n        k /= 2;\n        for (int i = (int)tr.size() - 1; i >= 1; --i) {\n            if (tr[i] <= k) {\n                tr[i - 1] += 3 * tr[i];\n                k -= tr[i];\n                tr[i] = 0;\n            } else {\n                tr[i - 1] += k * 3;\n                tr[i] -= k;\n                break;\n            }\n        }\n        ll an = 0;\n        for (int i = (int)tr.size() - 1; i >= 0; --i)\n            an += cost[i] * tr[i];\n        cout << an << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n, k;\n        cin >> n >> k;\n        vector <long long> tr;\n        long long min_k = 0;\n        while (n) {\n            tr.push_back(n % 3);\n            min_k += n % 3;\n            n /= 3;\n        }\n        if (min_k > k) {\n            cout << -1 << '\\n';\n            continue;\n        }\n        k -= min_k;\n        k /= 2;\n        for (int i = (int)tr.size() - 1; i >= 1; --i) {\n            if (tr[i] <= k) {\n                tr[i - 1] += 3 * tr[i];\n                k -= tr[i];\n                tr[i] = 0;\n            } else {\n                tr[i - 1] += k * 3;\n                tr[i] -= k;\n                break;\n            }\n        }\n        ll an = 0;\n        for (int i = (int)tr.size() - 1; i >= 0; --i)\n            an += cost[i] * tr[i];\n        cout << an << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132D": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132D",
    "problem_title": "2132D - From 1 to Infinity",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Find out which number the $$$k$$$-th digit belongs to in the infinite sequence. Let this number be $$$n$$$. Instead of analyzing the sequence, we can calculate the sum of the sums of the digits of all integers from $$$0$$$ to $$$n - 1$$$ and add to this the sum of the required digits of the number $$$n$$$.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Mentally add leading zeros to all numbers from $$$0$$$ to $$$n - 1$$$ so that their lengths become the same. The sum of the sums of the digits will not change, but it will be more convenient to determine the formulas in this case.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long k;\n        cin >> k;\n        long long cur = 9, len = 1;\n        while (k - cur * len > 0) {\n            k -= cur * len;\n            cur *= 10;\n            len++;\n        }\n        string s = to_string(cur / 9 + (k - 1) / len);\n        long long ans = 0;\n        for (int i = 0; i < (k - 1) % len + 1; i++)\n            ans += s[i] - '0';\n        long long pr_s = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int curd = s[i] - '0';\n            if (curd)\n                ans += curd * (len - 1) * cur / 2 + curd * (2 * pr_s + curd - 1) / 2 * cur / 9;\n            cur /= 10, len--;\n            pr_s += curd;\n        }\n        cout << ans << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long k;\n        cin >> k;\n        long long cur = 9, len = 1;\n        while (k - cur * len > 0) {\n            k -= cur * len;\n            cur *= 10;\n            len++;\n        }\n        string s = to_string(cur / 9 + (k - 1) / len);\n        long long ans = 0;\n        for (int i = 0; i < (k - 1) % len + 1; i++)\n            ans += s[i] - '0';\n        long long pr_s = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int curd = s[i] - '0';\n            if (curd)\n                ans += curd * (len - 1) * cur / 2 + curd * (2 * pr_s + curd - 1) / 2 * cur / 9;\n            cur /= 10, len--;\n            pr_s += curd;\n        }\n        cout << ans << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132E": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132E",
    "problem_title": "2132E - Arithmetics Competition",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "If we know how many specific cards Vadim should take, and how many should take Kostya (for example when $$$x + y = z$$$). How can we then obtain the maximum possible sum?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "We need to quickly compute the sum of the $$$x$$$ maximum elements in array $$$a$$$ and the sum of the $$$y$$$ maximum elements in array $$$b$$$. What should we do to be able to compute this for arbitrary $$$x$$$ and $$$y$$$ in $$$O(1)$$$?",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "How can we solve this problem if $$$x = n$$$ and $$$y = m$$$ — that is, each person can choose any number of cards, as long as their total is $$$z$$$?",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "If $$$x = n$$$ and $$$y = m$$$, then the optimal set of $$$z$$$ cards consists of $$$x'$$$ maximum cards from Vadim and $$$y'$$$ maximum cards from Kostya (where $$$x' + y' = z$$$). How should we adjust this optimal answer if the optimal number for Vadim or Kostya exceeds their limits (that is, if $$$x < x'$$$ or $$$y < y'$$$)?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution 1",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n\n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n\n    vector <pair <int, int>> ans(n + m + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i < ans.size(); i++) {\n        if (l < n && r < m) {\n            if (a[l] < b[r])\n                r++;\n            else\n                l++;\n        }\n        else if (l == n)\n            r++;\n        else if (r == m)\n            l++;\n        ans[i] = { l, r };\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        l = ans[z].first, r = ans[z].second;\n        if (l > x)\n            cout << pa[x] + pb[z - x] << '\\n';\n        else if (r > y)\n            cout << pa[z - y] + pb[y] << '\\n';\n        else\n            cout << pa[l] + pb[r] << '\\n';\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n\n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n\n    vector <pair <int, int>> ans(n + m + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i < ans.size(); i++) {\n        if (l < n && r < m) {\n            if (a[l] < b[r])\n                r++;\n            else\n                l++;\n        }\n        else if (l == n)\n            r++;\n        else if (r == m)\n            l++;\n        ans[i] = { l, r };\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        l = ans[z].first, r = ans[z].second;\n        if (l > x)\n            cout << pa[x] + pb[z - x] << '\\n';\n        else if (r > y)\n            cout << pa[z - y] + pb[y] << '\\n';\n        else\n            cout << pa[l] + pb[r] << '\\n';\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      },
      {
        "title": "solution 2",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n \n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n \n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n \n        int l = max(0, z - y);\n        int r = min(z, x);\n        while (l + 2 < r) {\n            int m1 = (l + l + r) / 3;\n            int m2 = (l + r + r) / 3;\n            if (pa[m1] + pb[z - m1] > pa[m2] + pb[z - m2]) {\n                r = m2;\n            } else {\n                l = m1;\n            }\n        }\n \n        long long s = 0;\n        for (int i = l; i <= r; i++)\n            s = max(s, pa[i] + pb[z - i]);\n \n        cout << s << '\\n';\n    }\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n \n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n \n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n \n        int l = max(0, z - y);\n        int r = min(z, x);\n        while (l + 2 < r) {\n            int m1 = (l + l + r) / 3;\n            int m2 = (l + r + r) / 3;\n            if (pa[m1] + pb[z - m1] > pa[m2] + pb[z - m2]) {\n                r = m2;\n            } else {\n                l = m1;\n            }\n        }\n \n        long long s = 0;\n        for (int i = l; i <= r; i++)\n            s = max(s, pa[i] + pb[z - i]);\n \n        cout << s << '\\n';\n    }\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132F": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132F",
    "problem_title": "2132F - Rada and the Chamomile Valley",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Recall or learn what bridges are and understand how this is related to the lanes that lie on all paths from $$$1$$$ to $$$n$$$.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "How to find all the bridges that lie on every path from $$$1$$$ to $$$n$$$?",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "Solve the problem for the case where $$$n = q$$$ and $$$c_i = i$$$.",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "How to find the nearest vertex from a given set of vertices $$$S$$$ for each vertex?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvector <vector <int>> g;\nvector <bool> used;\nvector <int> d, h;\nvector <pair <int, int>> edges;\nvector <int> cut, path;\nint mark = 1;\n\nvoid dfs(int v, int p, int n) {\n    used[v] = true;\n    d[v] = h[v] = (p == -1 ? 0 : d[p] + 1);\n    if (v == n) mark = 0;\n    for (auto e : g[v]) {\n        int to = edges[e].first + edges[e].second - v;\n        if (to == p) continue;\n        if (used[to])\n            h[v] = min(h[v], d[to]);\n        else {\n            path[e] ^= mark;\n            dfs(to, v, n);\n            path[e] ^= mark;\n            h[v] = min(h[v], h[to]);\n            if (h[to] > d[v]) cut[e] = 1;\n        }\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        g.assign(n + 1, {});\n        used.assign(n + 1, false);\n        d.assign(n + 1, 0);\n        h.assign(n + 1, 0);\n        edges = {};\n        cut.assign(m, false);\n        path.assign(m, false);\n        mark = 1;\n        for (int i = 0; i < m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            edges.push_back({a, b});\n            g[a].push_back(i);\n            g[b].push_back(i);\n        }\n        \n        dfs(1, -1, n);\n        \n        vector <int> ans(n + 1, n + m);\n        vector <int> dist(n + 1, n + m);\n        queue <int> q;\n        for (int i = 0; i < m; ++i) {\n            if (cut[i] && path[i]) {\n                ans[edges[i].first] = min(ans[edges[i].first], i + 1);\n                ans[edges[i].second] = min(ans[edges[i].second], i + 1);\n                if (dist[edges[i].first]) {\n                    dist[edges[i].first] = 0;\n                    q.push(edges[i].first);\n                }\n                if (dist[edges[i].second]) {\n                    dist[edges[i].second] = 0;\n                    q.push(edges[i].second);\n                }\n            }\n        }\n        \n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (auto e : g[v]) {\n                int to = edges[e].first + edges[e].second - v;\n                if (dist[to] > dist[v] + 1) {\n                    dist[to] = dist[v] + 1;\n                    ans[to] = ans[v];\n                    q.push(to);\n                }\n                else if (dist[to] == dist[v] + 1)\n                    ans[to] = min(ans[to], ans[v]);\n            }\n        }\n        \n        int Q;\n        cin >> Q;\n        while (Q--) {\n            int v;\n            cin >> v;\n            if (ans[v] == n + m) cout << -1;\n            else cout << ans[v];\n            if (t || Q) cout << '\\n';\n        }\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvector <vector <int>> g;\nvector <bool> used;\nvector <int> d, h;\nvector <pair <int, int>> edges;\nvector <int> cut, path;\nint mark = 1;\n\nvoid dfs(int v, int p, int n) {\n    used[v] = true;\n    d[v] = h[v] = (p == -1 ? 0 : d[p] + 1);\n    if (v == n) mark = 0;\n    for (auto e : g[v]) {\n        int to = edges[e].first + edges[e].second - v;\n        if (to == p) continue;\n        if (used[to])\n            h[v] = min(h[v], d[to]);\n        else {\n            path[e] ^= mark;\n            dfs(to, v, n);\n            path[e] ^= mark;\n            h[v] = min(h[v], h[to]);\n            if (h[to] > d[v]) cut[e] = 1;\n        }\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        g.assign(n + 1, {});\n        used.assign(n + 1, false);\n        d.assign(n + 1, 0);\n        h.assign(n + 1, 0);\n        edges = {};\n        cut.assign(m, false);\n        path.assign(m, false);\n        mark = 1;\n        for (int i = 0; i < m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            edges.push_back({a, b});\n            g[a].push_back(i);\n            g[b].push_back(i);\n        }\n        \n        dfs(1, -1, n);\n        \n        vector <int> ans(n + 1, n + m);\n        vector <int> dist(n + 1, n + m);\n        queue <int> q;\n        for (int i = 0; i < m; ++i) {\n            if (cut[i] && path[i]) {\n                ans[edges[i].first] = min(ans[edges[i].first], i + 1);\n                ans[edges[i].second] = min(ans[edges[i].second], i + 1);\n                if (dist[edges[i].first]) {\n                    dist[edges[i].first] = 0;\n                    q.push(edges[i].first);\n                }\n                if (dist[edges[i].second]) {\n                    dist[edges[i].second] = 0;\n                    q.push(edges[i].second);\n                }\n            }\n        }\n        \n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (auto e : g[v]) {\n                int to = edges[e].first + edges[e].second - v;\n                if (dist[to] > dist[v] + 1) {\n                    dist[to] = dist[v] + 1;\n                    ans[to] = ans[v];\n                    q.push(to);\n                }\n                else if (dist[to] == dist[v] + 1)\n                    ans[to] = min(ans[to], ans[v]);\n            }\n        }\n        \n        int Q;\n        cin >> Q;\n        while (Q--) {\n            int v;\n            cin >> v;\n            if (ans[v] == n + m) cout << -1;\n            else cout << ans[v];\n            if (t || Q) cout << '\\n';\n        }\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132G": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132G",
    "problem_title": "2132G - Famous Choreographer",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "There is no point in adding new symbols both above and below the original table simultaneously. Similarly, there is no point in adding symbols both to the left and to the right of the table at the same time.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "The center of the optimal answer table lies within the original one.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "We do not need to construct the answer; it is sufficient to check that an answer exists for the current center. Think about how to do this.",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "An answer exists for the current center if the subtable, which is the intersection of the original table and the one rotated around the center by $$$180^{\\circ}$$$, becomes identical to the original when rotated by $$$180^{\\circ}$$$. This subtable must contain at least one of the corners of the original table.",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "The checking of centers can be replaced by the checking of subtables that contain at least one of the corners of the original table.",
        "codes": []
      },
      {
        "title": "hint 6",
        "text": "To check the subtables to see if they become identical to the original when rotated by $$$180^{\\circ}$$$, we can use hashing.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MOD = 998244353;\nconst int P[2] = { 107, 61 };\nint BP[2];\n\nlong long bin_pow(long long a, int n) {\n    long long ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % MOD;\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return ret;\n}\n\ninline int add(int a, int b) {\n    int res = a + b;\n    if (res >= MOD) return res - MOD;\n    return res;\n}\n\ninline int sub(int a, int b) {\n    int res = a - b;\n    if (res < 0) return res + MOD;\n    return res;\n}\n\ninline int mult(int a, int b) {\n    long long res = (long long)a * b;\n    if (res >= MOD) return res % MOD;\n    return res;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    BP[0] = bin_pow(P[0], MOD - 2);\n    BP[1] = bin_pow(P[1], MOD - 2);\n    vector <int> pows[2];\n    vector <int> bpows[2];\n    for (int j = 0; j < 2; j++) {\n        pows[j].resize(1e6, 1);\n        bpows[j].resize(1e6, 1);\n        for (int i = 1; i < 1e6; i++) {\n            pows[j][i] = mult(pows[j][i - 1], P[j]);\n            bpows[j][i] = mult(bpows[j][i - 1], BP[j]);\n        }\n    }\n    \n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector <string> f(n);\n        for (int i = 0; i < n; i++)\n            cin >> f[i];\n        \n        vector <vector <int>> hash(n + 2, vector <int> (m + 2, 0));\n        vector <vector <int>> bhash(n + 2, vector <int> (m + 2, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][i - 1], pows[1][j - 1]));\n                hash[i][j] = add(sub(add(hash[i - 1][j], hash[i][j - 1]), hash[i - 1][j - 1]), cur);\n            }\n        }\n        for (int i = n; i >= 1; i--) {\n            for (int j = m; j >= 1; j--) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][n - i], pows[1][m - j]));\n                bhash[i][j] = add(sub(add(bhash[i + 1][j], bhash[i][j + 1]), bhash[i + 1][j + 1]), cur);\n            }\n        }\n        \n        auto isp = [&](int x1, int y1, int x2, int y2) {\n            int hsh = add(sub(sub(hash[x2][y2], hash[x1-1][y2]), hash[x2][y1-1]), hash[x1-1][y1-1]);\n            int bhsh = add(sub(sub(bhash[x1][y1], bhash[x2+1][y1]), bhash[x1][y2+1]), bhash[x2+1][y2+1]);\n            hsh = mult(hsh, mult(bpows[0][x1 - 1], bpows[1][y1 - 1]));\n            bhsh = mult(bhsh, mult(bpows[0][n - x2], bpows[1][m - y2]));\n            return hsh == bhsh;\n        };\n        \n        int mn = n * m * 4;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (isp(1, 1, i, j)) mn = min(mn, (2 * n - i) * (2 * m - j));\n                if (isp(1, j, i, m)) mn = min(mn, (2 * n - i) * (m + j - 1));\n                if (isp(i, 1, n, j)) mn = min(mn, (n + i - 1) * (2 * m - j));\n                if (isp(i, j, n, m)) mn = min(mn, (n + i - 1) * (m + j - 1));\n            }\n        }\n        \n        cout << mn - m * n << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MOD = 998244353;\nconst int P[2] = { 107, 61 };\nint BP[2];\n\nlong long bin_pow(long long a, int n) {\n    long long ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % MOD;\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return ret;\n}\n\ninline int add(int a, int b) {\n    int res = a + b;\n    if (res >= MOD) return res - MOD;\n    return res;\n}\n\ninline int sub(int a, int b) {\n    int res = a - b;\n    if (res < 0) return res + MOD;\n    return res;\n}\n\ninline int mult(int a, int b) {\n    long long res = (long long)a * b;\n    if (res >= MOD) return res % MOD;\n    return res;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    BP[0] = bin_pow(P[0], MOD - 2);\n    BP[1] = bin_pow(P[1], MOD - 2);\n    vector <int> pows[2];\n    vector <int> bpows[2];\n    for (int j = 0; j < 2; j++) {\n        pows[j].resize(1e6, 1);\n        bpows[j].resize(1e6, 1);\n        for (int i = 1; i < 1e6; i++) {\n            pows[j][i] = mult(pows[j][i - 1], P[j]);\n            bpows[j][i] = mult(bpows[j][i - 1], BP[j]);\n        }\n    }\n    \n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector <string> f(n);\n        for (int i = 0; i < n; i++)\n            cin >> f[i];\n        \n        vector <vector <int>> hash(n + 2, vector <int> (m + 2, 0));\n        vector <vector <int>> bhash(n + 2, vector <int> (m + 2, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][i - 1], pows[1][j - 1]));\n                hash[i][j] = add(sub(add(hash[i - 1][j], hash[i][j - 1]), hash[i - 1][j - 1]), cur);\n            }\n        }\n        for (int i = n; i >= 1; i--) {\n            for (int j = m; j >= 1; j--) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][n - i], pows[1][m - j]));\n                bhash[i][j] = add(sub(add(bhash[i + 1][j], bhash[i][j + 1]), bhash[i + 1][j + 1]), cur);\n            }\n        }\n        \n        auto isp = [&](int x1, int y1, int x2, int y2) {\n            int hsh = add(sub(sub(hash[x2][y2], hash[x1-1][y2]), hash[x2][y1-1]), hash[x1-1][y1-1]);\n            int bhsh = add(sub(sub(bhash[x1][y1], bhash[x2+1][y1]), bhash[x1][y2+1]), bhash[x2+1][y2+1]);\n            hsh = mult(hsh, mult(bpows[0][x1 - 1], bpows[1][y1 - 1]));\n            bhsh = mult(bhsh, mult(bpows[0][n - x2], bpows[1][m - y2]));\n            return hsh == bhsh;\n        };\n        \n        int mn = n * m * 4;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (isp(1, 1, i, j)) mn = min(mn, (2 * n - i) * (2 * m - j));\n                if (isp(1, j, i, m)) mn = min(mn, (2 * n - i) * (m + j - 1));\n                if (isp(i, 1, n, j)) mn = min(mn, (n + i - 1) * (2 * m - j));\n                if (isp(i, j, n, m)) mn = min(mn, (n + i - 1) * (m + j - 1));\n            }\n        }\n        \n        cout << mn - m * n << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132A": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132A",
    "problem_title": "A. Homework",
    "time_limit": "1 second",
    "memory_limit": "256 megabytes",
    "statement": "Vlad and Dima have been assigned a task in school for their English class. They were given two strings $$$a$$$ and $$$b$$$ and asked to append all characters from $$$b$$$ to string $$$a$$$ in any order. The guys decided to divide the work between themselves and, after lengthy negotiations, determined who would add each character from string $$$b$$$ to $$$a$$$.Due to his peculiarities, Vlad can only add characters to the beginning of the word, while Dima can only add them to the end. They add characters in the order they appear in string $$$b$$$. Your task is to determine what string Vlad and Dima will end up with.\n\nInputEach test consists of several test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The description of the test cases follows.The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10$$$) — the length of the string $$$a$$$.The second line contains the string $$$a$$$, consisting of lowercase letters of the English alphabet.The third line contains an integer $$$m$$$ ($$$1 \\le m \\le 10$$$) — the length of the strings $$$b$$$ and $$$c$$$.The fourth line contains the string $$$b$$$, consisting of lowercase letters of the English alphabet.The fifth line contains the string $$$c$$$, consisting of the characters'V'and'D'— the distribution of the characters of string $$$b$$$ between Dima and Vlad. If $$$c_i$$$ ='V', then the $$$i$$$-th letter is added by Vlad; otherwise, it is added by Dima.\n\nOutputFor each test case, output the string that will result from Dima and Vlad's work.",
    "sample_inputs": [
      "42ot2adDV3efo7rdcoecsDVDVDVD3aca4bbaaDVDV3biz4abonVVDD"
    ],
    "sample_outputs": [
      "dota\ncodeforces\nabacaba\nbabizon"
    ],
    "notes": "NoteIn the first test case, there is initially a string $$$ot$$$. Then Dima appends the character $$$a$$$ to the end of the string, resulting in $$$ota$$$, and Vlad appends the last character, resulting in $$$dota$$$.In the second test case, the string will change as follows: $$$efo \\rightarrow efor \\rightarrow defor \\rightarrow deforc \\rightarrow odeforc \\rightarrow odeforce \\rightarrow codeforce \\rightarrow codeforces$$$In the third test case: $$$aca \\rightarrow acab \\rightarrow bacab \\rightarrow bacaba \\rightarrow abacaba$$$In the fourth test case: $$$biz \\rightarrow abiz \\rightarrow babiz \\rightarrow babizo \\rightarrow babizon$$$",
    "tags": [
      "brute force",
      "implementation",
      "strings",
      "*800"
    ],
    "url": "https://codeforces.com/problemset/problem/2132/A",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve() {\n    string a, b, c;\n    int n, m;\n    cin >> n >> a;\n    cin >> m >> b >> c;\n    string add_left = \"\";\n    for (int i = 0; i < m; ++i) {\n        if (c[i] == 'V') {\n            add_left += b[i];\n        } else {\n            a += b[i];\n        }\n    }\n    reverse(add_left.begin(), add_left.end());\n    cout << add_left + a << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve() {\n    string a, b, c;\n    int n, m;\n    cin >> n >> a;\n    cin >> m >> b >> c;\n    string add_left = \"\";\n    for (int i = 0; i < m; ++i) {\n        if (c[i] == 'V') {\n            add_left += b[i];\n        } else {\n            a += b[i];\n        }\n    }\n    reverse(add_left.begin(), add_left.end());\n    cout << add_left + a << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2138C1": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138C1",
    "problem_title": "C1. Maple and Tree Beauty (Easy Version)",
    "time_limit": "3 seconds",
    "memory_limit": "1024 megabytes",
    "statement": "This is the easy version of the problem. The difference between the versions is that in this version, the constraints on $$$t$$$ and $$$n$$$ are smaller. You can hack only if you solved all versions of this problem.Maple is given a rooted tree consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$, where the root has index $$$1$$$. Each vertex of the tree is labeled either zero or one. Unfortunately, Maple forgot how the vertices are labeled and only remembers that there are exactly $$$k$$$ zeros and $$$n - k$$$ ones.For each vertex, we define thenameof the vertex as the binary string formed by concatenating the labels of the vertices from the root to the vertex. More formally, $$$\\text{name}_1 = \\text{label}_1$$$ and $$$\\text{name}_u = \\text{name}_{p_u} + \\text{label}_u$$$ for all $$$2\\le u\\le n$$$, where $$$p_u$$$ is the parent of vertex $$$u$$$ and $$$+$$$ represents string concatenation.Thebeautyof the tree is equal to the length of the longest common subsequence$$$^{\\text{∗}}$$$ of the names of all theleaves$$$^{\\text{†}}$$$. Your task is to determine the maximum beauty among all labelings of the tree with exactly $$$k$$$ zeros and $$$n - k$$$ ones.$$$^{\\text{∗}}$$$A sequence $$$a$$$ is a subsequence of a sequence $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by the deletion of several (possibly, zero or all) element from arbitrary positions.  The longest common subsequence of strings $$$s_1, s_2, \\ldots s_m$$$ is the longest string that is a subsequence of all of $$$s_1, s_2, \\ldots, s_m$$$.$$$^{\\text{†}}$$$A leaf is any vertex without children.\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 50$$$). The description of the test cases follows.The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\leq n \\leq 1000$$$, $$$0 \\leq k \\leq n$$$) — the number of vertices and the number of vertices labeled with zero, respectively.The second line contains $$$n - 1$$$ integers $$$p_2, p_3, \\ldots, p_{n}$$$ ($$$1 \\leq p_i \\le i - 1$$$) — the parent of vertex $$$i$$$.Note that there areno constraintson the sum of $$$n$$$ over all test cases.\n\nOutputFor each test case, output a single integer representing the maximum beauty among all labelings of the tree with exactly $$$k$$$ zeros and $$$n - k$$$ ones.",
    "sample_inputs": [
      "57 31 1 2 2 3 37 21 1 2 3 1 15 01 2 3 45 21 1 1 15 41 1 1 1",
      "52 012 113 01 13 11 23 11 1"
    ],
    "sample_outputs": [
      "3\n2\n5\n1\n2",
      "2\n2\n2\n3\n2"
    ],
    "notes": "NoteIn the first test case, the maximum beauty is $$$3$$$, when the vertices are labeled with $$$[0, 0, 0, 1, 1, 1, 1]$$$, and the longest common subsequence is001.In the second test case, the maximum beauty is $$$2$$$, when the vertices are labeled with $$$[1, 0, 0, 1, 1, 1, 1]$$$, and the longest common subsequence is11.",
    "tags": [
      "dfs and similar",
      "dp",
      "graphs",
      "trees"
    ],
    "url": "https://codeforces.com/problemset/problem/2138/C1",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "We can first find out that the maximum possible answer is the minimum depth among all leaves $$$d=\\min{dep_u}$$$, as the LCS can't be greater than the minimum length of all names.We consider a special case first where all leaves have the same depth. If we want to achieve the maximum answer $$$d$$$, the names of all leaves should be exactly the same. Which means, for any two vertices with the same depth, their label has to be the same.For each depth $$$i$$$, we group all vertices with depth $$$i$$$ together as the $$$i$$$-th group (suppose root has depth $$$1$$$). For each group, all vertices in the group should have the same label. Let the size of groups $$$1,\\cdots,d$$$ be $$$c_1,\\cdots,c_d$$$. Now the problem can be considered as a knapsack problem, where you have $$$d$$$ items with weight $$$c_1,\\cdots,c_d$$$. We need to find out whether you can take several numbers from $$$c$$$ that have sum equal to $$$k$$$. This can be solved in $$$O(n^2)$$$.If the maximum answer $$$d$$$ is not achievable, we can show that you can always achieve $$$w-1$$$. From for each group from the first to the $$$d$$$-th, we assgin an arbitrary label which still have at least $$$c_i$$$ numbers remaining to all vertices in the group. As all leaves have the same depth, $$$c_d$$$ should be the maximum element in the array, so you are always able to select a label for groups $$$1$$$ to $$$d-1$$$. Then arbitrarily distribute the remaining labels among vertices in the last groups (which are leaves)..Now consider the general case where not all leaves have the same depth. If we want to achieve answer $$$=d$$$, we need to select $$$d$$$ groups. For each leaf vertex $$$v$$$, there should exist a vertex in the $$$d$$$-th group which is an ancestor of $$$v$$$. And for every $$$2\\le i\\le d$$$, for each vertex $$$v$$$ in the $$$i$$$-th group, there should exist a vertex in the $$$i-1$$$-th group which is an ancestor of $$$v$$$. All vertices in the same group should have the same label. Suppose the $$$i$$$-th group has label $$$l_i$$$, then we can achieve $$$\\text{LCS}=l_1l_2\\ldots l_d$$$ which has length $$$d$$$.We can still group all vertices with depth $$$1\\le i\\le d$$$ together as the $$$i$$$-th group. For all vertices with depth $$$>d$$$, we can set their label arbitrarily. We can view them as items with weight $$$1$$$ in the knapsack problem.And we can show this is the optimal way to select $$$d$$$ groups. If some vertex $$$u$$$ with depth $$$\\le d$$$ is not selected, there must be some vertices selected in some group in the subtree of $$$u$$$, because the path from root to $$$u$$$ consists of less than $$$d$$$ vertices. If the smallest group index that some vertex in the subtree of $$$u$$$ belongs to is $$$i$$$, we can instead let $$$u$$$ be inside the $$$i$$$-th group, and then the labels of all vertices in the subtree $$$u$$$ that were previously in group $$$i$$$ can be selected arbitrarily. If we consider the knapsack problem, we have reduced some $$$c_i$$$ by $$$x$$$ and added $$$x$$$ items with weight $$$1$$$. All achievable values still remain achievable, while some previously unachievable values become achievable.The time complexity is $$$O(n^2)$$$, the bottleneck is knapsack.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "// n^2/w\n#include <bits/stdc++.h>\nusing namespace std;\nint solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> fa(n, -1), dep(n, 0);\n    vector<int> noson(n, 1), cnt(n + 1);\n    cnt[0]++;\n    for (int i = 1; i < n; i++) {\n        cin >> fa[i], fa[i]--;\n        dep[i] = dep[fa[i]] + 1;\n        cnt[dep[i]]++;\n        noson[fa[i]] = 0;\n    }\n    int mxdep = 1e9;\n    for (int i = 0; i < n; i++)\n        if (noson[i]) mxdep = min(mxdep, dep[i]);\n \n    int sum = 0;\n \n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    for (int i = 0; i <= mxdep; i++) {\n        for (int j = sum; j >= 0; j--) dp[j + cnt[i]] |= dp[j];\n        sum += cnt[i];\n    }\n    if (sum <= k || sum <= n - k) return mxdep + 1;\n    for (int i = 0; i <= sum; i++)\n        if (dp[i]) {\n            if (i <= k && sum - i <= n - k) return mxdep + 1;\n        }\n    return mxdep;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) cout << solve() << \"\\n\";\n    return 0;\n}",
        "codes": [
          "// n^2/w\n#include <bits/stdc++.h>\nusing namespace std;\nint solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> fa(n, -1), dep(n, 0);\n    vector<int> noson(n, 1), cnt(n + 1);\n    cnt[0]++;\n    for (int i = 1; i < n; i++) {\n        cin >> fa[i], fa[i]--;\n        dep[i] = dep[fa[i]] + 1;\n        cnt[dep[i]]++;\n        noson[fa[i]] = 0;\n    }\n    int mxdep = 1e9;\n    for (int i = 0; i < n; i++)\n        if (noson[i]) mxdep = min(mxdep, dep[i]);\n \n    int sum = 0;\n \n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    for (int i = 0; i <= mxdep; i++) {\n        for (int j = sum; j >= 0; j--) dp[j + cnt[i]] |= dp[j];\n        sum += cnt[i];\n    }\n    if (sum <= k || sum <= n - k) return mxdep + 1;\n    for (int i = 0; i <= sum; i++)\n        if (dp[i]) {\n            if (i <= k && sum - i <= n - k) return mxdep + 1;\n        }\n    return mxdep;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) cout << solve() << \"\\n\";\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139A": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139A",
    "problem_title": "2139A - Maple and Multiplication",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "If $$$a=b$$$ we need $$$0$$$ steps.If $$$a$$$ can be divided by $$$b$$$, we only need $$$1$$$ step, which is to multiply $$$b$$$ by $$$\\frac{a}{b}$$$. Same for the case when $$$b$$$ can be divided by $$$a$$$.Otherwise, we need at most $$$2$$$ steps. As both $$$a$$$ and $$$b$$$ are positive integers, we can first multiply $$$a$$$ by $$$b$$$ and then multiply $$$b$$$ by the original value of $$$a$$$. Both number will be equal to $$$a\\times b$$$.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nint solve(){\n    int a,b;\n    cin >> a >> b;\n    if(a == b) return 0;\n    if(a % b == 0 || b % a == 0) return 1;\n    return 2;\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    int TC;\n    cin >> TC;\n    while(TC --){\n        cout << solve() << '\\n';\n    }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nint solve(){\n    int a,b;\n    cin >> a >> b;\n    if(a == b) return 0;\n    if(a % b == 0 || b % a == 0) return 1;\n    return 2;\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    int TC;\n    cin >> TC;\n    while(TC --){\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n\n\n\n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139B": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139B",
    "problem_title": "2139B - Cake Collection",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "The number of cakes collected from an oven depends only on the last time Maple visits it. Therefore, in the optimal strategy, she should visit distinct ovens in the last $$$\\min(m,n)$$$ seconds.Let's think in reverse: suppose we fix an order $$$p_1,\\dots,p_n$$$ of the ovens. Then at second $$$m$$$ we visit oven $$$p_1$$$, at second $$$m-1$$$ we visit oven $$$p_2$$$, and so on. For the $$$i$$$-th oven in this order, we collect $$$a_{p_i}\\cdot \\max(0, m-i+1)$$$ cakes.To maximize the total number of cakes collected, ovens with larger $$$a_i$$$ should be visited later (i.e., assigned larger multipliers). Thus we sort $$$a$$$ in non-increasing order first.The final answer is $$$\\sum_{i=1}^n a_i \\cdot \\max(0, m-i+1)$$$.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\n \nvoid solve(){\n    int n,t;\n    cin >> n >> t;\n    ll ans = 0;\n    vector <int> a(n);\n    for(int i = 0;i < n;i ++) cin >> a[i];\n    sort(a.begin(),a.begin() + n,greater <int>());\n    for(int i = 0;i < n;i ++) ans += 1ll * a[i] * max(0,t - i);\n    cout << ans << '\\n';\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    int TC;\n    cin >> TC;\n    while(TC --){\n        solve();\n    }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\n \nvoid solve(){\n    int n,t;\n    cin >> n >> t;\n    ll ans = 0;\n    vector <int> a(n);\n    for(int i = 0;i < n;i ++) cin >> a[i];\n    sort(a.begin(),a.begin() + n,greater <int>());\n    for(int i = 0;i < n;i ++) ans += 1ll * a[i] * max(0,t - i);\n    cout << ans << '\\n';\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    int TC;\n    cin >> TC;\n    while(TC --){\n        solve();\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2138A": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138A",
    "problem_title": "2138A - Cake Assignment",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "You can backtrack from the final state.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Denote the state $$$(a,b)$$$ that indicates Chocola has $$$a$$$ cakes and Vanilla has $$$b$$$ cakes.After one operation of type $$$1$$$, Vanilla's number of cakes will definitely be at least half of the total, and similarly for operation $$$2$$$. If $$$0 < a < 2^{k}$$$, then $$$2^{k} < b < 2^{k+1}$$$, meaning the previous operation must have been type $$$1$$$. Similarly, if $$$0 < b < 2^{k}$$$, the previous operation must have been type $$$2$$$.Therefore, you can backtrack from the final state $$$(x,2^{k+1}-x)$$$, until it reaches the initial state $$$(2^k,2^k)$$$.Now let's analyze how many steps we need to do during the process.For the state $$$(a, b)$$$, where $$$a, b \\neq 0$$$, assume $$$a = i \\cdot 2^{p_a}$$$ and $$$b = j \\cdot 2^{p_b}$$$, $$$i$$$ and $$$j$$$ are positive odd integers.Since $$$a + b = 2^{k+1}$$$, it must be true that $$$ 0 \\le p_a = p_b \\le k$$$ , and after one operation $$$1$$$ or $$$2$$$, both $$$p_a$$$ and $$$p_b$$$ decrease by exactly $$$1$$$.Therefore, the whole process takes at most $$$k$$$ steps, so we solve the problem with $$$O(tk)$$$ time complexity.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h> \nusing namespace std;\nint main(){\n    int t; cin>>t;\n    while(t--){\n        long long k,x,kk; cin>>k>>x; kk=1ll<<k;\n        if (!x||x==kk*2) {cout<<\"-1\\n\"; continue;}\n        long long y=kk*2-x;\n        vector<int> ans; ans.clear();\n        while(x!=kk){\n            if (x>y) ans.push_back(2),x-=y,y*=2;\n            else ans.push_back(1),y-=x,x*=2;\n        }\n        cout<<ans.size()<<\"\\n\";\n        while(!ans.empty()) cout<<ans.back()<<' ',ans.pop_back();\n        cout<<\"\\n\";\n    }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h> \nusing namespace std;\nint main(){\n    int t; cin>>t;\n    while(t--){\n        long long k,x,kk; cin>>k>>x; kk=1ll<<k;\n        if (!x||x==kk*2) {cout<<\"-1\\n\"; continue;}\n        long long y=kk*2-x;\n        vector<int> ans; ans.clear();\n        while(x!=kk){\n            if (x>y) ans.push_back(2),x-=y,y*=2;\n            else ans.push_back(1),y-=x,x*=2;\n        }\n        cout<<ans.size()<<\"\\n\";\n        while(!ans.empty()) cout<<ans.back()<<' ',ans.pop_back();\n        cout<<\"\\n\";\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2138B": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138B",
    "problem_title": "2138B - Antiamuny Wants to Learn Swap",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "For array $$$b$$$, we can prove that $$$f(b)\\neq g(b)$$$ if and only if there exists indexes $$$1\\le i<j<k\\le m$$$ which satisfies $$$b_i>b_j>b_k$$$.Since $$$a$$$ is a permutation, all elements in $$$b$$$ should be distinct. $$$g(b)$$$ is equal to the number of inversions in $$$b$$$. When there exists some index $$$i$$$ that satisfies $$$a_i>a_{i+1}>a_{i+2}$$$, we can reduce the number of inversions by $$$3$$$ by applying operation $$$2$$$, allowing $$$f(b)$$$ to become less than $$$g(b)$$$. This is the only case where you can reduce more than $$$1$$$ inversion with one operation.If there exists indexes $$$1\\le i<j<k\\le m$$$ which satisfies $$$b_i>b_j>b_k$$$. We can first choose index $$$i,k$$$, then move all elements greater than $$$b_i$$$ to the right of $$$b_k$$$ and move all elements less than $$$b_k$$$ to the left of $$$b_i$$$ by swapping adjacent numbers (applying the first operation). Now all elements $$$b_p$$$ between $$$b_i,b_k$$$ satisfy $$$b_i>b_p>b_k$$$. We then swap them to the left of $$$b_i$$$ until there is only one element $$$b_j$$$ left. Now $$$b_i>b_j>b_k$$$ and they are adjacent, and we can apply operation $$$2$$$ on the current index of $$$b_i$$$.If we only apply operation 1 on indexes $$$i$$$ which satisfy $$$b_i>b_{i+1}$$$, there will never exist any index $$$i$$$ satisfying $$$b_i>b_{i+1}>b_{i+2}$$$ in $$$b$$$ during the process. If we apply an operation $$$1$$$ on some index $$$i$$$ where $$$b_i<b_{i+1}$$$, the number of inversions will be increased by $$$1$$$ instead of decreased by $$$1$$$, which makes it impossible to reach $$$f(b)<g(b)$$$ with one operation $$$2$$$, even i it decreases number of inversions by $$$3$$$. Therefore, in this case $$$f(b)=g(b)$$$.For each element $$$a_i$$$, we define:  $$$l_i$$$: the maximum index $$$< i$$$ such that $$$a_{l_i} > a_i$$$, $$$r_i$$$: the minimum index $$$> i$$$ such that $$$a_{r_i} < a_i$$$. Then the answer to a query $$$[l, r]$$$ is $$$\\texttt{NO}$$$ if and only if some segment $$$[l_i, r_i]$$$ lies fully inside $$$[l, r]$$$.To answer multiple queries, you can preprocess the smallest $$$r$$$ for every $$$l$$$ such that the answers for all $$$[l,x](x\\ge r)$$$ should be $$$\\texttt{NO}$$$.The time complexity is $$$O(n)$$$ if you find $$$l_i,r_i$$$ with the Monotonic Stack trick. $$$O(n\\log n)$$$ solutions can also pass.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n + 2);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n \n    vector<int> mxl(n + 1), mir(n + 1);\n    for (int i = 1; i <= n; i++)\n    {\n        mxl[i] = i - 1;\n        while (mxl[i] > 0 && a[mxl[i]] < a[i])\n            mxl[i] = mxl[mxl[i]];\n    }\n    for (int i = n; i >= 1; i--)\n    {\n        mir[i] = i + 1;\n        while (mir[i] <= n && a[mir[i]] > a[i])\n            mir[i] = mir[mir[i]];\n    }\n    vector<int> L(n + 1, 0);\n    for (int i = 2; i < n; i++)\n    {\n        if (mxl[i] > 0 && mir[i] <= n)\n        {\n            L[mir[i]] = max(L[mir[i]], mxl[i]);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        L[i] = max(L[i], L[i - 1]);\n    }\n \n    for (int i = 0; i < q; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        if (l <= L[r])\n            cout << \"NO\\n\";\n        else\n            cout << \"YES\\n\";\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        solve();\n    }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n + 2);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n \n    vector<int> mxl(n + 1), mir(n + 1);\n    for (int i = 1; i <= n; i++)\n    {\n        mxl[i] = i - 1;\n        while (mxl[i] > 0 && a[mxl[i]] < a[i])\n            mxl[i] = mxl[mxl[i]];\n    }\n    for (int i = n; i >= 1; i--)\n    {\n        mir[i] = i + 1;\n        while (mir[i] <= n && a[mir[i]] > a[i])\n            mir[i] = mir[mir[i]];\n    }\n    vector<int> L(n + 1, 0);\n    for (int i = 2; i < n; i++)\n    {\n        if (mxl[i] > 0 && mir[i] <= n)\n        {\n            L[mir[i]] = max(L[mir[i]], mxl[i]);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        L[i] = max(L[i], L[i - 1]);\n    }\n \n    for (int i = 0; i < q; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        if (l <= L[r])\n            cout << \"NO\\n\";\n        else\n            cout << \"YES\\n\";\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        solve();\n    }\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2138C2": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138C2",
    "problem_title": "2138C2 - Maple and Tree Beauty (Hard Version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "We focus on optimizing the knapsack problem. In the knapsack problem we only need to know $$$f_i=0/1$$$ which means whether you can achieve sum $$$i$$$, so we can optimize the knapsack with bitset. The time complexity is $$$O(\\frac{n^2}{\\omega})$$$ which is enough to pass E2.But actually we can do better. For the knapsack problem, it has at most $$$n$$$ items, and the sum of weights of all items is also at most $$$n$$$. We can do a sqrt decomposition trick here.   For items with weight $$$\\ge\\sqrt{n}$$$, there are at most $$$\\sqrt{n}$$$ such items. For items with weight $$$<\\sqrt{n}$$$, we count the number of items for each different weight. If there are $$$c_w$$$ items for weight $$$w$$$, we decompose $$$x$$$ into $$$c_w=2^0+2^1+\\cdots+2^k+y$$$ where $$$k$$$ is the largest integer satisfying $$$2^0+2^1+\\ldots+2^k\\le c_w$$$. Then we create new items new items with weights $$$2^0\\cdot w,2^1\\cdot w,\\ldots,2^k\\cdot w,y\\cdot w$$$. The set of new items is same as $$$c_w$$$ items with weight $$$w$$$ if we only consider the different sum of weights the set of items can achieve. Now we only have $$$\\sum_{w=1}^{\\sqrt{n}}\\log(c_w)=\\sqrt{n}$$$ items. The total time complexity is $$$O(\\sqrt{n}\\cdot n+\\sqrt{n}\\cdot n)=O(n\\sqrt{n})$$$.And this can also be optimized with bitset, leading to an $$$O(\\frac{n\\sqrt{n}}{\\omega})$$$ solution.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "// nsqrtn/w\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\ntemplate <int maxn>\nint solve(int n, int k) {\n    if (maxn <= n) {\n        return solve<min(N, maxn * 2)>(n, k);\n    }\n    bitset<maxn> dp;\n    vector<int> fa(n, -1), dep(n, 0);\n    vector<int> noson(n, 1), cnt(n + 1);\n    cnt[0]++;\n    for (int i = 1; i < n; i++) {\n        cin >> fa[i], fa[i]--;\n        dep[i] = dep[fa[i]] + 1;\n        cnt[dep[i]]++;\n        noson[fa[i]] = 0;\n    }\n    dp.reset();\n    dp[0] = 1;\n    int mxdep = 1e9;\n    for (int i = 0; i < n; i++)\n        if (noson[i]) mxdep = min(mxdep, dep[i]);\n \n    int sum = 0;\n    vector<int> all(cnt.begin(), cnt.begin() + mxdep + 1);\n    sort(all.begin(), all.end());\n    vector<int> v;\n    for (int i = 0; i < (int)all.size(); i++) {\n        int j = i;\n        while (j + 1 < (int)all.size() && all[i] == all[j + 1]) j++;\n        int t = j - i + 1;\n        for (int z = 1; z <= t; z *= 2) {\n            v.push_back(z * all[i]);\n            t -= z;\n        }\n        if (t > 0) v.push_back(t * all[i]);\n        i = j;\n    }\n    dp[0] = 1;\n    for (auto val : v) {\n        sum += val;\n        dp |= (dp << val);\n    }\n    if (sum <= k || sum <= n - k) return mxdep + 1;\n    for (int i = 0; i <= sum; i++)\n        if (dp[i]) {\n            if (i <= k && sum - i <= n - k) return mxdep + 1;\n        }\n    return mxdep;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, k;\n        cin >> n >> k;\n        cout << solve<1>(n, k) << \"\\n\";\n    }\n    return 0;\n}",
        "codes": [
          "// nsqrtn/w\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\ntemplate <int maxn>\nint solve(int n, int k) {\n    if (maxn <= n) {\n        return solve<min(N, maxn * 2)>(n, k);\n    }\n    bitset<maxn> dp;\n    vector<int> fa(n, -1), dep(n, 0);\n    vector<int> noson(n, 1), cnt(n + 1);\n    cnt[0]++;\n    for (int i = 1; i < n; i++) {\n        cin >> fa[i], fa[i]--;\n        dep[i] = dep[fa[i]] + 1;\n        cnt[dep[i]]++;\n        noson[fa[i]] = 0;\n    }\n    dp.reset();\n    dp[0] = 1;\n    int mxdep = 1e9;\n    for (int i = 0; i < n; i++)\n        if (noson[i]) mxdep = min(mxdep, dep[i]);\n \n    int sum = 0;\n    vector<int> all(cnt.begin(), cnt.begin() + mxdep + 1);\n    sort(all.begin(), all.end());\n    vector<int> v;\n    for (int i = 0; i < (int)all.size(); i++) {\n        int j = i;\n        while (j + 1 < (int)all.size() && all[i] == all[j + 1]) j++;\n        int t = j - i + 1;\n        for (int z = 1; z <= t; z *= 2) {\n            v.push_back(z * all[i]);\n            t -= z;\n        }\n        if (t > 0) v.push_back(t * all[i]);\n        i = j;\n    }\n    dp[0] = 1;\n    for (auto val : v) {\n        sum += val;\n        dp |= (dp << val);\n    }\n    if (sum <= k || sum <= n - k) return mxdep + 1;\n    for (int i = 0; i <= sum; i++)\n        if (dp[i]) {\n            if (i <= k && sum - i <= n - k) return mxdep + 1;\n        }\n    return mxdep;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, k;\n        cin >> n >> k;\n        cout << solve<1>(n, k) << \"\\n\";\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139D": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139D",
    "problem_title": "2139D - Antiamuny and Slider Movement",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "Let’s define $$$b_i$$$ as the position of the $$$i$$$-th slider decreased by $$$i$$$. Every operation on the sliders can be interpreted as a modification of the array $$$b$$$.  If we increase the position of slider $$$i$$$, then $$$b_i$$$ increases. At the same time, every suffix element $$$b_{i+1}, b_{i+2}, \\dots, b_n$$$ gets updated to $$$b_j := \\max(b_j, b_i)$$$. If we decrease the position of slider $$$i$$$, then $$$b_i$$$ decreases. At the same time, every prefix element $$$b_1, b_2, \\dots, b_{i-1}$$$ gets updated to $$$b_j := \\min(b_j, b_i)$$$. Since the array $$$b$$$ always remains non-decreasing, we can reinterpret operations as follows:  Every operation simultaneously applies a $$$\\min$$$ operation to all elements on the left, and a $$$\\max$$$ operation to all elements on the right. For a fixed slider $$$b_i$$$, the effect of each operation on the slider should be one of the following:  $$$b_i := \\max(b_i, x)$$$ $$$b_i := \\min(b_i, x)$$$ $$$b_i := x$$$ (assignment) Our task is to compute the sum of final values of $$$b_i$$$ after all possible sequences of operations.We sort all operations by their parameter $$$x$$$. If multiple operations share the same $$$x$$$, we give them a consistent order and then assume all $$$x$$$ are distinct in the following part of the editorial.We first suppose that the position of the slider is changed at least once. Suppose the final value for slider $$$i$$$ is $$$b_e$$$, let’s consider which operation sets $$$b_i = b_e$$$ at the very end.At this point, we no longer care about the exact value of $$$b_i$$$ during the process — only whether it is less than, equal to, or greater than $$$b_e$$$.All operations of type $$$\\max$$$ with $$$x < b_e$$$ and type $$$\\min$$$ with $$$x > b_e$$$ are irrelevant. We can insert them anywhere after deciding the order of other operations without affecting the result. We won't consider these operations in the following parts of the editorial.All assignment operations $$$b_i := x$$$ can be reinterpreted:  If $$$x < b_e$$$, treat it as $$$b_i := \\min(b_i, x)$$$. If $$$x > b_e$$$, treat it as $$$b_i := \\max(b_i, x)$$$. The last operation, that makes $$$b_i = b_e$$$ must be the one with parameter $$$x = b_e$$$.  If this operation is assignment, then all other operations can appear in any order. If this operation is $$$\\max$$$ type, then immediately before it we must have $$$b_i < b_e$$$.   Either the last preceding valid operation is some $$$\\min$$$ type operation making $$$b_i < b_e$$$;    Or no other effective operation occurs, and the initial value of $$$b_i$$$ was already smaller than $$$b_e$$$.  If this operation is $$$\\min$$$ type operation, it is symmetric: either the last preceding valid operation is a $$$\\max$$$ type operation, or the initial value of $$$b_i$$$ was already larger than $$$b_e$$$. Finally, don’t forget the case where a slider is never touched, where it simply keeps its initial value.For each of the $$$n$$$ sliders, we need to check contributions over all $$$m$$$ operations. The overall time complexity is $$$O(nm)$$$.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=1000000007;\nlong long a[5000],ans[5000],tt[5001],inv[5001];\nstruct apos{\n\tlong long id;\n\tlong long x;\n\tfriend bool operator<(apos a,apos b){\n\t\treturn a.x<b.x;\n\t}\n}ap[5000];\nint main(){\n\tios::sync_with_stdio(false),cin.tie(0);\n\tint T,flag;\n\tlong long n,m,p,q,x,i,j,cl,cr;\n\ttt[0]=1;\n\tfor(i=1;i<=5000;i++)tt[i]=tt[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(i=2;i<=5000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(cin>>T;T>0;T--)\n\t{\n\t\tcin>>n>>m>>p;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>a[i];\n\t\t\ta[i]-=i;\n\t\t}\n\t\tfor(i=0;i<p;i++)\n\t\t{\n\t\t\tcin>>ap[i].id>>ap[i].x;\n\t\t\tap[i].id--;\n\t\t\tap[i].x-=ap[i].id;\n\t\t}\n\t\tsort(ap,ap+p);\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tflag=0;\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i&&ap[j].x>=a[i])flag=1;\n\t\t\t\tif(ap[j].id>=i&&ap[j].x<a[i])flag=1;\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\tans[i]=a[i]+i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i]=0;\n\t\t\tcl=0;\n\t\t\tcr=0;\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i)cr++;\n\t\t\t}\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i)cr--;\n\t\t\t\tif(ap[j].id==i)ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1])%mod;\n\t\t\t\tif(ap[j].id<i)\n\t\t\t\t{\n\t\t\t\t\tif(cl==0&&cr==0&&a[i]<=ap[j].x)ans[i]=(ans[i]+ap[j].x+i)%mod;\n\t\t\t\t\telse ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1]%mod*inv[cl+cr]%mod*cl)%mod;\n\t\t\t\t}\n\t\t\t\tif(ap[j].id>i)\n\t\t\t\t{\n\t\t\t\t\tif(cl==0&&cr==0&&a[i]>ap[j].x)ans[i]=(ans[i]+ap[j].x+i)%mod;\n\t\t\t\t\telse ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1]%mod*inv[cl+cr]%mod*cr)%mod;\n\t\t\t\t}\n\t\t\t\tif(ap[j].id>=i)cl++;\n\t\t\t}\n\t\t}\n\t\tfor(int x = 0;x < n;x ++)\n\t\t{\n\t\t\tcout<<ans[x]*tt[p]%mod<<' ';\n\t\t}\n\t\tcout<<'\\n';\n\t}\n\treturn 0;\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=1000000007;\nlong long a[5000],ans[5000],tt[5001],inv[5001];\nstruct apos{\n\tlong long id;\n\tlong long x;\n\tfriend bool operator<(apos a,apos b){\n\t\treturn a.x<b.x;\n\t}\n}ap[5000];\nint main(){\n\tios::sync_with_stdio(false),cin.tie(0);\n\tint T,flag;\n\tlong long n,m,p,q,x,i,j,cl,cr;\n\ttt[0]=1;\n\tfor(i=1;i<=5000;i++)tt[i]=tt[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(i=2;i<=5000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(cin>>T;T>0;T--)\n\t{\n\t\tcin>>n>>m>>p;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>a[i];\n\t\t\ta[i]-=i;\n\t\t}\n\t\tfor(i=0;i<p;i++)\n\t\t{\n\t\t\tcin>>ap[i].id>>ap[i].x;\n\t\t\tap[i].id--;\n\t\t\tap[i].x-=ap[i].id;\n\t\t}\n\t\tsort(ap,ap+p);\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tflag=0;\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i&&ap[j].x>=a[i])flag=1;\n\t\t\t\tif(ap[j].id>=i&&ap[j].x<a[i])flag=1;\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\tans[i]=a[i]+i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i]=0;\n\t\t\tcl=0;\n\t\t\tcr=0;\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i)cr++;\n\t\t\t}\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i)cr--;\n\t\t\t\tif(ap[j].id==i)ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1])%mod;\n\t\t\t\tif(ap[j].id<i)\n\t\t\t\t{\n\t\t\t\t\tif(cl==0&&cr==0&&a[i]<=ap[j].x)ans[i]=(ans[i]+ap[j].x+i)%mod;\n\t\t\t\t\telse ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1]%mod*inv[cl+cr]%mod*cl)%mod;\n\t\t\t\t}\n\t\t\t\tif(ap[j].id>i)\n\t\t\t\t{\n\t\t\t\t\tif(cl==0&&cr==0&&a[i]>ap[j].x)ans[i]=(ans[i]+ap[j].x+i)%mod;\n\t\t\t\t\telse ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1]%mod*inv[cl+cr]%mod*cr)%mod;\n\t\t\t\t}\n\t\t\t\tif(ap[j].id>=i)cl++;\n\t\t\t}\n\t\t}\n\t\tfor(int x = 0;x < n;x ++)\n\t\t{\n\t\t\tcout<<ans[x]*tt[p]%mod<<' ';\n\t\t}\n\t\tcout<<'\\n';\n\t}\n\treturn 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139E1": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139E1",
    "problem_title": "2139E1 - Determinant Construction (Easy Version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution 1",
        "text": "Thanks to jqdai0815 for his significant contribution to this solution. Step 1We can consider transforming the construction of a matrix into the construction of a directed graph, as the determinant and permutations are closely related to the cycle covers of a directed graph.If we have a directed graph with $$$n$$$ vertices, a cycle cover is a set of $$$n$$$ edges such that each vertex has exactly one incoming edge and one outgoing edge in this set (self-loops are allowed). In other words, these $$$n$$$ edges form one or more cycles that together cover all vertices in the graph.In a complete directed graph (with self-loops), every permutation of the vertices determines a cycle cover and vice versa. (The cycles of the permutation are precisely the cycles in the cover.)We consider the definition of the determinant: $$$ \\det(M)=\\sum_{\\begin{subarray}{c}B=(b_{0},\\ldots,b_{n-1})\\\\ B\\in\\mathcal{P}_{n}\\end{subarray}}(-1)^{\\mathrm{inv}(B)}\\cdot\\prod_{i=0}^{n-1}m_ {i,b_{i}} $$$This summation goes over all permutations $$$B$$$, in other words, over all cycle covers of the directed graph determined by the adjacency matrix $$$M$$$. We can also interpret $$$m_{i,j}=0$$$ as \"the edge from $$$i$$$ to $$$j$$$ does not exist at all\". Thus, the product term $$$\\prod_{i=0}^{n-1}m_ {i,b_{i}}$$$ is non-zero only if all $$$m_ {i,b_{i}} \\neq 0$$$, which corresponds to the existence of a cycle cover in the graph.We want to construct a directed graph such that the sum of the weights of its cycle covers equals $$$x$$$. Since the current problem only allows the use of $$$-1, 0, 1$$$, the edge weights can only be $$$1$$$ or $$$-1$$$, and the contribution of a valid cycle cover to the answer can only be $$$1$$$ or $$$-1$$$.PS: You can refer to pages 56-58 of https://ipsc.ksp.sk/2012/real/solutions/booklet.pdf for more information. Step 2There might be many ways to construct a legal directed graph. We will demonstrate a method that transforms the problem into constructing a DAG with exactly $$$x$$$ paths from source vertex $$$1$$$ to sink vertex $$$n$$$.For a directed acyclic graph $$$G$$$ with source vertex $$$1$$$ and sink vertex $$$n$$$, we can construct the following adjacency matrix:  $$$g_{i,j} = -1$$$ if there is an edge $$$i \\rightarrow j$$$ in $$$G$$$. Set the weight of all original edges in $$$G$$$ to $$$-1$$$. $$$g_{i,i} = 1$$$ for all $$$1 < i < n$$$. Add a self-loop with weight $$$1$$$ to all vertices in $$$G$$$ except the source and sink. $$$g_{n,1} = 1$$$. Add an edge from the sink to the source with weight $$$1$$$. Everything else $$$= 0$$$. We analyze all cycle covers of this new graph. Due to the presence of the edge $$$n \\rightarrow 1$$$ , any cycle cover must contain a main cycle that includes nodes $$$1$$$ and $$$n$$$, formed by a path $$$P$$$ from $$$1$$$ to $$$n$$$ in $$$G$$$ and the edge $$$n \\rightarrow 1$$$. For nodes not on path $$$P$$$ (i.e., intermediate nodes not covered by path $$$P$$$), they must be covered by self-loops with weight $$$1$$$. Therefore, each cycle cover uniquely corresponds to a path $$$P$$$ from $$$1$$$ to $$$n$$$.Since there are $$$x$$$ paths in $$$G$$$, we only need to ensure that the contribution of each cycle cover is $$$1$$$ to obtain a determinant value of $$$x$$$. Next, we will analyze how to achieve this by setting the weight of all original edges in $$$G$$$ to $$$-1$$$.For each cycle cover, first consider the product of all edge weights:  The main cycle has $$$k$$$ edges, among which $$$k-1$$$ edges come from path $$$P$$$ (each with weight $$$-1$$$), and one edge is $$$n \\rightarrow 1$$$ (with weight $$$1$$$). Thus, the product term is $$$(-1)^{k-1}$$$. The weights of all other self-loops are $$$1$$$. Therefore, the product of all edge weights is $$$(-1)^{k-1}$$$.Then we consider the sign term $$$(-1)^{\\mathrm{inv}(B)}$$$. In fact, the parity of the number of inversions $$$\\mathrm{inv}(B)$$$ in the permutation is consistent with the parity of the number of even cycles in the permutation. The main cycle is a cycle of length $$$k$$$, and the self-loops are all cycles of length $$$1$$$. Therefore, the sign term is $$$(-1)^{k-1}$$$.Thus, the contribution of each cycle cover is $$$(-1)^{k-1} \\cdot (-1)^{k-1}=1$$$.Due to the constraints in the problem that the matrix size is at most $$$80$$$ and there are at most $$$3$$$ non-zero entries per row and column, we need to construct a DAG that satisfies:  Exactly $$$x$$$ paths from source vertex $$$1$$$ to sink vertex $$$n$$$. At most $$$80$$$ nodes. The in-degree of each node $$$\\le 2$$$ and the out-degree of each node $$$\\le 2$$$.  Step 3Since $$$80$$$ is a loose boundary, there might be many constructions that satisfy it. We will introduce a construction method that encodes $$$x$$$ in base three.The basic unit shown in the figure can form a base-three digit because the number of paths from $$$1$$$ to $$$3$$$ is $$$2$$$, and from $$$1$$$ to $$$4$$$ is $$$3$$$. Node $$$4$$$ can be connected to the next unit, forming a chain of units, where each unit corresponds to a base-three digit. Nodes $$$3$$$ and $$$4$$$ have one free out-degree, which can contribute to the final answer.The example figure below shows how to construct $$$22=1+3+2 \\cdot 3^2$$$ in this way. There are $$$\\log_3 n$$$ basic units, each with $$$4$$$ nodes. The answer chain has at most $$$\\log_3 n$$$ nodes. Therefore, the total number of nodes is $$$5\\log_3 n + O(1)$$$, which can pass the problem. Code (C++)#include<bits/stdc++.h> \nusing namespace std;\nconst int N=81;\nint a[N][N];\nvector<pair<int,int>> e;\nvoid add(int x,int y){\n    e.push_back({x,y});\n}\nvoid make_matrix(int n){\n    for(int i=2;i<n;++i) a[i][i]=1;\n    a[n][1]=1;\n    for(auto [x,y]:e) a[x][y]=-1;\n}\nint main(){\n    int _; scanf(\"%d\",&_); //cin>>_;\n    int max_bit=15;\n    while(_--){\n        memset(a,0,sizeof(a)); e.clear();\n        int n=1;\n        for(int i=0;i<max_bit;++i){\n            add(n,n+1); add(n+1,n+2); add(n+2,n+3); add(n+3,n+4);\n            add(n+1,n+3); add(n+2,n+4);\n            n+=4;\n        }\n        int x,bit_1=1,bit_2=4; scanf(\"%d\",&x); ++n;\n        for(int i=0;i<max_bit;++i){\n            if (x%3==1) add(bit_1,n),add(n,n+1),++n;\n            if (x%3==2) add(bit_2,n),add(n,n+1),++n;\n            bit_1+=4; bit_2+=4; x/=3;\n        }\n        make_matrix(n);\n        cout << n <<'\\n';\n        for (int r = 1; r <= n; r++) {\n            for (int c = 1; c <= n; c++) {\n                printf(\"%d \",a[r][c]);\n            }\n            cout << '\\n';\n        }\n    }\n}",
        "codes": [
          "#include<bits/stdc++.h> \nusing namespace std;\nconst int N=81;\nint a[N][N];\nvector<pair<int,int>> e;\nvoid add(int x,int y){\n    e.push_back({x,y});\n}\nvoid make_matrix(int n){\n    for(int i=2;i<n;++i) a[i][i]=1;\n    a[n][1]=1;\n    for(auto [x,y]:e) a[x][y]=-1;\n}\nint main(){\n    int _; scanf(\"%d\",&_); //cin>>_;\n    int max_bit=15;\n    while(_--){\n        memset(a,0,sizeof(a)); e.clear();\n        int n=1;\n        for(int i=0;i<max_bit;++i){\n            add(n,n+1); add(n+1,n+2); add(n+2,n+3); add(n+3,n+4);\n            add(n+1,n+3); add(n+2,n+4);\n            n+=4;\n        }\n        int x,bit_1=1,bit_2=4; scanf(\"%d\",&x); ++n;\n        for(int i=0;i<max_bit;++i){\n            if (x%3==1) add(bit_1,n),add(n,n+1),++n;\n            if (x%3==2) add(bit_2,n),add(n,n+1),++n;\n            bit_1+=4; bit_2+=4; x/=3;\n        }\n        make_matrix(n);\n        cout << n <<'\\n';\n        for (int r = 1; r <= n; r++) {\n            for (int c = 1; c <= n; c++) {\n                printf(\"%d \",a[r][c]);\n            }\n            cout << '\\n';\n        }\n    }\n}"
        ]
      },
      {
        "title": "solution 2",
        "text": "Step 1We can consider using Tridiagonal Matrices, where the advantage lies in transforming the calculation of the determinant value into a recursive formula.Let $$$d_{i,j}$$$ denote the element in the i-th row and j-th column of matrix $$$D$$$, $$$D_k$$$ represents the submatrix composed of the upper-left $$$k \\times k$$$ elements, and $$$A_k$$$ denotes the determinant value of $$$D_k$$$.When $$$k \\ge 2$$$, there are two ways to obtain $$$D_{k+1}$$$ from $$$D_k$$$:  Let $$$ d_{k+1,k+1}=1, d_{k+1,k}=1,d_{k,k+1}=1$$$ to get $$$A_{k+1}=A_k-A_{k-1}$$$ Let $$$ d_{k+1,k+1}=1, d_{k+1,k}=1,d_{k,k+1}=-1$$$ to get $$$A_{k+1}=A_k+A_{k-1}$$$ Thus, we transform the problem into constructing a sequence $$$A_1,\\ldots,A_m$$$ satisfying:  $$$A_1 = |D_1|, A_2 = |D_2|$$$ For any $$$k=2,3,\\ldots,m-1$$$, one of the following two equations holds: $$$A_{k+1}=A_k-A_{k-1}$$$, or $$$A_{k+1}=A_k+A_{k-1}$$$ $$$A_m=n (m \\le 80)$$$  Step 2Consider recursively generating the entire sequence from $$$A_m=n$$$ backwards.  Choose a positive integer as $$$A_{m−1}$$$. At a certain moment, we have $$$A_k$$$ and $$$A_{k+1}$$$, and obtain $$$A_{k−1}$$$ as follows:If $$$A_k > A_{k+1}$$$, let $$$A_{k-1}=A_k-A_{k+1}$$$; otherwise, let $$$A_{k-1}=A_{k+1}-A_k$$$This ensures that each number in the sequence is a non-negative integer. If at some point there exist $$$D_1,D_2$$$ satisfying $$$A_k = |D_1|, A_{k+1} = |D_2|$$$, successfully finish the construction. For example,if we have $$$A_m=7$$$ and $$$A_{m−1}=3$$$, the final sequence will be $$$1,2,3,1,4,3,7$$$, and we will generate the matrix as $$$\\begin{pmatrix} 1 & -1 & 0 & 0 & 0 & 0 & 0 \\\\ 1 & 1 & -1 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & 1 & 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 1 & -1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 1 & -1 \\\\ 0 & 0 & 0 & 0 & 0 & 1 & 1 \\end{pmatrix}$$$Denote $$$(A_k,A_{k+1})=(x,y)$$$.When $$$x>y$$$, the recursion process can be written as $$$(x,y) \\rightarrow (x-y,x) \\rightarrow (y,x-y)$$$, increasing the length of the sequence by $$$2$$$, completing one iteration of subtraction.When $$$x \\le y$$$, the recursion process can be written as $$$(x,y) \\rightarrow (y-x,x)$$$, increasing the length of the sequence by $$$1$$$, completing one iteration of subtraction.The process will eventually lead to $$$(x,0)$$$ or $$$(0,x)$$$, where $$$x$$$ is the GCD of $$$A_m$$$ and $$$A_{m−1}$$$.When $$$A_m$$$ and $$$A_{m−1}$$$ are coprime, we have $$$x=1$$$, meeting the requirements for the sequence. In fact, we can stop earlier when $$$(1,2)$$$, and the sequence is still legal.When $$$A_m$$$ and $$$A_{m−1}$$$ are not coprime, we have $$$x>1$$$, and this method can't obtain a sequence that meets the requirements. Step 3Given $$$A_m=n$$$, we need to find a suitable $$$A_{m−1}$$$ such that the length of the final sequence is less than or equal to $$$80$$$.Since $$$80$$$ is a relaxed constraint, and you only need to find one valid $$$A_{m−1}$$$, you can try various approaches. For example, you could enumerate all possibilities within the range $$$[1, n-1]$$$ for some large $$$n$$$, and then discover that there are many valid $$$A_{m−1}$$$ values that meet the criteria. If you randomly search for $$$A_{m−1}$$$ within the range, the expected number of attempts required is very low. In fact, the verification program tested all integers $$$n$$$ from $$$10$$$ to $$$10^7$$$, randomly selecting $$$1000$$$ possible $$$A_{m−1}$$$ values for each n and testing them. The results showed that in the worst case (when $$$n = 9827370$$$), there were still $$$24$$$ valid $$$A_{m−1}$$$ values that met the requirements out of the $$$1000$$$ randomly chosen values. Code (C++)Code: #include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=80){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[105][105]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main(){\n    int _; cin>>_; mt19937 rd(time(0));\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        while(1){\n            int y=rd()%(n-1)+1;\n            int tmp=work(n,y);\n            if (tmp<=80) {gen(n,y); break;}\n        }\n    }\n    return 0;\n}\nVerification Program: #pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\nint inf=1e9;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=80){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nint main(){\n    mt19937 rd(114514);\n    int n=1e7,minn=1e3;\n    for(int x=n;x>=5;x--){\n        int _=1e3,c=0;\n        while(_--){\n            int y=rd()%(x-1)+1;\n            int tmp=work(x,y);\n            if (tmp<=80) ++c;\n        }\n        if (c<minn) minn=c,cout<<' '<<minn<<' '<<x<<endl;\n        if (x%10000==1) cout<<clock()<<'#'<<x<<endl;\n    }\n    return 0;\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=80){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[105][105]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main(){\n    int _; cin>>_; mt19937 rd(time(0));\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        while(1){\n            int y=rd()%(n-1)+1;\n            int tmp=work(n,y);\n            if (tmp<=80) {gen(n,y); break;}\n        }\n    }\n    return 0;\n}",
          "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\nint inf=1e9;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=80){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nint main(){\n    mt19937 rd(114514);\n    int n=1e7,minn=1e3;\n    for(int x=n;x>=5;x--){\n        int _=1e3,c=0;\n        while(_--){\n            int y=rd()%(x-1)+1;\n            int tmp=work(x,y);\n            if (tmp<=80) ++c;\n        }\n        if (c<minn) minn=c,cout<<' '<<minn<<' '<<x<<endl;\n        if (x%10000==1) cout<<clock()<<'#'<<x<<endl;\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139E2": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139E2",
    "problem_title": "2139E2 - Determinant Construction (Hard Version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "In Solution 2, the first two steps remain consistent with G1, but we need a better method to find a suitable $$$A_{m−1}$$$ such that the length of the final sequence is less than or equal to $$$50$$$. Randomly searching for $$$A_{m−1}$$$ within the range $$$[1, n-1]$$$ may result in TLE.We noticed that if $$$A_{m−1}$$$ and $$$A_m$$$ are two adjacent fibonacci numbers, the sequence will converge rapidly (with a length within $$$40$$$). Although not all $$$A_m=n$$$ are fibonacci numbers, we can still draw inspiration from this.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution a",
        "text": "We attempt to decompose $$$n$$$ as $$$n=a \\cdot \\operatorname{fib}(i)+b \\cdot \\operatorname{fib}(i-1), a,b \\ge 0$$$, where $$$\\operatorname{fib}(i)$$$ denotes the $$$i$$$-th fibonacci number.Then, we set $$$A_{m-1}=a \\cdot \\operatorname{fib}(i-1)+b \\cdot \\operatorname{fib}(i-2)$$$By iterating further, we obtain $$$A_{m-2}=a \\cdot \\operatorname{fib}(i-2)+b \\cdot \\operatorname{fib}(i-3)$$$, $$$\\dots$$$The purpose of this is to make the iteration process rapidly decrease the value in the initial steps, similar to the fibonacci sequence. Intuitively, the larger the $$$i$$$ chosen, the higher the probability of finding a legal $$$A_{m-1}$$$.The author did not provide a rigorous mathematical proof for this, but using a verification program which found a legal $$$A_{m-1}$$$ for all $$$A_m=n \\in [2,10^7]$$$ within one minute. Therefore, it is feasible to prove the correctness of this approach within the data range during the contest. Code (C++)#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=50){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[55][55]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\ntypedef long long ll;\nll fib[55]={1,1};\nll exgcd(ll a,ll b,ll &x,ll &y){\n\tif(!b){\n\t\tx=1; y=0; return a;\n\t}\n\tll d=exgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n\treturn d;\n}\nmap<int,int> mp;\nint main(){\n    for(int i=2;i<=50;++i) fib[i]=fib[i-1]+fib[i-2];\n    int _; cin>>_;\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        if (n<=10){\n            gen(n,n-1); continue;\n        }\n        if (mp[n]) {gen(n,mp[n]); continue;}\n        int noww=0;\n        while(fib[noww]<n) ++noww;\n        int now=noww;\n        while(now>=3){\n            ll a=fib[now-1],b=fib[now-2],x,y,c=n;\n            ll d=exgcd(a,b,x,y);\n            x*=c,y*=c;\n            //find x,y\n            x=(x%b+b)%b;  y=(c-a*x)/b; if (y<0) {--now; continue;}\n            int s=inf,o;\n            while(y>=0){\n                o=fib[now-2]*x+fib[now-3]*y;\n                s=work(n,o);\n                if (s>50) {x+=b,y-=a; continue;}\n                else break;\n            }\n            if (s>50) {--now; continue;}\n            else{\n                gen(n,o); mp[n]=o; break;\n            }\n        }\n        //\n    }\n    return 0;\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=50){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[55][55]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\ntypedef long long ll;\nll fib[55]={1,1};\nll exgcd(ll a,ll b,ll &x,ll &y){\n\tif(!b){\n\t\tx=1; y=0; return a;\n\t}\n\tll d=exgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n\treturn d;\n}\nmap<int,int> mp;\nint main(){\n    for(int i=2;i<=50;++i) fib[i]=fib[i-1]+fib[i-2];\n    int _; cin>>_;\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        if (n<=10){\n            gen(n,n-1); continue;\n        }\n        if (mp[n]) {gen(n,mp[n]); continue;}\n        int noww=0;\n        while(fib[noww]<n) ++noww;\n        int now=noww;\n        while(now>=3){\n            ll a=fib[now-1],b=fib[now-2],x,y,c=n;\n            ll d=exgcd(a,b,x,y);\n            x*=c,y*=c;\n            //find x,y\n            x=(x%b+b)%b;  y=(c-a*x)/b; if (y<0) {--now; continue;}\n            int s=inf,o;\n            while(y>=0){\n                o=fib[now-2]*x+fib[now-3]*y;\n                s=work(n,o);\n                if (s>50) {x+=b,y-=a; continue;}\n                else break;\n            }\n            if (s>50) {--now; continue;}\n            else{\n                gen(n,o); mp[n]=o; break;\n            }\n        }\n        //\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "solution b",
        "text": "We note that for the fibonacci sequence, $$$\\lim_{x \\to \\infty} \\frac{\\operatorname{fib}(x-1)}{\\operatorname{fib}(x)} = \\frac{\\sqrt 5 -1}{2}$$$, which suggests that searching for $$$A_{m-1}$$$ around $$$\\frac{\\sqrt 5 -1}{2}n$$$ might be a promising approach.In fact, directly enumerating $$$A_{m-1}$$$ starting from $$$\\frac{\\sqrt 5 -1}{2}n$$$ and trying each one is a efficient method. The author also verified through a verification program that for all $$$A_m=n \\in [2,10^7]$$$, a legal $$$A_{m-1}$$$ was found within one minute. Thus, it is feasible to prove the correctness of this approach within the data range during the contest.Considering that the time limit for this problem is relatively loose (5s), most attempts to search for $$$A_{m-1}$$$ around $$$\\frac{\\sqrt 5 -1}{2}n$$$ may be able to pass. Code (C++)#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=50){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[55][55]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nmap<int,int> mp;\nint main(){\n    int _; cin>>_;\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        if (mp[n]) {gen(n,mp[n]); continue;}\n        double s=(sqrt(5)-1.0)/2.0;\n        int st=s*n,l=max(1,st),r=n-1;\n        //int l=1,r=n-1;\n        int nowy,nows=50;\n        if (n%2==0){\n            if (l%2==0) ++l;\n            for(int y=l;y<=r;y+=2){\n                int tmp=work(n,y);\n                if (tmp<=nows) {gen(n,y); mp[n]=y; break;}\n            }\n        }\n        else{\n            for(int y=l;y<=r;++y){\n                int tmp=work(n,y);\n                if (tmp<=nows) {gen(n,y); mp[n]=y; break;}\n            }\n        }\n    }\n    return 0;\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=50){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[55][55]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nmap<int,int> mp;\nint main(){\n    int _; cin>>_;\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        if (mp[n]) {gen(n,mp[n]); continue;}\n        double s=(sqrt(5)-1.0)/2.0;\n        int st=s*n,l=max(1,st),r=n-1;\n        //int l=1,r=n-1;\n        int nowy,nows=50;\n        if (n%2==0){\n            if (l%2==0) ++l;\n            for(int y=l;y<=r;y+=2){\n                int tmp=work(n,y);\n                if (tmp<=nows) {gen(n,y); mp[n]=y; break;}\n            }\n        }\n        else{\n            for(int y=l;y<=r;++y){\n                int tmp=work(n,y);\n                if (tmp<=nows) {gen(n,y); mp[n]=y; break;}\n            }\n        }\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139F": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139F",
    "problem_title": "2139F - Ode to the Bridge Builder",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "For convenience, we mark the targets point and the points on the initial segment with $$$A(0,0),B(1,0),C(p,q)$$$.The problem asks us to do at most $$$\\left\\lceil 2|AC|\\right\\rceil$$$ moves. This constraint is actually not quite usual. We can first show that the theoretical lower bound should be $$$x=\\left\\lceil |AC|\\right\\rceil+\\left\\lceil |BC|\\right\\rceil−1$$$. We can show we can't get less moves by following: If we have already constructed the final structure, then $$$AC$$$ and $$$BC$$$ should be connected with a path, and we can find a path from $$$A$$$ to $$$C$$$ and a path from $$$B$$$ to $$$C$$$ that don't intersect (except at point $$$C$$$), otherwise the structure can't be built with non-degenerate triangles.And we have to alternate progressing through two paths every time we construct a triangle, otherwise we must draw a line longer than $$$1$$$. The last triangle will cover both paths, so the number of steps will be decreased by one. The optimal path is two straight segments (which is not always possible).Case 1.1: We first try some simple strategies. Two triangles can form a parallelogram, so we can connect $$$AC$$$, choose a point $$$D$$$ on $$$AC$$$ which makes $$$|AD|=\\frac{|AC|}{\\lceil|AC|\\rceil}$$$, which is always in range $$$[0.5,1]$$$ when $$$|AC|\\ge 1$$$. And from $$$\\triangle ADB$$$ we can construct a parallelogram. We draw a line passing $$$D$$$ that is parallel to $$$AB$$$, a line passing $$$B$$$ that is parallel to $$$AC$$$, and they intersects at $$$E$$$. Then we pile up the same parallelogram structure until we reach $$$C$$$. This always works when $$$30^\\circ\\le\\angle CAB\\le60^\\circ$$$.Proof: We first prove that all segments has length between $$$0.5$$$ and $$$1$$$. Because we stack the same parallelogram structure, all segments have length equal to $$$AB,BD$$$ or $$$AD$$$. $$$AB$$$ and $$$AD$$$ already meets the requirement. When $$$30^\\circ\\le\\angle CAB\\le60^\\circ$$$, the length of $$$BD$$$ is at least $$$0.5$$$ as the distance between two parallel lines is at least $$$0.5$$$, and at most $$$1$$$ as $$$AB=1$$$ and $$$\\angle CAB$$$ is never the largest angle in $$$\\triangle DAB$$$. We can calculate that the number of moves we used is $$$2\\left\\lceil |AC|\\right\\rceil-1\\le\\left\\lceil 2|AC|\\right\\rceil$$$ which matches the requirement (for the last parallelogram we only need one triangle).Case 1.2: We can change the way we construct parallelograms (with sides $$$AB,BC$$$) and this method always works when $$$30^\\circ\\le\\angle CBx\\le60^\\circ$$$. The number of moves is $$$\\left\\lceil2|BC|\\right\\rceil\\le \\left\\lceil 2|AC|\\right\\rceil$$$. This case is actually necessary, which will be explained in the following part.Case 2: If $$$\\angle CAB< \\angle CBx<30^\\circ$$$. We first build a point $$$D$$$ which makes $$$AD=1$$$ and $$$\\angle DAB=30^\\circ$$$ and construct $$$\\triangle DAB$$$. We can show that the constraint is actually easier to meet in this situation, because when $$$\\angle CAB<\\angle CBx<30^\\circ$$$, $$$|BC|<|AC|-0.5$$$. With this, $$$\\left\\lceil |AC|\\right\\rceil+\\left\\lceil |BC|\\right\\rceil−1=\\left\\lceil 2|AC|\\right\\rceil-1$$$ always holds, allowing us one extra move.Then we draw a line passing $$$D$$$ parallel to $$$BC$$$. We can show that if $$$\\angle DAB=30^\\circ$$$ and $$$0\\le \\angle CAB\\le 30^\\circ$$$, the distance from $$$D$$$ to line $$$BC$$$ is at least $$$0.5$$$. So all segments with ends on different lines will have length $$$\\ge 0.5$$$.Then we select a point $$$E$$$ on $$$BC$$$, which makes $$$DE=1$$$. We can show that $$$\\sqrt{3}-1\\le |BE|\\le 1$$$ based on some calculations in this case. Then we do a similar parallelogram construction process to $$$C$$$. The total number of moves is $$$2\\left\\lceil |CE|\\right\\rceil+2$$$.There are still two cases here to analyze to prove the number of steps fulfills our requirement. We write $$$|BC|=a+b$$$ where $$$a$$$ is the integer part of $$$|BC|$$$, then we analyze cases about $$$b$$$.  Case 2.1: When $$$b\\ge\\sqrt{3}-1$$$ or $$$b=0$$$, we can show that $$$2\\left\\lceil |AC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil$$$, and $$$\\left\\lceil |AC|\\right\\rceil=\\left\\lceil |BC|\\right\\rceil+1$$$ if $$$|AC|\\ge 2$$$. The number of steps is $$$2\\left\\lceil |EC|\\right\\rceil+2\\le 2\\left\\lceil |BC|\\right\\rceil+2=2\\left\\lceil |AC|\\right\\rceil$$$. Case 2.2: When $$$0<b<\\sqrt{3}-1$$$, we can show that $$$\\left\\lceil |EC|\\right\\rceil=\\left\\lceil |BC|\\right\\rceil-1$$$. Total moves equals to $$$2+2\\left\\lceil |CE|\\right\\rceil=2\\left\\lceil |BC|\\right\\rceil\\le \\left\\lceil |AC|\\right\\rceil+\\left\\lceil |BC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil$$$.  Be careful with small cases where $$$|BC|$$$ is too short, which may make $$$|DF|=|EG|<0.5$$$.Note that there are some cases where $$$\\angle CBx>30^\\circ$$$ and $$$\\angle CAB<30^\\circ$$$, where Case 2 strategy doesn't work. So case 1.2 is required.Case 3: If $$$\\angle CBx>\\angle CAB>60^\\circ$$$. We first build a point $$$D$$$ which makes $$$AD=1$$$ and $$$\\angle DAB=60^\\circ$$$ and construct $$$\\triangle DAB$$$. We write $$$|AC|=a+b$$$ where $$$a$$$ is integer, then we analyze two cases about $$$b$$$.Case 3.1: When $$$b>0.5$$$ or $$$b=0$$$, $$$2\\left\\lceil |AC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil$$$. We begin a same parallelogram construction as Case 1 where the sides of parallelogram are $$$BC,BD$$$. We can show that $$$30^\\circ\\le\\angle CBD\\le60^\\circ$$$. So it is possible to pile up to $$$C$$$ from $$$BD$$$ in $$$2\\left\\lceil |BC|\\right\\rceil-1$$$ moves. And in total we need $$$2\\left\\lceil |BC|\\right\\rceil\\le2\\left\\lceil |AC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil$$$ moves.Case 3.2: When $$$0<b\\le 0.5$$$, $$$2\\left\\lceil |AC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil+1$$$. We instead connect $$$CD$$$ and construct parallelogram with sides $$$DC,DB$$$. We can show that $$$120^\\circ\\le\\angle CDB\\le150^\\circ$$$ so we can still do the parallelogram construction. When $$$|AC|\\ge \\sqrt{3}$$$, $$$\\left\\lceil |CD|\\right\\rceil=\\left\\lceil |AC||\\right\\rceil-1$$$, making the number of moves $$$2\\left\\lceil |CD|\\right\\rceil+1=2\\left\\lceil |AC|\\right\\rceil-1=\\left\\lceil 2|AC|\\right\\rceil$$$. Actually case 1.1 is not required, because it is impossible to construct a testcase where $$$\\angle CAB<60^\\circ, \\angle CBx>60^\\circ,0<b\\le 0.5$$$ and Case 3.2 fails.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\nconst db pi = acos(-1.0);\nconst int N = 1000005;\n\ninline int sgn(db x){\n    if(x < 1e-13 && x > -1e-13) return 0;\n    if(x > 0) return 1;\n    return -1;\n}\n\nstruct point{\n    db x,y;\n    point (db _x = 0.0,db _y = 0.0) : x(_x), y(_y) {}\n};\npoint operator + (const point &p1,const point &p2){\n\treturn point(p1.x + p2.x,p1.y + p2.y);\n}\npoint operator - (const point &p1,const point &p2){\n\treturn point(p1.x - p2.x,p1.y - p2.y);\n}\npoint operator * (db x,const point &p){\n\treturn point(x * p.x,x * p.y);\n} \nbool operator == (point x,point y){\n\treturn sgn(x.x - y.x) == 0 && sgn(x.y - y.y) == 0;\n}\n\ninline db dot(point p1,point p2){\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\ninline db det(point p1,point p2){\n\treturn p1.x * p2.y - p2.x * p1.y;\n}\n\ninline db len(point p){\n    return sqrtl(1.0 * p.x * p.x + 1.0 * p.y * p.y);\n}\n\npoint project_point(point x,point ya,point yb){\n\tpoint v = yb - ya;\n\treturn ya + (dot(v,x - ya) / dot(v,v)) * v;\n}\n\ndb distp(point x,point ya,point yb){\n\treturn fabs(det(ya - x,yb - x)) / len(yb - ya);\n}\n\npoint line_circle_intersec_point(point o,point la,point lb){\n\tdb dis = distp(o,la,lb),l;\n\tpoint pj = project_point(o,la,lb);\n\tl = sqrt(1.0 - dis * dis);\n\tpoint ret = pj + (l / len(lb - la)) * (lb - la);\n\treturn ret;\n}\n\ntuple <int,int,int> ans[N];\npoint p[N],target;\nint step;\n\nbool check(int n){\n    set <pair <int,int> > st;\n    st.insert({1,2});\n    if(n > step) return 0;\n    db eps_len = 1e-8,eps_dis = 1e-4;\n    int fl = 0;\n    for(int i = 1;i <= n;i ++){\n        auto [u,v,w] = ans[i];\n        if(u > v) swap(u,v);\n        if(st.find({u,v}) == st.end()) return 0;\n        if(len(p[u] - p[w]) < 0.5 - eps_len || len(p[u] - p[w]) > 1.0 + eps_len) return 0;\n        if(len(p[v] - p[w]) < 0.5 - eps_len || len(p[v] - p[w]) > 1.0 + eps_len) return 0;\n        st.insert({u,w}); st.insert({v,w});\n        if(len(p[w] - target) <= eps_dis) fl = 1;\n    }\n    return 1;\n}\n\nint solve1a(){\n    point dir = target - p[1];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 2;\n    for(int i = 1;i < split;i ++){\n        ++ c; p[c] = p[1] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        // construct one parallelogram\n    }\n    ++ c; p[c] = target;\n    ans[c - 2] = {c - 2,c - 1,c};\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve1b(){\n    point dir = target - p[2];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 2;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[1] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve2(){\n    p[3] = point(sqrt(3.0) / 2,0.5);\n    p[4] = line_circle_intersec_point(p[3],p[2],target);\n    if(len(p[4] - p[2]) > 1)\n        p[4] = p[2] + (1.0 / len(target - p[2])) * (target - p[2]);\n    ans[1] = {1,2,3};\n    ans[2] = {2,3,4};\n    point dir = target - p[4];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 4;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[4] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve3a(){\n    p[3] = point(0.5,sqrt(3.0) / 2);\n    ans[1] = {1,2,3};\n    point dir = target - p[2];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 3;\n    for(int i = 1;i < split;i ++){\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    ++ c; p[c] = target;\n    ans[c - 2] = {c - 2,c - 1,c};\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve3b(){\n    p[3] = point(0.5,sqrt(3.0) / 2);\n    ans[1] = {1,2,3};\n    point dir = target - p[3];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 3;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve(){\n    if(int res = solve1a()) return res;\n    if(int res = solve1b()) return res;\n    if(int res = solve2()) return res;\n    if(int res = solve3a()) return res;\n    if(int res = solve3b()) return res;\n    return 0;\n}\n\nint main(){\n    int TC; scanf(\"%d\",&TC);\n    p[1] = point(0,0);\n    p[2] = point(1,0);\n    while(TC --){\n        int tx,ty;\n        scanf(\"%d %d %d\",&tx,&ty,&step);\n        step = ceil(2.0 * sqrt(1.0 * tx * tx + 1.0 * ty * ty));\n        target = point(tx,ty);\n        int n = solve();\n        assert(n > 0);\n        printf(\"%d\\n\",n);\n        for(int i = 1;i <= n;i ++){\n            auto [u,v,w] = ans[i];\n            printf(\"%d %d %.12lf %.12lf\\n\",u,v,p[w].x,p[w].y);\n        }\n    }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\nconst db pi = acos(-1.0);\nconst int N = 1000005;\n\ninline int sgn(db x){\n    if(x < 1e-13 && x > -1e-13) return 0;\n    if(x > 0) return 1;\n    return -1;\n}\n\nstruct point{\n    db x,y;\n    point (db _x = 0.0,db _y = 0.0) : x(_x), y(_y) {}\n};\npoint operator + (const point &p1,const point &p2){\n\treturn point(p1.x + p2.x,p1.y + p2.y);\n}\npoint operator - (const point &p1,const point &p2){\n\treturn point(p1.x - p2.x,p1.y - p2.y);\n}\npoint operator * (db x,const point &p){\n\treturn point(x * p.x,x * p.y);\n} \nbool operator == (point x,point y){\n\treturn sgn(x.x - y.x) == 0 && sgn(x.y - y.y) == 0;\n}\n\ninline db dot(point p1,point p2){\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\ninline db det(point p1,point p2){\n\treturn p1.x * p2.y - p2.x * p1.y;\n}\n\ninline db len(point p){\n    return sqrtl(1.0 * p.x * p.x + 1.0 * p.y * p.y);\n}\n\npoint project_point(point x,point ya,point yb){\n\tpoint v = yb - ya;\n\treturn ya + (dot(v,x - ya) / dot(v,v)) * v;\n}\n\ndb distp(point x,point ya,point yb){\n\treturn fabs(det(ya - x,yb - x)) / len(yb - ya);\n}\n\npoint line_circle_intersec_point(point o,point la,point lb){\n\tdb dis = distp(o,la,lb),l;\n\tpoint pj = project_point(o,la,lb);\n\tl = sqrt(1.0 - dis * dis);\n\tpoint ret = pj + (l / len(lb - la)) * (lb - la);\n\treturn ret;\n}\n\ntuple <int,int,int> ans[N];\npoint p[N],target;\nint step;\n\nbool check(int n){\n    set <pair <int,int> > st;\n    st.insert({1,2});\n    if(n > step) return 0;\n    db eps_len = 1e-8,eps_dis = 1e-4;\n    int fl = 0;\n    for(int i = 1;i <= n;i ++){\n        auto [u,v,w] = ans[i];\n        if(u > v) swap(u,v);\n        if(st.find({u,v}) == st.end()) return 0;\n        if(len(p[u] - p[w]) < 0.5 - eps_len || len(p[u] - p[w]) > 1.0 + eps_len) return 0;\n        if(len(p[v] - p[w]) < 0.5 - eps_len || len(p[v] - p[w]) > 1.0 + eps_len) return 0;\n        st.insert({u,w}); st.insert({v,w});\n        if(len(p[w] - target) <= eps_dis) fl = 1;\n    }\n    return 1;\n}\n\nint solve1a(){\n    point dir = target - p[1];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 2;\n    for(int i = 1;i < split;i ++){\n        ++ c; p[c] = p[1] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        // construct one parallelogram\n    }\n    ++ c; p[c] = target;\n    ans[c - 2] = {c - 2,c - 1,c};\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve1b(){\n    point dir = target - p[2];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 2;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[1] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve2(){\n    p[3] = point(sqrt(3.0) / 2,0.5);\n    p[4] = line_circle_intersec_point(p[3],p[2],target);\n    if(len(p[4] - p[2]) > 1)\n        p[4] = p[2] + (1.0 / len(target - p[2])) * (target - p[2]);\n    ans[1] = {1,2,3};\n    ans[2] = {2,3,4};\n    point dir = target - p[4];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 4;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[4] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve3a(){\n    p[3] = point(0.5,sqrt(3.0) / 2);\n    ans[1] = {1,2,3};\n    point dir = target - p[2];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 3;\n    for(int i = 1;i < split;i ++){\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    ++ c; p[c] = target;\n    ans[c - 2] = {c - 2,c - 1,c};\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve3b(){\n    p[3] = point(0.5,sqrt(3.0) / 2);\n    ans[1] = {1,2,3};\n    point dir = target - p[3];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 3;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve(){\n    if(int res = solve1a()) return res;\n    if(int res = solve1b()) return res;\n    if(int res = solve2()) return res;\n    if(int res = solve3a()) return res;\n    if(int res = solve3b()) return res;\n    return 0;\n}\n\nint main(){\n    int TC; scanf(\"%d\",&TC);\n    p[1] = point(0,0);\n    p[2] = point(1,0);\n    while(TC --){\n        int tx,ty;\n        scanf(\"%d %d %d\",&tx,&ty,&step);\n        step = ceil(2.0 * sqrt(1.0 * tx * tx + 1.0 * ty * ty));\n        target = point(tx,ty);\n        int n = solve();\n        assert(n > 0);\n        printf(\"%d\\n\",n);\n        for(int i = 1;i <= n;i ++){\n            auto [u,v,w] = ans[i];\n            printf(\"%d %d %.12lf %.12lf\\n\",u,v,p[w].x,p[w].y);\n        }\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2136A": {
    "contest_title": "Codeforces Round 1046 (Div. 1)",
    "problem_id": "2136A",
    "problem_title": "2136A - In the Dream",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1046 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145796",
          "full_url": "https://codeforces.com/blog/entry/145796"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "If one team got a score of $$$x$$$ in the first half, what is the maximum score the other team could get?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "We can consider the first half and the second half separately. The dream might come true if and only if the scores in both halves are possible. In the second half, the RiOI team scored $$$(c - a)$$$ goals, while the KDOI team scored $$$(d - b)$$$ goals.Suppose the RiOI team scored $$$x$$$ goals in some half. Denoting the score of the KDOI team as $$$y$$$, one can see that the maximal value of $$$y$$$ is $$$2\\cdot x + 2$$$, under the goal order $$$\\tt{\\color{red}K\\color{red}K\\color{black}RK\\color{red}K\\color{black}R...RK\\color{red}K\\color{black}RK\\color{red}K}$$$. When $$$y \\geq x$$$, all scores in the range $$$[x, 2\\cdot x+2]$$$ can be achieved by deleting several $$$\\tt K$$$-s colored red.Therefore, the scores $$$x: y$$$ in a single half are possible, if and only if $$$\\max(x, y) \\leq 2\\cdot \\min(x, y) + 2$$$.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint T, a, b, c, d;\n\nint main() {\n\tfor (scanf(\"%d\", &T); T--; ) {\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d), c -= a, d -= b;\n\t\tif (a > b) swap(a, b); if (c > d) swap(c, d);\n\t\tputs((a + 1 << 1) >= b && (c + 1 << 1) >= d ? \"YES\" : \"NO\");\n\t}\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint T, a, b, c, d;\n\nint main() {\n\tfor (scanf(\"%d\", &T); T--; ) {\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d), c -= a, d -= b;\n\t\tif (a > b) swap(a, b); if (c > d) swap(c, d);\n\t\tputs((a + 1 << 1) >= b && (c + 1 << 1) >= d ? \"YES\" : \"NO\");\n\t}\n}"
        ]
      },
      {
        "title": "code (python)",
        "text": "import sys\ninput=sys.stdin.readline\n \nt=int(input())\nfor _ in range(t):\n    a,b,c,d=map(int,input().split())\n    if(max(a,b)>2*min(a,b)+2):\n        print(\"NO\")\n    elif(max(c-a,d-b)>2*min(c-a,d-b)+2):\n        print(\"NO\")\n    else:\n        print(\"YES\")",
        "codes": [
          "import sys\ninput=sys.stdin.readline\n \nt=int(input())\nfor _ in range(t):\n    a,b,c,d=map(int,input().split())\n    if(max(a,b)>2*min(a,b)+2):\n        print(\"NO\")\n    elif(max(c-a,d-b)>2*min(c-a,d-b)+2):\n        print(\"NO\")\n    else:\n        print(\"YES\")"
        ]
      },
      {
        "title": "rate the problem!",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2136B": {
    "contest_title": "Codeforces Round 1046 (Div. 1)",
    "problem_id": "2136B",
    "problem_title": "2136B - Like the Bitset",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1046 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145796",
          "full_url": "https://codeforces.com/blog/entry/145796"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "When shall we output $$$\\tt{NO}$$$?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "We can put larger numbers on indices with $$$s_i = \\tt{0}$$$, and smaller numbers on indices with $$$s_i = \\tt{1}$$$.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Note that if there is an interval $$$p_l, \\ldots, p_r$$$ such that $$$r - l + 1 \\geq k$$$, and $$$s_l = s_{l+1} = \\ldots = s_r = \\tt{1}$$$, then it's impossible to satisfy all the requirements, since by iterating $$$i$$$ over $$$l$$$ to $$$r$$$, there must be some $$$i$$$ such that $$$p_i = \\max(p_l, \\ldots, p_r)$$$.Otherwise, denote $$$c$$$ as the number of occurrences of $$$\\tt{1}$$$ in the string $$$s$$$. We can always construct the permutation by filling the indices $$$i$$$ of $$$s_i = \\tt{1}$$$ with $$$1$$$ to $$$c$$$ respectively, and indices of $$$s_i = \\tt{0}$$$ with $$$(c + 1)$$$ to $$$n$$$ respectively. It works because for every interval $$$[l, r]$$$ such that $$$r - l + 1 \\geq k$$$, there is at least one index $$$l \\leq i \\leq r$$$ such that $$$s_i = \\tt{0}$$$, and it will be greater than all the indices of $$$s_i = \\tt{1}$$$.Time complexity: $$$\\mathcal O(n)$$$ per test case.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\n \nvoid solve() {\n\tint n, k; std::cin >> n >> k;\n\tstd::string s; std::cin >> s, s = \" \" + s;\n\tfor (int i = 1, j = 1; i <= n; i = ++j) if (s[i] == '1') {\n\t\twhile (j < n && s[j + 1] == '1') j++;\n\t\tif (j - i + 1 >= k) return (void)puts(\"NO\");\n\t}\n\tputs(\"YES\");\n\tint c1 = 0, c2 = std::count_if(s.begin(), s.end(), [&](char ch) -> bool { return ch == '1'; });\n\tfor (int i = 1; i <= n; ++i) \n\t\tstd::cout << (s[i] == '1' ? ++c1 : ++c2) << \" \\n\"[i == n];\n}\n \nint main() { int t; std::cin >> t; while (t--) solve(); return 0; }",
        "codes": [
          "#include <bits/stdc++.h>\n \nvoid solve() {\n\tint n, k; std::cin >> n >> k;\n\tstd::string s; std::cin >> s, s = \" \" + s;\n\tfor (int i = 1, j = 1; i <= n; i = ++j) if (s[i] == '1') {\n\t\twhile (j < n && s[j + 1] == '1') j++;\n\t\tif (j - i + 1 >= k) return (void)puts(\"NO\");\n\t}\n\tputs(\"YES\");\n\tint c1 = 0, c2 = std::count_if(s.begin(), s.end(), [&](char ch) -> bool { return ch == '1'; });\n\tfor (int i = 1; i <= n; ++i) \n\t\tstd::cout << (s[i] == '1' ? ++c1 : ++c2) << \" \\n\"[i == n];\n}\n \nint main() { int t; std::cin >> t; while (t--) solve(); return 0; }"
        ]
      },
      {
        "title": "code (python)",
        "text": "import sys\ninput=lambda:sys.stdin.readline().rstrip()\nfor _ in range(int(input())):\n  n,k=map(int,input().split())\n  s=input()\n  if \"1\"*k in s: # YES YOU WILL NOT BELIEVE THAT THIS IS O(N)\n    print(\"No\")\n  else:\n    print(\"Yes\")\n    a=sorted(range(0,n),key=lambda i:s[i],reverse=True)\n    ans=[0]*n\n    for i in range(n):\n      ans[a[i]]=i+1\n    print(*ans)",
        "codes": [
          "import sys\ninput=lambda:sys.stdin.readline().rstrip()\nfor _ in range(int(input())):\n  n,k=map(int,input().split())\n  s=input()\n  if \"1\"*k in s: # YES YOU WILL NOT BELIEVE THAT THIS IS O(N)\n    print(\"No\")\n  else:\n    print(\"Yes\")\n    a=sorted(range(0,n),key=lambda i:s[i],reverse=True)\n    ans=[0]*n\n    for i in range(n):\n      ans[a[i]]=i+1\n    print(*ans)"
        ]
      },
      {
        "title": "rate the problem!",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2135A": {
    "contest_title": "Codeforces Round 1046 (Div. 1)",
    "problem_id": "2135A",
    "problem_title": "2135A - Against the Difference",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1046 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145796",
          "full_url": "https://codeforces.com/blog/entry/145796"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "DP is needed for this problem.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "If you force some index to be in the subsequence, there is only one optimal transition.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's go for DP. Denote $$$dp(i)$$$ as the length of the longest neat subsequence of prefix $$$[a_1, a_2, \\ldots, a_i]$$$. It's obvious that $$$dp(0) \\leq dp(1) \\leq \\ldots \\leq dp(n)$$$.Suppose we have calculated $$$dp(0), \\ldots, dp(i-1)$$$. Let's try to calculate $$$dp(i)$$$:  If $$$a_i$$$ is not selected in the neat subsequence, we simply use $$$dp(i-1)$$$ to update $$$dp(i)$$$; If $$$a_i$$$ is selected in the neat subsequence, the subsequence must end with $$$a_i$$$ elements equal to $$$a_i$$$. Since the $$$dp$$$ array is monotone, we should greedily find the $$$a_i$$$-th largest index $$$x$$$ in $$$[a_1, \\ldots, a_i]$$$ where $$$a_x = a_i$$$, and use $$$dp(x-1) + a_i$$$ to update $$$dp(i)$$$. The resulting $$$dp(i)$$$ is $$$\\max(dp(i-1), dp(x-1) + a_i)$$$. Finding $$$x$$$ can be done efficiently by storing the occurrences of each different value.Time complexity: $$$\\mathcal O(n)$$$ per test case.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 10;\n\nint T, n, a[MAXN], dp[MAXN]; deque<int> q[MAXN];\n\nint main() {\n\tfor (scanf(\"%d\", &T); T--; ) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++) q[i].clear();\n\t\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdp[i] = dp[i - 1], q[a[i]].emplace_back(i);\n\t\t\tif (q[a[i]].size() > a[i]) q[a[i]].pop_front();\n\t\t\tif (q[a[i]].size() == a[i]) dp[i] = max(dp[i], dp[q[a[i]].front() - 1] + a[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", dp[n]);\n\t}\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 10;\n\nint T, n, a[MAXN], dp[MAXN]; deque<int> q[MAXN];\n\nint main() {\n\tfor (scanf(\"%d\", &T); T--; ) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++) q[i].clear();\n\t\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdp[i] = dp[i - 1], q[a[i]].emplace_back(i);\n\t\t\tif (q[a[i]].size() > a[i]) q[a[i]].pop_front();\n\t\t\tif (q[a[i]].size() == a[i]) dp[i] = max(dp[i], dp[q[a[i]].front() - 1] + a[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", dp[n]);\n\t}\n}"
        ]
      },
      {
        "title": "rate the problem!",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2135B": {
    "contest_title": "Codeforces Round 1046 (Div. 1)",
    "problem_id": "2135B",
    "problem_title": "2135B - For the Champion",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1046 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145796",
          "full_url": "https://codeforces.com/blog/entry/145796"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "You may not know the given Manhattan distance is between you and which anchor point. Can you make some moves so that you can determine it?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "The absolute value in $$$\\lvert x_i-c \\rvert + \\lvert y_i-d \\rvert$$$ is somehow annoying, because you don't know whether it's $$$(x_i - c)$$$ or $$$(c - x_i)$$$. Find a way to fix the sign of $$$(x_i - c)$$$ and $$$(y_i - d)$$$. Extra HintTry to move the robot to the top-left corner.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Read the hints.Denote $$$V$$$ as $$$10^9$$$. Let's first use four operations $$$(\\texttt{L}, V)$$$, $$$(\\texttt{L}, V)$$$, $$$(\\texttt{U}, V)$$$, and $$$(\\texttt{U}, V)$$$. Since initially $$$-V \\leq X, Y \\leq V$$$, after the four operations, it's guaranteed that $$$X', Y' \\leq -V$$$.Thus, one can note that the current value received from the jury is exactly $$$\\min\\limits_{1 \\leq i \\leq n}(\\lvert x_i - X'\\rvert + \\lvert y_i - Y'\\rvert) = \\min\\limits_{1 \\leq i \\leq n}(X' - x_i + y_i - Y')$$$, which equals $$$\\min\\limits_{1 \\leq i \\leq n}(x_i - y_i) - X + Y + 4V$$$. This gives us the value of $$$X + Y$$$.Similarly, if we move to the top-right corner (or the bottom-left one), we can know the value of $$$X - Y$$$. It would take $$$4$$$ extra steps of moving down or moving right (instead of $$$4 + 4$$$). By knowing $$$X + Y$$$ and $$$X - Y$$$, $$$X$$$ and $$$Y$$$ can be solved out.Hence, we use only $$$8$$$ operations for each test case, which is sufficient to pass.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n; cin >> n;\n    ll mn1 = LLONG_MAX, mx2 = -LLONG_MAX;\n    for (int i = 1; i <= n; i++) {\n        ll x, y; cin >> x >> y;\n        mn1 = min(mn1, y - x);\n        mx2 = max(mx2, x + y);\n    }\n    ll res;\n    cout << \"? R 1000000000\" << endl;\n    cin >> res;\n    cout << \"? R 1000000000\" << endl;\n    cin >> res;\n    cout << \"? D 1000000000\" << endl;\n    cin >> res;\n    cout << \"? D 1000000000\" << endl;\n    cin >> res;\n    ll res1 = mn1 - res + 4000000000ll;\n    cout << \"? U 1000000000\" << endl;\n    cin >> res;\n    cout << \"? U 1000000000\" << endl;\n    cin >> res;\n    cout << \"? U 1000000000\" << endl;\n    cin >> res;\n    cout << \"? U 1000000000\" << endl;\n    cin >> res;\n    ll res2 = mx2 + res - 4000000000ll;\n    cout << \"! \" << (res2 - res1) / 2 << ' ' << (res2 + res1) / 2 << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n}",
        "codes": [
          "#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n; cin >> n;\n    ll mn1 = LLONG_MAX, mx2 = -LLONG_MAX;\n    for (int i = 1; i <= n; i++) {\n        ll x, y; cin >> x >> y;\n        mn1 = min(mn1, y - x);\n        mx2 = max(mx2, x + y);\n    }\n    ll res;\n    cout << \"? R 1000000000\" << endl;\n    cin >> res;\n    cout << \"? R 1000000000\" << endl;\n    cin >> res;\n    cout << \"? D 1000000000\" << endl;\n    cin >> res;\n    cout << \"? D 1000000000\" << endl;\n    cin >> res;\n    ll res1 = mn1 - res + 4000000000ll;\n    cout << \"? U 1000000000\" << endl;\n    cin >> res;\n    cout << \"? U 1000000000\" << endl;\n    cin >> res;\n    cout << \"? U 1000000000\" << endl;\n    cin >> res;\n    cout << \"? U 1000000000\" << endl;\n    cin >> res;\n    ll res2 = mx2 + res - 4000000000ll;\n    cout << \"! \" << (res2 - res1) / 2 << ' ' << (res2 + res1) / 2 << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n}"
        ]
      },
      {
        "title": "rate the problem!",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2135D2": {
    "contest_title": "Codeforces Round 1046 (Div. 1)",
    "problem_id": "2135D2",
    "problem_title": "2135D2 - From the Unknown (Hard Version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1046 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145796",
          "full_url": "https://codeforces.com/blog/entry/145796"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Try to input $$$10^5$$$ copies of $$$1$$$ in the first query. What can you get then?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "After the first query, you can get $$$W\\in [L, R]$$$. And $$$2\\cdot L\\ge R$$$ always holds. Now, can you construct the second query?",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "Can you do something better than $$$10^5~1~1~\\ldots~1$$$ in the first query, so that the interval length will be reduced for the second query?",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "Change the first query to $$$N$$$ copies of $$$B$$$, where $$$N$$$ and $$$B$$$ are both undetermined constants.",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "Brute force to find the optimal value of $$$N$$$ and $$$B$$$.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution (easy)",
        "text": "In the first query, we will input $$$10^5$$$ copies of $$$1$$$. And the result will be equal to $$$r_1 = \\left\\lceil\\frac{10^5}{W}\\right\\rceil$$$. By solving the equation $$$\\left\\lceil\\frac{10^5}{x}\\right\\rceil = r_1$$$, we can get $$$ \\displaystyle{W\\in \\left [ \\left\\lceil\\frac{10^5}{r_1}\\right\\rceil, \\left\\lceil \\frac{10^5}{r_1 - 1} \\right\\rceil - 1 \\right ]}. $$$For example, if:  $$$r_1 = 1$$$, then $$$W=100\\,000$$$; $$$r_1 = 2$$$, then $$$W\\in [50\\,000, 99\\,999]$$$; $$$r_1 = 3$$$, then $$$W\\in [33\\,334, 49\\,999]$$$; ... For each interval $$$[L, R]$$$ above, $$$2\\cdot L > R$$$ always holds, which is because $$$\\lfloor \\frac{n}{2L} \\rfloor = \\lfloor \\frac{\\lfloor \\frac{n}{L} \\rfloor}{2} \\rfloor \\neq \\lfloor \\frac{n}{L} \\rfloor$$$.Thus, we can input the following article in the second query: $$$ [\\underline{L, 1}, \\underline{L, 2}, \\ldots, \\underline{L, R - L}]. $$$For each of the underlined group $$$(L, x)$$$:  If $$$L + x \\le W$$$, the two words in this group will be displayed in the same line; Otherwise, they will be displayed in different lines. Note that $$$L + x + L > 2\\cdot L > R \\ge W$$$, so for each $$$1\\le x \\le W - L$$$, the group $$$(L, x)$$$ takes a single line, and for each $$$W - L < x \\le R - L$$$, the group $$$(L, x)$$$ always take two lines. So the result of the query is $$$r_2 = (W - L) + 2\\cdot (R - W)$$$. Hence, we get $$$W = 2\\cdot R - L - r_2$$$. And we need to use $$$n = 2\\cdot (R - L)\\le 10^5$$$ words in this query.Thus, we solved the problem in at most $$$2$$$ queries, which fits the constraints of the Easy Version.",
        "codes": []
      },
      {
        "title": "code (easy, c++)",
        "text": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <class T>\nusing Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define all(v) v.begin(), v.end()\n#define logg(x) (31 - __builtin_clz(x))\n#define llogg(x) (63 - __builtin_clzll(x))\n#define mini(v) min_element(v.begin(), v.end())\n#define maxi(v) max_element(v.begin(), v.end())\n#define TIME cerr << double(clock() - st) / (double)CLOCKS_PER_SEC\n#define sq(a) ((a)*(a))\n#ifdef hocln\n#include \"deb.h\"\n#else\n#define imie(...) \"\"\n#define debug() cerr\n#endif\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef tuple<ll, ll, ll> triple;\ntypedef tuple<ll, ll, ll, ll, ll> five;\ntypedef unsigned long long ull;\nconst long long INF = 4e18;\nconst int inf = 2e9;\nconst int MN = 3e5 + 15;\nconst int MX = 2e6 + 15;\n//const long long MOD = 1e9 + 7;\n//const long long MOD = 998244353;\nconst long double PI = 3.141592653589793238462643383279502884197;\ntemplate<typename T, typename T2> bool chmax(T& a, const T2& b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T, typename T2> bool chmin(T& a, const T2& b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> using vector2 = vector<vector<T>>;\nconst int dx[] = { 0, 0, 1, -1, 1, 1, -1, -1 };\nconst int dy[] = { 1, -1, 0, 0 , 1, -1, 1, -1};\nstd::random_device rd;\nstd::mt19937 gen(rd());\nll random(ll low, ll high) { uniform_int_distribution<> dist(low, high); return dist(gen); }\ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1, T2>& p) {\n    is >> p.first;\n    return is >> p.second;\n}\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    for (auto &i: v) os << i << ' ';\n    return os;\n}\nint tc = 0;\n\ninline void get(int l, int r) {\n\tint len = r-l+1;\n\tcout << \"? \" << len * 2 << ' ';\n\tfor(int i = 1;i <= len;i++) {\n\t\tcout << l << ' ' << i << ' ';\n\t}\n\tcout << endl;\n\tint x;\n\tcin >> x;\n\tcout << \"! \" << len * 2 - x + l << endl;\n}\n\ninline void solve_test() {\n\tint n=1e5;\n\tcout << \"? \";\n\tcout << n << ' ';\n\tfor(int i = 1;i <= n;i++) cout << \"1 \";\n\tcout << endl;\n\tint x;\n\tcin >> x;\n\tif(x == 1) {\n\t\tcout << \"! \" << n << endl;\n\t\treturn;\n\t}\n\tint l = -1, r = -1;\n\tfor(int i = 1;i <= n;i++) {\n\t\tif((n + i - 1) / i == x && l == -1) l = i;\n\t\tif((n + i - 1) / i == x) r = i;\n\t}\n\tget(l,r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    int tt = 1;\n    cin >> tt;\n    while(tt--) {\n\t\t++tc;\n        solve_test();\n    }\n}",
        "codes": [
          "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <class T>\nusing Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define all(v) v.begin(), v.end()\n#define logg(x) (31 - __builtin_clz(x))\n#define llogg(x) (63 - __builtin_clzll(x))\n#define mini(v) min_element(v.begin(), v.end())\n#define maxi(v) max_element(v.begin(), v.end())\n#define TIME cerr << double(clock() - st) / (double)CLOCKS_PER_SEC\n#define sq(a) ((a)*(a))\n#ifdef hocln\n#include \"deb.h\"\n#else\n#define imie(...) \"\"\n#define debug() cerr\n#endif\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef tuple<ll, ll, ll> triple;\ntypedef tuple<ll, ll, ll, ll, ll> five;\ntypedef unsigned long long ull;\nconst long long INF = 4e18;\nconst int inf = 2e9;\nconst int MN = 3e5 + 15;\nconst int MX = 2e6 + 15;\n//const long long MOD = 1e9 + 7;\n//const long long MOD = 998244353;\nconst long double PI = 3.141592653589793238462643383279502884197;\ntemplate<typename T, typename T2> bool chmax(T& a, const T2& b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T, typename T2> bool chmin(T& a, const T2& b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> using vector2 = vector<vector<T>>;\nconst int dx[] = { 0, 0, 1, -1, 1, 1, -1, -1 };\nconst int dy[] = { 1, -1, 0, 0 , 1, -1, 1, -1};\nstd::random_device rd;\nstd::mt19937 gen(rd());\nll random(ll low, ll high) { uniform_int_distribution<> dist(low, high); return dist(gen); }\ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1, T2>& p) {\n    is >> p.first;\n    return is >> p.second;\n}\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    for (auto &i: v) os << i << ' ';\n    return os;\n}\nint tc = 0;\n\ninline void get(int l, int r) {\n\tint len = r-l+1;\n\tcout << \"? \" << len * 2 << ' ';\n\tfor(int i = 1;i <= len;i++) {\n\t\tcout << l << ' ' << i << ' ';\n\t}\n\tcout << endl;\n\tint x;\n\tcin >> x;\n\tcout << \"! \" << len * 2 - x + l << endl;\n}\n\ninline void solve_test() {\n\tint n=1e5;\n\tcout << \"? \";\n\tcout << n << ' ';\n\tfor(int i = 1;i <= n;i++) cout << \"1 \";\n\tcout << endl;\n\tint x;\n\tcin >> x;\n\tif(x == 1) {\n\t\tcout << \"! \" << n << endl;\n\t\treturn;\n\t}\n\tint l = -1, r = -1;\n\tfor(int i = 1;i <= n;i++) {\n\t\tif((n + i - 1) / i == x && l == -1) l = i;\n\t\tif((n + i - 1) / i == x) r = i;\n\t}\n\tget(l,r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    int tt = 1;\n    cin >> tt;\n    while(tt--) {\n\t\t++tc;\n        solve_test();\n    }\n}"
        ]
      },
      {
        "title": "solution (hard)",
        "text": "We want to cut down the total length of articles. So here comes a new strategy for the first query: $$$N$$$ copies of $$$B$$$, where $$$N$$$ and $$$B$$$ are both undetermined constants.Now, the result for the first query is $$$r_1 = \\displaystyle\\left\\lceil \\frac{N}{\\left \\lfloor\\frac{W}{B}\\right\\rfloor} \\right\\rceil$$$.If $$$W\\in [1, B - 1]$$$, the editor will be unable to display the article, and unfortunately our original strategy for the second query will not work in this case. But we can still use the strategy in the first query! Now we can query $$$B^2$$$ copies of $$$1$$$, and it's easy to show that the results for each $$$W=1,2,\\ldots,B - 1$$$ will be distinct.Otherwise, $$$W\\in [B, 10^5]$$$, similar to the easy version, we will get an interval $$$[L, R]$$$, where $$$2\\cdot L\\ge R$$$ always holds. Then, we can use the same strategy as the second query in the easy version and get a solution with $$$2\\cdot(R - L)$$$ queries. To calculate $$$L$$$ and $$$R$$$, you can simply use binary search, or do some math work to get  $$$ W\\in \\displaystyle \\left[B\\cdot \\left(\\left\\lfloor\\frac{N - 1}{r} + 1\\right\\rfloor \\right), B\\cdot \\left(\\left\\lfloor\\frac{N - 1}{r - 1} + 1\\right\\rfloor \\right) - 1\\right]. $$$There is also a fact that the rightmost interval will be cut off by the upper bound of $$$10^5$$$. We can use brute force to find suitable values for $$$N$$$ and $$$B$$$. In the main correct solution, we choose $$$N = 11\\,343$$$ and $$$B = 116$$$, and the maximal interval length is $$$6\\,263$$$. Thus, the total length of articles won't exceed $$$11\\,343 + \\max(2\\cdot 6\\,263, 116^2) = 24\\,799\\le 25\\,000$$$.By some further optimization we can reduce $$$116^2$$$ a little to $$$\\le 12\\, 526$$$, so the total length of articles can be reduced to $$$23\\,869$$$, but that's not needed.",
        "codes": []
      },
      {
        "title": "code (hard, c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXW = 100'000;\nconst int MAXSUM = 25'000;\nconst int B = 116;\nconst int K = 11343;\n\nint t;\n\ninline int ask(vector<int> v) {\n  cout << \"? \" << v.size();\n  for (int i : v) {\n    cout << ' ' << i;\n  }\n  cout << endl;\n  int x;\n  cin >> x;\n  if (x == -1) {\n    exit(0);\n  }\n  return x;\n}\ninline void answer(int x) { cout << \"! \" << x << endl; }\n\nint main() {\n  cin >> t;\n  while (t--) {\n    vector<int> v_qry1(K, B);\n    int res_qry1 = ask(v_qry1);\n    if (res_qry1 == 0) {\n      // W < B\n      vector<int> v_qry2(B * B, 1);\n      int res_qry2 = ask(v_qry2);\n      int w = (B * B - 1) / (res_qry2 - 1);\n      answer(w);\n    } else {\n      // W >= B\n      int min_w = ((K - 1) / res_qry1 + 1) * B,\n          max_w = ((K - 1) / (res_qry1 - 1) + 1) * B - 1;\n      max_w = min(max_w, MAXW);\n      for (int w = B; w <= MAXW; w++) {\n        int h = (K - 1) / (w / B) + 1;\n        if (h == res_qry1) {\n          assert(min_w <= w);\n          assert(w <= max_w);\n        } else {\n          assert(w < min_w || w > max_w);\n        }\n      }\n\n      if (min_w == max_w) {\n        answer(min_w);\n      } else {\n        vector<int> v_qry2;\n        for (int i = min_w + 2; i <= max_w; i++) {\n          v_qry2.push_back(min_w + 1);\n          v_qry2.push_back(i - min_w - 1);\n        }\n        if (v_qry2.empty()) {\n          v_qry2.push_back(min_w + 1);\n        }\n        int res_qry2 = ask(v_qry2);\n\n        if (res_qry2 == 0) {\n          answer(min_w);\n        } else {\n          answer(min_w + 1 + ((int)v_qry2.size() - res_qry2));\n        }\n      }\n    }\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXW = 100'000;\nconst int MAXSUM = 25'000;\nconst int B = 116;\nconst int K = 11343;\n\nint t;\n\ninline int ask(vector<int> v) {\n  cout << \"? \" << v.size();\n  for (int i : v) {\n    cout << ' ' << i;\n  }\n  cout << endl;\n  int x;\n  cin >> x;\n  if (x == -1) {\n    exit(0);\n  }\n  return x;\n}\ninline void answer(int x) { cout << \"! \" << x << endl; }\n\nint main() {\n  cin >> t;\n  while (t--) {\n    vector<int> v_qry1(K, B);\n    int res_qry1 = ask(v_qry1);\n    if (res_qry1 == 0) {\n      // W < B\n      vector<int> v_qry2(B * B, 1);\n      int res_qry2 = ask(v_qry2);\n      int w = (B * B - 1) / (res_qry2 - 1);\n      answer(w);\n    } else {\n      // W >= B\n      int min_w = ((K - 1) / res_qry1 + 1) * B,\n          max_w = ((K - 1) / (res_qry1 - 1) + 1) * B - 1;\n      max_w = min(max_w, MAXW);\n      for (int w = B; w <= MAXW; w++) {\n        int h = (K - 1) / (w / B) + 1;\n        if (h == res_qry1) {\n          assert(min_w <= w);\n          assert(w <= max_w);\n        } else {\n          assert(w < min_w || w > max_w);\n        }\n      }\n\n      if (min_w == max_w) {\n        answer(min_w);\n      } else {\n        vector<int> v_qry2;\n        for (int i = min_w + 2; i <= max_w; i++) {\n          v_qry2.push_back(min_w + 1);\n          v_qry2.push_back(i - min_w - 1);\n        }\n        if (v_qry2.empty()) {\n          v_qry2.push_back(min_w + 1);\n        }\n        int res_qry2 = ask(v_qry2);\n\n        if (res_qry2 == 0) {\n          answer(min_w);\n        } else {\n          answer(min_w + 1 + ((int)v_qry2.size() - res_qry2));\n        }\n      }\n    }\n  }\n}"
        ]
      },
      {
        "title": "rate the problem! (easy)",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      },
      {
        "title": "rate the problem! (hard)",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2135E2": {
    "contest_title": "Codeforces Round 1046 (Div. 1)",
    "problem_id": "2135E2",
    "problem_title": "2135E2 - Beyond the Palindrome (Hard Version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1046 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145796",
          "full_url": "https://codeforces.com/blog/entry/145796"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Replace $$$\\tt 0$$$ with $$$1$$$ and $$$\\tt 1$$$ with $$$-1$$$. Try to find a sufficient and necessary condition of $$$s$$$ almost-palindrome.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Denote the $$$\\pm 1$$$-s you get in Hint 1 as array $$$a$$$, and $$$b_i = \\sum_{j=1}^n a_j$$$. ($$$s$$$ is almost-palindrome) $$$\\Longleftrightarrow$$$ ($$$\\min b_i + \\max b_i = b_n$$$),",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "You will need to solve the following subproblem:You are on an infinite 2D plane, initially at $$$(0, 0)$$$. You can only move up/right by $$$1$$$ unit in one step. Also, you cannot touch the line $$$y=x + l$$$ or $$$y = x+ r$$$ during your move. Count the number of ways to travel to $$$(n, m)$$$.We can solve the subproblem by a technique called \"reflection inclusion-exclusion\" in $$$\\mathcal{O}\\left(\\frac{n}{|l - r|}\\right)$$$ time complexity. You can view more details in problem E1 part of this blog: https://codeforces.com/blog/entry/129027Or here is a detailed explanation in Chinese: https://www.cnblogs.com/Hanghang007/p/18159154",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "Try to compress sums by processing all $$$\\max b_i - \\min b_i = k$$$ together.",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "List out the coefficients of all $$${n\\choose m}$$$.",
        "codes": []
      },
      {
        "title": "hint 6",
        "text": "Try linear sieve.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution (easy)",
        "text": "Read the hints first.Recall the answer for the subproblem in Hint 3 as $$$f(n, m, l, r)$$$, we have $$$ f(n, m, l, r) = \\displaystyle \\sum_{k\\in \\mathbb Z} {n + m\\choose n - k\\cdot (r - l)} - {n + m\\choose n -k\\cdot (r - l) + r}. $$$Suppose $$$\\min b_i = l$$$ and $$$\\max b_i = r$$$, the number of $$$b$$$-s is the number of ways to travel from $$$(0, 0)$$$ to $$$(n, m)$$$, \"exactly\" touching $$$y=x+l$$$ and $$$y=x+r$$$, that is,  $$$f\\left(\\frac{n-(l+r)}{2},\\frac{n+(l+r)}{2},l,r\\right) - f\\left(\\frac{n-(l+r)}{2},\\frac{n+(l+r)}{2},l-1,r\\right) \\\\ -f\\left(\\frac{n-(l+r)}{2},\\frac{n+(l+r)}{2},l,r+1\\right)+f\\left(\\frac{n-(l+r)}{2},\\frac{n+(l+r)}{2},l-1,r+1\\right). $$$Now we can compress the sums by processing all $$$\\max b_i - \\min b_i = k$$$ together. Let's enumerate on $$$k$$$, and note that the upper index of binomials is always $$$\\frac{n-(l+r)}{2}+\\frac{n+(l+r)}{2}=n$$$, and the lower index moves contiguously with the same $$$k$$$. Thus, we have solved the problem in $$$\\mathcal{O}(n\\log n)$$$.",
        "codes": []
      },
      {
        "title": "code (easy, c++)",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst int MAXN = 1e6 + 10;\nconst int mod = 998244353;\n \ninline int add(int x, int y) { return x += y, x < mod ? x : x - mod; }\ninline int sub(int x, int y) { return x -= y, x < 0 ? x + mod : x; }\ninline void cadd(int &x, int y) { x += y, x < mod || (x -= mod); }\ninline void csub(int &x, int y) { x -= y, x < 0 && (x += mod); }\n \nint inv[MAXN], a[MAXN], s[MAXN];\n \ninline \nvoid init(int n) {\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;\n}\n \nint n;\n \ninline \nint ask(int l, int r) {\n\tl = max(l, 0), r = min(r, n);\n\treturn l ? sub(s[r], s[l - 1]) : s[r];\n}\n \ninline \nint calc(int k, int t) {\n\tint sum = 0;\n\tfor (int p = 0; (n + k >> 1) - p * (k + 2 - t) >= 0; p++) {\n\t\tcadd(sum, ask((n - k >> 1) - p * (k + 2 - t), (n + k >> 1) - t - p * (k + 2 - t)));\n\t}\n\tfor (int p = 0; (n - k >> 1) - 1 - p * (k + 2 - t) >= 0; p++) {\n\t\tcsub(sum, (ll)(k + 1 - t) * a[(n - k >> 1) - 1 - p * (k + 2 - t)] % mod);\n\t}\n\tfor (int p = 1; (n - k >> 1) + p * (k + 2 - t) <= n; p++) {\n\t\tcadd(sum, ask((n - k >> 1) + p * (k + 2 - t), (n + k >> 1) - t + p * (k + 2 - t)));\n\t}\n\tfor (int p = 0; (n + k >> 1) + 1 - t + p * (k + 2 - t) <= n; p++) {\n\t\tcsub(sum, (ll)(k + 1 - t) * a[(n + k >> 1) + 1 - t + p * (k + 2 - t)] % mod);\n\t}\n\treturn sum;\n}\n \nint T, ans;\n \nint main() {\n\tfor (scanf(\"%d\", &T), init(1e6 + 1); T--; ) {\n\t\tscanf(\"%d\", &n), *a = *s = 1, ans = 0;\n\t\tfor (int i = 1, x = 1; i <= n; i++) {\n\t\t\ta[i] = (ll)a[i - 1] * inv[i] % mod * (n - i + 1) % mod;\n\t\t\ts[i] = add(s[i - 1], a[i]);\n\t\t}\n\t\tfor (int i = 1, x = 0, y = 0; i <= n; i++) {\n\t\t\tif (n + i & 1) continue;\n\t\t\tcadd(ans, x), cadd(ans, x = calc(i, 0));\n\t\t\ty = calc(i, 1), csub(ans, add(y, y));\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst int MAXN = 1e6 + 10;\nconst int mod = 998244353;\n \ninline int add(int x, int y) { return x += y, x < mod ? x : x - mod; }\ninline int sub(int x, int y) { return x -= y, x < 0 ? x + mod : x; }\ninline void cadd(int &x, int y) { x += y, x < mod || (x -= mod); }\ninline void csub(int &x, int y) { x -= y, x < 0 && (x += mod); }\n \nint inv[MAXN], a[MAXN], s[MAXN];\n \ninline \nvoid init(int n) {\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;\n}\n \nint n;\n \ninline \nint ask(int l, int r) {\n\tl = max(l, 0), r = min(r, n);\n\treturn l ? sub(s[r], s[l - 1]) : s[r];\n}\n \ninline \nint calc(int k, int t) {\n\tint sum = 0;\n\tfor (int p = 0; (n + k >> 1) - p * (k + 2 - t) >= 0; p++) {\n\t\tcadd(sum, ask((n - k >> 1) - p * (k + 2 - t), (n + k >> 1) - t - p * (k + 2 - t)));\n\t}\n\tfor (int p = 0; (n - k >> 1) - 1 - p * (k + 2 - t) >= 0; p++) {\n\t\tcsub(sum, (ll)(k + 1 - t) * a[(n - k >> 1) - 1 - p * (k + 2 - t)] % mod);\n\t}\n\tfor (int p = 1; (n - k >> 1) + p * (k + 2 - t) <= n; p++) {\n\t\tcadd(sum, ask((n - k >> 1) + p * (k + 2 - t), (n + k >> 1) - t + p * (k + 2 - t)));\n\t}\n\tfor (int p = 0; (n + k >> 1) + 1 - t + p * (k + 2 - t) <= n; p++) {\n\t\tcsub(sum, (ll)(k + 1 - t) * a[(n + k >> 1) + 1 - t + p * (k + 2 - t)] % mod);\n\t}\n\treturn sum;\n}\n \nint T, ans;\n \nint main() {\n\tfor (scanf(\"%d\", &T), init(1e6 + 1); T--; ) {\n\t\tscanf(\"%d\", &n), *a = *s = 1, ans = 0;\n\t\tfor (int i = 1, x = 1; i <= n; i++) {\n\t\t\ta[i] = (ll)a[i - 1] * inv[i] % mod * (n - i + 1) % mod;\n\t\t\ts[i] = add(s[i - 1], a[i]);\n\t\t}\n\t\tfor (int i = 1, x = 0, y = 0; i <= n; i++) {\n\t\t\tif (n + i & 1) continue;\n\t\t\tcadd(ans, x), cadd(ans, x = calc(i, 0));\n\t\t\ty = calc(i, 1), csub(ans, add(y, y));\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
        ]
      },
      {
        "title": "solution (hard)",
        "text": "Read the hints and E1 editorial first. We'll try to speed up in a different way.Let's consider $$$f\\left(\\frac{n-(l+r)}{2},\\frac{n+(l+r)}{2},l,r\\right)$$$ first. Let $$$k=r-l$$$. For each $$$k=1,2,\\ldots,n$$$, we have$$$\\displaystyle\\sum_{-k\\le l\\le 0}f\\left(\\frac{n-(l+r)}{2},\\frac{n+(l+r)}{2},l,r\\right)$$$$$$=\\displaystyle\\sum_{-k\\le l\\le 0}\\sum_{z\\in\\mathbb Z} {n\\choose (n-(2z+1)\\cdot k) / 2-l}-{n\\choose (n-(2z-1)\\cdot k) / 2}$$$$$$=\\displaystyle\\sum_{-k+1\\le l\\le 0}\\sum_{z\\in\\mathbb Z} {\\color{red}{n\\choose (n-(2z+1)\\cdot k) / 2-l}}-{\\color{blue}{n\\choose (n-(2z-1)\\cdot k) / 2}}$$$$$$={\\color{red}2^{\\color{red}n}}-\\displaystyle k\\cdot { \\sum_{z\\in\\mathbb Z}\\color{blue}{n\\choose (n-(2z-1)\\cdot k) / 2}}$$$We will consider the coefficient of $$${n\\choose m}$$$ in the blue part. Note that $$$(n-(2z-1)\\cdot k) / 2 = m\\Longleftrightarrow k=(n-2m)/(2z-1)$$$. Define $$$g(n)=\\sum_{d\\mid n,2\\nmid(n/d)} d$$$, then the coefficient of $$${n\\choose m}$$$ is $$$g(|n-2m|)$$$.The other 3 parts are similar. Summing all, we got the final answer is $$$ \\displaystyle{(-1)^{n+1}\\cdot2^n+2\\sum^n_{i=0}\\binom ni(g(|n-2i-1|)-g(|n-2i|)).} $$$And we can use linear sieve to precalculate $$$g(n)$$$. Thus, the whole problem is solved in $$$\\mathcal{O}(n)$$$.",
        "codes": []
      },
      {
        "title": "code (hard, c++)",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst int MAXN = 2e7 + 10;\nconst int mod = 998244353;\n \ninline int add(int x, int y) { return x += y, x < mod ? x : x - mod; }\ninline int sub(int x, int y) { return x -= y, x < 0 ? x + mod : x; }\ninline void cadd(int &x, int y) { x += y, x < mod || (x -= mod); }\ninline void csub(int &x, int y) { x -= y, x < 0 && (x += mod); }\n \ninline \nint qpow(int b, int p) {\n\tint res = 1;\n\tfor (; p; b = (ll)b * b % mod, p >>= 1) if (p & 1) res = (ll)res * b % mod;\n\treturn res;\n}\n \nint f[MAXN], g[MAXN], p[MAXN], tot;\n \nint fac[MAXN], ifac[MAXN];\n \ninline \nvoid init(int n) {\n\tf[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (!f[i]) p[++tot] = i, f[i] = g[i] = i + (i > 2);\n\t\tfor (int j = 1; j <= tot; j++) {\n\t\t\tif (i * p[j] > n) break;\n\t\t\tif (i % p[j] == 0) {\n\t\t\t\tg[i * p[j]] = g[i] * p[j] + (j > 1);\n\t\t\t\tf[i * p[j]] = f[i] / g[i] * g[i * p[j]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf[i * p[j]] = f[i] * (p[j] + (j > 1));\n\t\t\tg[i * p[j]] = p[j] + (j > 1);\n\t\t}\n\t}\n\t*fac = 1;\n\tfor (int i = 1; i <= n; i++) fac[i] = (ll)fac[i - 1] * i % mod;\n\tifac[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n; i; i--) ifac[i - 1] = (ll)ifac[i] * i % mod;\n}\n \nint T, n, ans;\n \nint main() {\n\tfor (scanf(\"%d\", &T), init(2e7 + 1); T--; ) {\n\t\tscanf(\"%d\", &n), ans = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tans = (ans + (ll)ifac[i] * ifac[n - i] % mod * sub(f[abs(n - i * 2 - 1)], f[abs(n - i * 2)])) % mod;\n\t\t}\n\t\tans = (ll)ans * fac[n] % mod;\n\t\tcadd(ans, ans), (n & 1 ? cadd : csub)(ans, qpow(2, n));\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst int MAXN = 2e7 + 10;\nconst int mod = 998244353;\n \ninline int add(int x, int y) { return x += y, x < mod ? x : x - mod; }\ninline int sub(int x, int y) { return x -= y, x < 0 ? x + mod : x; }\ninline void cadd(int &x, int y) { x += y, x < mod || (x -= mod); }\ninline void csub(int &x, int y) { x -= y, x < 0 && (x += mod); }\n \ninline \nint qpow(int b, int p) {\n\tint res = 1;\n\tfor (; p; b = (ll)b * b % mod, p >>= 1) if (p & 1) res = (ll)res * b % mod;\n\treturn res;\n}\n \nint f[MAXN], g[MAXN], p[MAXN], tot;\n \nint fac[MAXN], ifac[MAXN];\n \ninline \nvoid init(int n) {\n\tf[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (!f[i]) p[++tot] = i, f[i] = g[i] = i + (i > 2);\n\t\tfor (int j = 1; j <= tot; j++) {\n\t\t\tif (i * p[j] > n) break;\n\t\t\tif (i % p[j] == 0) {\n\t\t\t\tg[i * p[j]] = g[i] * p[j] + (j > 1);\n\t\t\t\tf[i * p[j]] = f[i] / g[i] * g[i * p[j]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf[i * p[j]] = f[i] * (p[j] + (j > 1));\n\t\t\tg[i * p[j]] = p[j] + (j > 1);\n\t\t}\n\t}\n\t*fac = 1;\n\tfor (int i = 1; i <= n; i++) fac[i] = (ll)fac[i - 1] * i % mod;\n\tifac[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n; i; i--) ifac[i - 1] = (ll)ifac[i] * i % mod;\n}\n \nint T, n, ans;\n \nint main() {\n\tfor (scanf(\"%d\", &T), init(2e7 + 1); T--; ) {\n\t\tscanf(\"%d\", &n), ans = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tans = (ans + (ll)ifac[i] * ifac[n - i] % mod * sub(f[abs(n - i * 2 - 1)], f[abs(n - i * 2)])) % mod;\n\t\t}\n\t\tans = (ll)ans * fac[n] % mod;\n\t\tcadd(ans, ans), (n & 1 ? cadd : csub)(ans, qpow(2, n));\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
        ]
      },
      {
        "title": "rate the problem! (easy)",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      },
      {
        "title": "rate the problem! (hard)",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2135F": {
    "contest_title": "Codeforces Round 1046 (Div. 1)",
    "problem_id": "2135F",
    "problem_title": "2135F - To the Infinity",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1046 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145796",
          "full_url": "https://codeforces.com/blog/entry/145796"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "How to compare two $$$f$$$ values? Since this function grows extremely fast, try to compare $$$\\ln f$$$, $$$\\ln \\ln f$$$ and so on.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "You only need to compare lexicographical order.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "How to quickly compare lexicographical order? Try using hashing.",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "Use a data structure to maintain the hash value for each point.",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "Consider performing a topological sort on the tree from the bottom up. Then, when a node needs to be inserted into another tree, its ranking is already determined. A segment tree can be used instead of a balanced tree.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "First, define the concept of a $$$\\textbf{power tower}$$$. $$$X$$$ is a power tower if and only if one of the following holds:  $$$X = x$$$. $$$X = x^{X_1X_2\\cdots X_m}$$$, where $$$m$$$ is a constant independent of $$$x$$$, and $$$X_1, X_2, \\cdots, X_m$$$ are all power towers. Clearly, for power towers $$$X$$$ and $$$Y$$$, $$$X^Y$$$ is also a power tower. Therefore, in this problem, any $$$f_u(x)$$$ is a power tower.First, consider how to compare two power towers $$$X$$$ and $$$Y$$$. The steps are as follows:  If $$$X = x$$$ or $$$Y = x$$$, directly return their magnitudes. Otherwise, let $$$X = x^{X_1X_2\\cdots X_p}$$$, $$$Y = x^{Y_1Y_2\\cdots Y_q}$$$, where the quantities in the exponents are power towers.    Sort $$$X_1, X_2, \\cdots, X_p$$$ and $$$Y_1, Y_2, \\cdots, Y_q$$$ in descending order. Compare their lexicographical order. If the lexicographical orders are equal, return that $$$X$$$ and $$$Y$$$ are equal; otherwise, return that the power tower with the larger lexicographical order is greater than the one with the smaller lexicographical order.  This gives a solution that can determine the relative sizes of two power towers in polynomial complexity. However, this is far from sufficient.To optimize the complexity, when comparing $$$X$$$ and $$$Y$$$, we at least need to know the sorted order of $$$X_1, X_2, \\cdots, X_p$$$ and $$$Y_1, Y_2, \\cdots, Y_q$$$. This is equivalent to knowing the size relationships among them.A key property of the tree can be easily observed: Let $$$fa_u$$$ be the father of $$$u$$$ in the tree. Then, it must hold that $$$f_u(x) \\prec f_{fa_u}(x)$$$. Consider performing a topological sort on the original tree and using a heap to maintain the current queue. Each time, the smallest node is taken out to update the others. For any node $$$u$$$ in the queue, the corresponding power tower $$$X = f_u(x)$$$ already has known rankings for $$$X_1, X_2, \\cdots, X_p$$$. A persistent segment tree can then be used to maintain prefix-sum hashes. When comparing two power towers, binary search can be performed on the segment tree to quickly find the first position where their exponent power towers differ, achieving a fast comparison in $$$\\mathcal{O}(\\log n)$$$ time per operation. Time complexity: $$$\\mathcal{O}(n\\log^2 n)$$$ per test case.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef unsigned long long ull;\n \nconst int MAXN = 4e5 + 10;\n \null A = mt19937_64(time(0))();\n \ninline ull shift(ull x) {\n\treturn x ^= A, x ^= x << 13, x ^= x >> 7, x ^= x << 11, x ^= A;\n}\n \nstruct node {\n\tint l, r, num; ull val;\n} t[MAXN * 20]; int cnt, rt[MAXN];\n \nvoid add(int &p, int pre, int l, int r, int k, ull x) {\n\tt[p = ++cnt] = t[pre], t[p].val += x, t[p].num++;\n\tif (l == r) return ; int mid = l + r >> 1;\n\tif (k <= mid) add(t[p].l, t[pre].l, l, mid, k, x);\n\telse add(t[p].r, t[pre].r, mid + 1, r, k, x);\n}\n \nbool find(int p, int pre, int l, int r) {\n\tif (l == r) return t[p].num > t[pre].num; int mid = l + r >> 1;\n\tif (t[t[p].r].val == t[t[pre].r].val) return find(t[p].l, t[pre].l, l, mid);\n\telse return find(t[p].r, t[pre].r, mid + 1, r);\n}\n \nint n, l[MAXN], r[MAXN], fa[MAXN], d[MAXN];\n \nint rk[MAXN], tot, lst; ull h[MAXN];\n \nstruct cmp {\n\tbool operator () (int x, int y) {\n\t\treturn h[x] == h[y] ? x > y : find(rt[x], rt[y], 1, n);\n\t}\n}; priority_queue<int, vector<int>, cmp> q;\n \n \ninline \nvoid upd(int u) {\n\th[u] = h[l[u]] + shift(h[r[u]]);\n\tadd(rt[u], rt[l[u]], 1, n, rk[r[u]], shift(h[r[u]]));\n}\n \nint T;\n \nint main() {\n\tfor (scanf(\"%d\", &T); T--; ) {\n\t\tscanf(\"%d\", &n), cnt = lst = tot = 0;\n\t\tfor (int i = 1; i <= n; i++) rt[i] = 0; \n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\t\td[i] = (l[i] && r[i] ? 2 : 0), fa[l[i]] = fa[r[i]] = i;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) if (!d[i]) h[i] = 1, q.emplace(i);\n\t\tfor (int u; !q.empty(); ) {\n\t\t\tprintf(\"%d \", u = q.top()), q.pop();\n\t\t\tif (h[u] != h[lst]) tot++; lst = u, rk[u] = tot;\n\t\t\tif (!--d[fa[u]]) upd(fa[u]), q.push(fa[u]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef unsigned long long ull;\n \nconst int MAXN = 4e5 + 10;\n \null A = mt19937_64(time(0))();\n \ninline ull shift(ull x) {\n\treturn x ^= A, x ^= x << 13, x ^= x >> 7, x ^= x << 11, x ^= A;\n}\n \nstruct node {\n\tint l, r, num; ull val;\n} t[MAXN * 20]; int cnt, rt[MAXN];\n \nvoid add(int &p, int pre, int l, int r, int k, ull x) {\n\tt[p = ++cnt] = t[pre], t[p].val += x, t[p].num++;\n\tif (l == r) return ; int mid = l + r >> 1;\n\tif (k <= mid) add(t[p].l, t[pre].l, l, mid, k, x);\n\telse add(t[p].r, t[pre].r, mid + 1, r, k, x);\n}\n \nbool find(int p, int pre, int l, int r) {\n\tif (l == r) return t[p].num > t[pre].num; int mid = l + r >> 1;\n\tif (t[t[p].r].val == t[t[pre].r].val) return find(t[p].l, t[pre].l, l, mid);\n\telse return find(t[p].r, t[pre].r, mid + 1, r);\n}\n \nint n, l[MAXN], r[MAXN], fa[MAXN], d[MAXN];\n \nint rk[MAXN], tot, lst; ull h[MAXN];\n \nstruct cmp {\n\tbool operator () (int x, int y) {\n\t\treturn h[x] == h[y] ? x > y : find(rt[x], rt[y], 1, n);\n\t}\n}; priority_queue<int, vector<int>, cmp> q;\n \n \ninline \nvoid upd(int u) {\n\th[u] = h[l[u]] + shift(h[r[u]]);\n\tadd(rt[u], rt[l[u]], 1, n, rk[r[u]], shift(h[r[u]]));\n}\n \nint T;\n \nint main() {\n\tfor (scanf(\"%d\", &T); T--; ) {\n\t\tscanf(\"%d\", &n), cnt = lst = tot = 0;\n\t\tfor (int i = 1; i <= n; i++) rt[i] = 0; \n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\t\td[i] = (l[i] && r[i] ? 2 : 0), fa[l[i]] = fa[r[i]] = i;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) if (!d[i]) h[i] = 1, q.emplace(i);\n\t\tfor (int u; !q.empty(); ) {\n\t\t\tprintf(\"%d \", u = q.top()), q.pop();\n\t\t\tif (h[u] != h[lst]) tot++; lst = u, rk[u] = tot;\n\t\t\tif (!--d[fa[u]]) upd(fa[u]), q.push(fa[u]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
        ]
      },
      {
        "title": "rate the problem!",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2135C": {
    "contest_title": "Codeforces Round 1046 (Div. 1)",
    "problem_id": "2135C",
    "problem_title": "C. By the Assignment",
    "time_limit": "4 seconds",
    "memory_limit": "512 megabytes",
    "statement": "For an undirected connected graph of $$$n$$$ vertices, where the $$$i$$$-thvertexhas a weight of $$$v_i$$$, we define thevalueof a simple path$$$^{\\text{∗}}$$$ $$$l_1, l_2, \\ldots, l_m$$$ as $$$v_{l_1}\\oplus v_{l_2}\\oplus\\cdots\\oplus v_{l_m}$$$$$$^{\\text{†}}$$$. We call the graphbalancedif and only if:For every $$$1\\le p<q\\le n$$$, all simple paths from $$$p$$$ to $$$q$$$ have the samevalue.Aquawave has given you an undirected connected graph of $$$n$$$ vertices and $$$m$$$ edges, and the $$$i$$$-th vertex in the graph has a weight of $$$a_i$$$. However, some of the weights are missing, represented by $$$-1$$$.Aquawave wants to assign an integer weight between $$$0$$$ and $$$V-1$$$ to each vertex with $$$a_i=-1$$$, so that the graph will bebalanced.You have to help Aquawave find the number of ways to assign weights to achieve the goal, modulo $$$998\\,244\\,353$$$.$$$^{\\text{∗}}$$$A simple path from $$$c$$$ to $$$d$$$ is a sequence of vertices $$$l_1, l_2, \\ldots, l_m$$$, where $$$l_1=c$$$, $$$l_m=d$$$, such that there is an edge between $$$l_i$$$ and $$$l_{i+1}$$$ for every $$$1\\le i\\le m-1$$$, and there are no repeated vertices, i.e. $$$l_i\\ne l_j$$$ for $$$1\\le i<j\\le n$$$.$$$^{\\text{†}}$$$$$$\\oplus$$$ denotes thebitwise XOR operation.\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10^4$$$). The description of the test cases follows.The first line of each test case contains three integers $$$n$$$, $$$m$$$, and $$$V$$$ ($$$2\\le n\\le 2\\cdot 10^5$$$, $$$n-1\\le m\\le \\min\\left(\\frac{n(n-1)}{2}, 4\\cdot 10^5\\right)$$$, $$$1\\le V\\le 10^9$$$) — the number of vertices, the number of edges, and the upper bound of weights.The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$-1\\le a_i\\le V-1$$$) — the weights of the vertices. $$$a_i=-1$$$ represents that the weight of the $$$i$$$-th vertex is missing.Then $$$m$$$ lines follow, the $$$i$$$-th line containing two integers $$$u$$$ and $$$v$$$ ($$$1\\le u,v\\le n$$$) — the two vertices that the $$$i$$$-th edge connects.It is guaranteed that the given graph is simple and connected.It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2\\cdot 10^5$$$, and the sum of $$$m$$$ over all test cases does not exceed $$$4\\cdot 10^5$$$.\n\nOutputFor each test case, output a single integer — the number of ways to assign weights to make the graphbalanced, modulo $$$998\\,244\\,353$$$.",
    "sample_inputs": [
      "54 4 4-1 -1 -1 -11 22 31 34 35 6 72 2 -1 2 21 21 31 42 53 54 57 8 9-1 -1 -1 -1 0 -1 01 22 33 41 41 55 67 67 55 8 10000000001 2 3 4 -11 23 23 55 12 44 32 51 45 4 1000000000-1 2 -1 3 -11 21 32 42 5"
    ],
    "sample_outputs": [
      "4\n1\n9\n0\n747068572"
    ],
    "notes": "NoteIn the first test case, there are four possible assignments:$$$a=[0,0,0,0]$$$;$$$a=[0,0,0,1]$$$;$$$a=[0,0,0,2]$$$;$$$a=[0,0,0,3]$$$.It can be shown that all of these assignments can make the graphbalanced.In the second test case, we will pick $$$(p,q)=(1,5)$$$. The simple path $$$1\\to 2\\to 5$$$ has avalueof $$$2\\oplus 2\\oplus 2=2$$$, and the simple path $$$1\\to 3\\to 5$$$ has avalueof $$$2\\oplus a_3\\oplus 2=a_3$$$, so the only possible value for $$$a_3$$$ is $$$2$$$. It can be shown that $$$a_3=2$$$ can make the graphbalanced.In the fifth test case, the given graph is a tree, so there is only one simple path between any two vertices. Thus, we can assign an arbitrary value between $$$0$$$ and $$$V-1$$$ to each $$$a_i$$$, and the answer is $$$1\\,000\\,000\\,000^3\\bmod998\\,244\\,353=747\\,068\\,572$$$.",
    "tags": [
      "binary search",
      "bitmasks",
      "combinatorics",
      "dfs and similar",
      "dsu",
      "graphs",
      "math",
      "*2000"
    ],
    "url": "https://codeforces.com/problemset/problem/2135/C",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1046 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145796",
          "full_url": "https://codeforces.com/blog/entry/145796"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Consider the value of nodes on a cycle.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Consider the parity of the cycle's length.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "The following are equivalent statements:  \"There is a cycle containing nodes $$$u, v$$$\"; \"Nodes $$$u, v$$$ are in the same two-edge-connected component\".",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "Two two-edge-connected components don't affect each other.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Read the hints.First, focus on a simple cycle only. Denote its length as $$$l$$$. We can choose two arbitrary nodes $$$u$$$ and $$$v$$$ on the cycle, obtaining two different simple paths. The two paths have equal values for all pairs of $$$(u, v)$$$. This implies that, for each set of size $$$l-2$$$ containing only nodes on the cycle, the bitwise XOR of the weight of the nodes in the set should equal $$$0$$$.Thus, all nodes on the cycle have equal weight, since when sets $$$S_0 \\cup {v}$$$ and $$$S_0 \\cup {u}$$$ have equal bitwise XOR of node weights, this leads to nodes $$$u$$$ and $$$v$$$ having equal weights. Additionally, if $$$l$$$ is odd, one can verify that the weight of nodes on the cycle must be equal to $$$0$$$ (otherwise, it can be an arbitrary integer in $$$[0, V)$$$).By decomposing the graph into two-edge-connected components, one can easily determine whether two nodes share a cycle —— by checking whether they belong to the same component. The answer is independent in each component, so we can simply multiply them together.How to calculate the answer for a two-edge-connected component? First of all, the weight of all nodes must be equal. Then, if there exists an odd cycle (which can be detected with 2-coloring), it should equal $$$0$$$. There are only three different possible answers: $$$0$$$, $$$1$$$, and $$$V$$$.Thus, one can calculate the answer to the original problem efficiently.Time Complexity: $$$\\mathcal O(n + m)$$$ per test case.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 10;\nconst int mod = 998244353;\n\nvector<int> g[MAXN], dcc[MAXN];\n\nint dfn[MAXN], low[MAXN], id;\n\nint s[MAXN], tp, p[MAXN], cnt;\n\nvoid tarjan(int u, int f = 0) {\n\tdfn[u] = low[u] = ++id, s[++tp] = u;\n\tfor (int v : g[u]) {\n\t\tif (!dfn[v]) tarjan(v, u), low[u] = min(low[u], low[v]);\n\t\telse if (v != f) low[u] = min(low[u], dfn[v]);\n\t}\n\tif (dfn[u] == low[u]) {\n\t\tcnt++;\n\t\tfor (int x = 0; x != u; ) {\n\t\t\tx = s[tp--], p[x] = cnt;\n\t\t\tdcc[cnt].emplace_back(x);\n\t\t}\n\t}\n}\n\nint col[MAXN];\n\nbool check(int u, int f = 0) {\n\tif (~col[u]) return col[u] == f; col[u] = f;\n\tfor (int v : g[u]) if (p[u] == p[v] && !check(v, f ^ 1)) return 0;\n\treturn 1;\n}\n\nint T, n, m, V, a[MAXN], ans;\n\nint main() {\n\tfor (scanf(\"%d\", &T); T--; ) {\n\t\tscanf(\"%d%d%d\", &n, &m, &V), id = cnt = 0, ans = 1;\n\t\tfor (int i = 1; i <= n; i++) dfn[i] = low[i] = p[i] = 0, col[i] = -1;\n\t\tfor (int i = 1; i <= n; i++) g[i].clear(), dcc[i].clear();\n\t\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 1, u, v; i <= m; i++) {\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tg[u].emplace_back(v), g[v].emplace_back(u);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);\n\t\tfor (int i = 1; i <= cnt; i++) {\n\t\t\tint x = -1;\n\t\t\tfor (int u : dcc[i]) {\n\t\t\t\tif (a[u] < 0) continue;\n\t\t\t\tif (x < 0) x = a[u];\n\t\t\t\telse if (x != a[u]) { ans = 0; break; }\n\t\t\t}\n\t\t\tif (!ans) break;\n\t\t\tbool f = check(dcc[i][0]);\n\t\t\tif (f) { if (x < 0) ans = (ll)ans * V % mod; }\n\t\t\telse if (x > 0) ans = 0;\n\t\t\tif (!ans) break;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 10;\nconst int mod = 998244353;\n\nvector<int> g[MAXN], dcc[MAXN];\n\nint dfn[MAXN], low[MAXN], id;\n\nint s[MAXN], tp, p[MAXN], cnt;\n\nvoid tarjan(int u, int f = 0) {\n\tdfn[u] = low[u] = ++id, s[++tp] = u;\n\tfor (int v : g[u]) {\n\t\tif (!dfn[v]) tarjan(v, u), low[u] = min(low[u], low[v]);\n\t\telse if (v != f) low[u] = min(low[u], dfn[v]);\n\t}\n\tif (dfn[u] == low[u]) {\n\t\tcnt++;\n\t\tfor (int x = 0; x != u; ) {\n\t\t\tx = s[tp--], p[x] = cnt;\n\t\t\tdcc[cnt].emplace_back(x);\n\t\t}\n\t}\n}\n\nint col[MAXN];\n\nbool check(int u, int f = 0) {\n\tif (~col[u]) return col[u] == f; col[u] = f;\n\tfor (int v : g[u]) if (p[u] == p[v] && !check(v, f ^ 1)) return 0;\n\treturn 1;\n}\n\nint T, n, m, V, a[MAXN], ans;\n\nint main() {\n\tfor (scanf(\"%d\", &T); T--; ) {\n\t\tscanf(\"%d%d%d\", &n, &m, &V), id = cnt = 0, ans = 1;\n\t\tfor (int i = 1; i <= n; i++) dfn[i] = low[i] = p[i] = 0, col[i] = -1;\n\t\tfor (int i = 1; i <= n; i++) g[i].clear(), dcc[i].clear();\n\t\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 1, u, v; i <= m; i++) {\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tg[u].emplace_back(v), g[v].emplace_back(u);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);\n\t\tfor (int i = 1; i <= cnt; i++) {\n\t\t\tint x = -1;\n\t\t\tfor (int u : dcc[i]) {\n\t\t\t\tif (a[u] < 0) continue;\n\t\t\t\tif (x < 0) x = a[u];\n\t\t\t\telse if (x != a[u]) { ans = 0; break; }\n\t\t\t}\n\t\t\tif (!ans) break;\n\t\t\tbool f = check(dcc[i][0]);\n\t\t\tif (f) { if (x < 0) ans = (ll)ans * V % mod; }\n\t\t\telse if (x > 0) ans = 0;\n\t\t\tif (!ans) break;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
        ]
      },
      {
        "title": "rate the problem!",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2155A": {
    "contest_title": "Codeforces Round 1056 (Div. 2)",
    "problem_id": "2155A",
    "problem_title": "2155A - El fucho",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1056 (Div. 2) Editorial",
          "url": "/blog/entry/147174",
          "full_url": "https://codeforces.com/blog/entry/147174"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "When two teams in the same group face off against each other, exactly one of them stays in the group.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution 1",
        "text": "The answer for all $$$n$$$ is $$$2n-2$$$.Let's consider the winners' group first. Note that exactly one team drops to the losers' bracket for every match in this group. Only one team is left in the winners' group right before the end, so $$$n-1$$$ matches must have been played in the winners' group right before the final match.Similar logic applies to the losers' group. $$$n-1$$$ teams in total drop down to the losers' group over the course of the tournament. For every match played between two teams in this group, exactly one team is eliminated from the tournament. A single team in left in this group right before the final match, so $$$n-2$$$ matches must have been played in the losers' group right before the final match.Finally, we add the final match to our calculation, bringing the total to  $$$(n-1)+(n-2)+1 = 2n-2$$$",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\n  int n, t; \n\n  cin >> t;\n\n  while(t--) {\n\n     cin >> n;\n\n     cout << 2*n-2 << \"\\n\";\n\n  }\n\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\n  int n, t; \n\n  cin >> t;\n\n  while(t--) {\n\n     cin >> n;\n\n     cout << 2*n-2 << \"\\n\";\n\n  }\n\n}"
        ]
      },
      {
        "title": "solution 2",
        "text": "Alternatively, we can simulate the process directly.Suppose there are $$$a$$$ teams in the winners' group and $$$b$$$ teams in the losers' group right before a round.First, $$$\\left \\lfloor \\frac{b}{2} \\right \\rfloor$$$ matches are played among the teams in the losers' group, so $$$\\left \\lfloor \\frac{b}{2} \\right \\rfloor$$$ are eliminated in this step. We subtract this number from $$$b$$$ and add $$$\\left \\lfloor \\frac{b}{2} \\right \\rfloor$$$ to the total number of matches played.Then, $$$\\left \\lfloor \\frac{a}{2} \\right \\rfloor$$$ matches are played among the teams in the winners' group, so $$$\\left \\lfloor \\frac{a}{2} \\right \\rfloor$$$ of them drop down to the losers' group. We subtract this number from $$$b$$$ and add $$$\\left \\lfloor \\frac{b}{2} \\right \\rfloor$$$ to the total number of matches played. After simulating $$$\\mathcal{O}(\\log (n))$$$ rounds as described above, both brackets are left with a single team, so we add $$$1$$$ to our total.Time complexity: $$$\\mathcal{O}(\\log (n))$$$",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n\t\n\tint n, t, winners, losers, ans;\n\t\n\tcin >> t;\n\t\n\twhile(t--) {\n\t   cin >> n;\n\t   winners = n;\n\t   losers = 0;\n\t   ans = 0;\n\t   \n\t   while(max(losers, winners) > 1) {\n\t       ans += losers/2;\n\t       losers = (losers+1)/2;\n\t       \n\t       ans += winners/2; \n\t       losers += winners/2; \n\t       winners++;\n\t       winners /= 2;\n\t   }\n\t   \n\t   ans++;\n\t   \n\t   cout << ans << \"\\n\";\n\t}\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n\t\n\tint n, t, winners, losers, ans;\n\t\n\tcin >> t;\n\t\n\twhile(t--) {\n\t   cin >> n;\n\t   winners = n;\n\t   losers = 0;\n\t   ans = 0;\n\t   \n\t   while(max(losers, winners) > 1) {\n\t       ans += losers/2;\n\t       losers = (losers+1)/2;\n\t       \n\t       ans += winners/2; \n\t       losers += winners/2; \n\t       winners++;\n\t       winners /= 2;\n\t   }\n\t   \n\t   ans++;\n\t   \n\t   cout << ans << \"\\n\";\n\t}\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2155B": {
    "contest_title": "Codeforces Round 1056 (Div. 2)",
    "problem_id": "2155B",
    "problem_title": "2155B - Abraham's Great Escape",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1056 (Div. 2) Editorial",
          "url": "/blog/entry/147174",
          "full_url": "https://codeforces.com/blog/entry/147174"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "There is exactly one value of $$$k$$$ that doesn't work",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Two arrows facing each other trap Abraham forever.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "We claim that the only value of $$$k$$$ for which the answer is $$$\\texttt{NO}$$$ is $$$k = n*n-1$$$. If $$$k = n^2-1$$$ were possible, Abraham should be trapped forever from exactly $$$n^2-(n^2-1) = 1$$$ starting cell, but the arrow in that cell would necessarily point towards the outside of the grid, or in the direction of another cell from which Abraham will eventually escape, so this situation is impossible and we should print $$$\\texttt{NO}$$$.All other values of $$$k$$$ are achievable with the following construction:   Fill up rows of the grid with $$$\\texttt{U}$$$ from left to right and from top to bottom. You should place $$$k$$$ of this letter in total. Fill every cell that doesn't have a $$$\\texttt{U}$$$ already and isn't in the last row with a $$$\\texttt{D}$$$. (These cells might be non-existent) Fill the leftmost unoccupied cell in the last row with an $$$R$$$ and all the cells to its right with an $$$L$$$. (Note that at least one $$$L$$$ is placed). This works because, if Abraham steps on a $$$\\texttt{U}$$$, he will be pushed onto another $$$\\texttt{U}$$$, and so on until he leaves the board.On the other hand, if he steps on a $$$\\texttt{D}$$$, he will be carried along all the way to an $$$\\texttt{R}$$$ or $$$\\texttt{L}$$$ in the last row. It's easy to see that these directions necessarily trap Abraham.Time complexity: $$$\\mathcal{O}(n^2)$$$",
        "codes": []
      },
      {
        "title": "code (python)",
        "text": "t = int(input())\n \nfor q in range(t):\n    n, k = (int(x) for x in input().split())\n \n    if(k == n*n-1):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for i in range(n):\n \n            s = \"\"\n            for j in range(n):\n                if(k > 0):\n                    s += \"U\"\n                    k -= 1\n                elif(i == n-1 and j == n-1):\n                    s += \"L\"\n                elif(i == n-1):\n                    s += \"R\"\n                else:\n                    s += \"D\"\n \n            print(s)",
        "codes": [
          "t = int(input())\n \nfor q in range(t):\n    n, k = (int(x) for x in input().split())\n \n    if(k == n*n-1):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for i in range(n):\n \n            s = \"\"\n            for j in range(n):\n                if(k > 0):\n                    s += \"U\"\n                    k -= 1\n                elif(i == n-1 and j == n-1):\n                    s += \"L\"\n                elif(i == n-1):\n                    s += \"R\"\n                else:\n                    s += \"D\"\n \n            print(s)"
        ]
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2155C": {
    "contest_title": "Codeforces Round 1056 (Div. 2)",
    "problem_id": "2155C",
    "problem_title": "2155C - The Ancient Wizards' Capes",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1056 (Div. 2) Editorial",
          "url": "/blog/entry/147174",
          "full_url": "https://codeforces.com/blog/entry/147174"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "What's the maximum value that $$$|a_{i+1} - a_i|$$$ can attain for any $$$i$$$?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Bound the number of possible cape arrangements",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Suppose that Harry's list corresponds to at least one arrangement of capes. The main claim is that any two consecutive values in his list differ by at most $$$1$$$.Note that when Harry walks from position $$$i$$$ to position $$$i+1$$$, the visibility of wizard $$$1$$$ to $$$i-1$$$ and $$$i+2$$$ to $$$n$$$ is unaffected, so there are four possible situations regarding the other $$$2$$$ wizards:  Wizards $$$i$$$ and $$$i+1$$$ wear their capes to their left. Wizard $$$i+1$$$ becomes visible and wizard $$$i$$$ can still be seen from position $$$i+1$$$, so $$$a_{i+1}-a_i = 1$$$ Wizards $$$i$$$ and $$$i+1$$$ wear their capes to their right. Wizard $$$i+1$$$ remains visible while wizard $$$i$$$ becomes invisible from position $$$i+1$$$, so $$$a_{i+1}-a_i = -1$$$ Wizard $$$i$$$ wears his cape to his left while wizard $$$i+1$$$ wears his cape to his right. Both wizards are still visible from position $$$i+1$$$, so $$$a_{i+1}-a_i = 0$$$ Wizard $$$i$$$ wears his cape to his left while wizard $$$i+1$$$ wears his cape to his right. Wizard $$$i+1$$$ becomes visible, but wizard $$$i$$$ becomes invisible when moving to position $$$i+1$$$, so $$$a_{i+1}-a_i = 0$$$ In summary, if both wizards wear their capes the same way, the difference between the corresponding entries in Harry's list is $$$1$$$. Else, it is $$$0$$$. Note that this uniquely determines the entire list based on how wizard $$$1$$$ is wearing his cape if and only if $$$|a_{i+1}-a_i| < 2$$$ for all $$$1 \\le i < n$$$. Thus, there are at most two possible arrangements for the wizards' capes. We can construct both of them and check whether they are consistent with Harry's list.Time complexity: Time complexity: $$$\\mathcal{O}(n)$$$",
        "codes": []
      },
      {
        "title": "code (python)",
        "text": "def validar(x, n, a):\n    flag = False\n    visibles = 1\n \n    for i in range(2, n+1):\n        if(x[i] == 1):\n            visibles += 1\n \n    if(visibles == a[1]):\n        flag = True\n \n        for i in range(1, n):\n            if(x[i] == 1 and x[i+1] == 1):\n                visibles -= 1\n            elif(x[i] == 0 and x[i+1] == 0):\n                visibles += 1\n \n            if(a[i+1] != visibles):\n                flag = False\n                break\n \n    return flag\n \nt = int(input())\n \nfor i in range(t):\n    sol1 = []\n    sol2 = []\n    sol1.append(0)\n    sol2.append(0)\n    sol1.append(0)\n    sol2.append(1)\n    flag = True\n    cont = 0\n    \n    n = int(input())\n    arr = []\n    arr.append(0)\n    arr.extend(map(int, input().split()))\n \n    for j in range(1, n): \n        if(arr[j+1]-arr[j] > 1):\n            flag = False\n            break\n \n        if(arr[j+1]-arr[j] == 0):\n            sol1.append(1-sol1[j])\n            sol2.append(1-sol2[j])\n        else:\n            sol1.append(sol1[j])\n            sol2.append(sol2[j])\n \n    if(not flag):\n        print(0)\n        continue\n \n    if(validar(sol1, n, arr)):\n        cont += 1\n \n    if(validar(sol2, n, arr)):\n        cont += 1\n \n    print(cont)",
        "codes": [
          "def validar(x, n, a):\n    flag = False\n    visibles = 1\n \n    for i in range(2, n+1):\n        if(x[i] == 1):\n            visibles += 1\n \n    if(visibles == a[1]):\n        flag = True\n \n        for i in range(1, n):\n            if(x[i] == 1 and x[i+1] == 1):\n                visibles -= 1\n            elif(x[i] == 0 and x[i+1] == 0):\n                visibles += 1\n \n            if(a[i+1] != visibles):\n                flag = False\n                break\n \n    return flag\n \nt = int(input())\n \nfor i in range(t):\n    sol1 = []\n    sol2 = []\n    sol1.append(0)\n    sol2.append(0)\n    sol1.append(0)\n    sol2.append(1)\n    flag = True\n    cont = 0\n    \n    n = int(input())\n    arr = []\n    arr.append(0)\n    arr.extend(map(int, input().split()))\n \n    for j in range(1, n): \n        if(arr[j+1]-arr[j] > 1):\n            flag = False\n            break\n \n        if(arr[j+1]-arr[j] == 0):\n            sol1.append(1-sol1[j])\n            sol2.append(1-sol2[j])\n        else:\n            sol1.append(sol1[j])\n            sol2.append(sol2[j])\n \n    if(not flag):\n        print(0)\n        continue\n \n    if(validar(sol1, n, arr)):\n        cont += 1\n \n    if(validar(sol2, n, arr)):\n        cont += 1\n \n    print(cont)"
        ]
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2155D": {
    "contest_title": "Codeforces Round 1056 (Div. 2)",
    "problem_id": "2155D",
    "problem_title": "2155D - Batteries",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1056 (Div. 2) Editorial",
          "url": "/blog/entry/147174",
          "full_url": "https://codeforces.com/blog/entry/147174"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Place the batteries in order on a circumference.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "If there are $$$a$$$ working batteries, can we bound the distance between some pair of them in terms of $$$n$$$ and $$$a$$$?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Arrange the batteries in clockwise order on a circumference such that the arc length between any two consecutive batteries is $$$1$$$, and let the indices of the working batteries be $$$1 \\le b_1 < b_2 < \\dots < b_a \\le n$$$. Let the distance between two working batteries $$$b_i$$$ and $$$b_{i+1}$$$ be $$$b_j-b_i$$$ if $$$i < a$$$ and $$$b_1+n-b_a$$$ if $$$i = a$$$. Note that this matches the length of a circle arc between $$$b_i$$$ and $$$b_{i+1}$$$ that doesn't contain any other working battery. Observe that the sum of the distances between $$$b_i$$$ and $$$b_{i+1}$$$ for $$$1 \\le i \\le a$$$ (indices taken $$$\\bmod a$$$) is exactly $$$n$$$, since the corresponding circle arcs make up the entire circumference. Since there are $$$a$$$ pairs of working batteries, by Pigeonhole Principle there is some distance that is less than or equal to $$$\\left \\lfloor \\frac{n}{a} \\right \\rfloor$$$Consequently, the following strategy works: For every $$$i$$$ from $$$1$$$ to $$$\\left \\lfloor \\frac{n}{a} \\right \\rfloor$$$, and for every $$$j$$$ from $$$1$$$ to $$$n$$$, query batteries $$$j$$$ and $$$j+i \\bmod n$$$ (if $$$j+i = 0$$$, query with battery $$$n$$$) which is equivalent to querying battery $$$j$$$ and the one $$$i$$$ positions ahead clockwise. The above takes at most  $$$n \\times \\left \\lfloor \\frac{n}{a} \\right \\rfloor \\le \\left \\lfloor \\frac{n^2}{a} \\right \\rfloor$$$trials, as desired.",
        "codes": []
      },
      {
        "title": "code",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid main_() {\n    \n    int n, x;\n\tcin >> n;\n\t\n\tfor (int i = 1; i < n; i++)\n\t    for (int j = 1; j <= n; j++) {\n\t\t    \n                x = (i+j)%n;\n                \n                if(x == 0) {\n                    x = n;\n                }\n                \n                cout << j << \" \" << x << endl;\n                \n                int res;\n                cin >> res;\n                \n                if (res) {\n                    return;\n                }\n        }\n}\n\nint main() {\n\t\n\tint t = 1;\n\tcin >> t;\n\twhile (t--)\n\t\tmain_();\n\t\n\treturn 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid main_() {\n    \n    int n, x;\n\tcin >> n;\n\t\n\tfor (int i = 1; i < n; i++)\n\t    for (int j = 1; j <= n; j++) {\n\t\t    \n                x = (i+j)%n;\n                \n                if(x == 0) {\n                    x = n;\n                }\n                \n                cout << j << \" \" << x << endl;\n                \n                int res;\n                cin >> res;\n                \n                if (res) {\n                    return;\n                }\n        }\n}\n\nint main() {\n\t\n\tint t = 1;\n\tcin >> t;\n\twhile (t--)\n\t\tmain_();\n\t\n\treturn 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2155E": {
    "contest_title": "Codeforces Round 1056 (Div. 2)",
    "problem_id": "2155E",
    "problem_title": "E. Mimo & Yuyu",
    "time_limit": "2 seconds",
    "memory_limit": "256 megabytes",
    "statement": "Mimo and Yuyu just finished their 1000-piece jigsaw puzzle of beautiful Bellas Artes! Now they are looking for other ways to entertain themselves.There is an $$$n \\times m$$$ grid of cells with columns labeled $$$1, 2, \\ldots m$$$ from left to right and rows labeled $$$1, 2, \\ldots n$$$ from top to bottom. Let $$$(u, v)$$$ ($$$1 \\le u \\le n, 1 \\le v \\le m$$$) denote the cell in the $$$u$$$-th row and $$$v$$$-th column. Each cell can contain any number of tokens which are indistinguishable among themselves. Initially, there are $$$k$$$ tokens, the $$$i$$$-th of which is located in $$$(x_i, y_i)$$$.Mimo and Yuyu now play a game alternating turns. On his/her turn, a player chooses a token $$$c$$$ currently in the grid as well as a sequence ofdistinctcells $$$(a_1, b_1), (a_2, b_2), \\ldots (a_p, b_p)$$$ ($$$p \\ge 2$$$) such that the following conditions hold:$$$c$$$ is located in $$$(a_1, b_1)$$$For all $$$i$$$ ($$$1 \\le i < p$$$), $$$\\left|a_{i+1} - a_i\\right|+\\left|b_{i+1} - b_i\\right| = 1$$$. That is, adjacent cells in the sequence must be adjacent in the grid.$$$b_1 \\ge b_2 \\ge \\ldots \\ge b_p$$$. That is, thecolumnsof the cells of the sequence must form anon-increasingsequence (never stepping away from column $$$1$$$).$$$b_p = 1$$$. That is, the last cell of the sequence must lie in column $$$1$$$.$$$b_1 > b_2$$$. In particular, $$$b_2 = b_1-1$$$. That is, $$$(a_1, b_1)$$$ must be the only cell of the sequence lying in column $$$b_1$$$.Then, he/she removes $$$c$$$ from the grid and adds 1 token to $$$(a_2, b_2), (a_3, b_3), \\ldots (a_p, b_p)$$$ each. This concludes his/her turn.The player who cannot make a turn loses. Mimo goes first. Determine who will win if both players play optimally.For example, consider a game where $$$n=6$$$, $$$m=4$$$, and 3 tokens currently exist in $$$(2, 3)$$$, $$$(4, 2)$$$, and $$$(6, 4)$$$ (as shown in Figure 1). In this scenario, a valid turn, for instance, could consist of choosing $$$c$$$ as the token in $$$(6, 4)$$$ and the sequence of cells with $$$p=10$$$ defined by $$$a=[6,6,5,4,3,2,2,3,4,4]$$$ and $$$b=[4,3,3,3,3,3,2,2,2,1]$$$. Note that $$$(a_i, b_i)$$$ describes valid cells in the grid.For the sake of clarity, a dashed line is shown in Figure 2 passing through this particular choice of $$$(a_1, b_1), (a_2, b_2), \\ldots (a_p, b_p)$$$ in order. Figure 3 and 4 show the state of the game after the turn is performed, with and without the highlighted sequence respectively.Figure 1Figure 2Figure 3Figure 4Note that the first and seventh test case in the example correspond to the games shown in Figure 1 and Figure 4 respectively.\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10^4$$$). The description of the test cases follows.The first line of each test case contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \\le n, m, k \\le 2 \\cdot 10^5$$$).The $$$i$$$-th of the next $$$k$$$ lines contains two integers $$$x_i$$$ and $$$y_i$$$ ($$$1 \\le x_i \\le n, 1 \\le y_i \\le m$$$).It is guaranteed that the sum of $$$k$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.Note that there is no explicit upper bound on the sum of $$$n$$$ and $$$m$$$.\n\nOutputFor each test case, outputMimoif Mimo wins, orYuyuif Yuyu wins.You can output the answer in any case (upper or lower). For example, the stringsmIMo,mimo,Mimo, andMIMOwill be recognized as responses indicating that the first player wins.",
    "sample_inputs": [
      "76 4 32 34 26 41 1 11 13 2 41 11 22 23 220 4 310 420 21 31 5 11 32 3 52 11 21 22 31 36 4 116 35 34 33 32 32 32 23 24 24 24 1"
    ],
    "sample_outputs": [
      "MimoYuyuMimoMimoYuyuYuyuYuyu"
    ],
    "notes": "NoteIn the second test case, Mimo cannot make any moves, so Yuyu wins.In the third test case, the token in $$$(1, 1)$$$ cannot be used as $$$c$$$ for any turn because there is no sequence of cells that begins with $$$(1, 1)$$$ and satisfies $$$b_1 > b_2$$$, so the game might unfold as follows:Mimo removes the token in $$$(1, 2)$$$ and adds a token to $$$(1, 1)$$$.Yuyu removes the token in $$$(2, 2)$$$ and adds a token to $$$(2, 1)$$$.Mimo removes the token in $$$(3, 2)$$$ and adds a token to $$$(3, 1)$$$.It can be shown that Yuyu could not have played more optimally, so Mimo wins.",
    "tags": [
      "games",
      "greedy",
      "math"
    ],
    "url": "https://codeforces.com/problemset/problem/2155/E",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1056 (Div. 2) Editorial",
          "url": "/blog/entry/147174",
          "full_url": "https://codeforces.com/blog/entry/147174"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "When $$$n = 1$$$, the total number of turns is fixed.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "When $$$n = 2$$$, the winning and losing states depend only on the parity of the amount of tokens in each column.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "For convenience, let's denote with $$$d_i$$$ the number of tokens located in column $$$i$$$.It's worth noting that the game lasts a finite amount of turns because, the array $$$[ d_m, d_{m-1}, \\dots d_1 ]$$$ becomes lexicographically smaller (strictly) after each turn.Note that we can think of each token independently, as tokens are only removed one at a time by the players.We first deal with the case $$$n = 1$$$. Let $$$c_i$$$ be the column where token $$$i$$$ is located. We will prove by induction that token $$$i$$$ contributes $$$2^{c_i-2}$$$ turns to the game whenever $$$c_i \\ge 2$$$. That is, $$$2^{c_i-2}$$$ turns are necessary and sufficient to remove token $$$i$$$ and all the tokens it spawns from the board. Base case $$$c_i = 2$$$: A player moves token $$$i$$$ to column $$$1$$$. No tokens are added to the board, so $$$1 = 2^0$$$ turns are played in total.Otherwise, $$$c_i-2$$$ tokens will be added to the board after choosing token $$$i$$$, one in each of columns $$$2, 3, \\dots {c_i-1}$$$. By the induction hypothesis, removing these tokens and all the tokens they spawn will take  $$$ \\sum_{j=2}^{c_i-1} 2^{j-2} = 2^0+2^1+\\dots+2^{i-3} = 2^{c_i-2}-1$$$turns. Adding the initial turn to the total, we get $$$2^{c_i-2}-1+1 = 2^{c_i-2}$$$ turns in total. The answer is equivalent to the parity of the number of turns performed in total, obtained by summing the contribution of turns by each token. Only tokens in column $$$2$$$ contribute an odd amount of turns ($$$2^0 = 1$$$ turn) while every other token contributes an even amount of turns ($$$0$$$ or $$$2^{j-2}$$$ turns), so we just need to print $$$\\texttt{Mimo}$$$ if there is an odd number of tokens on column $$$2$$$ or $$$\\texttt{Yuyu}$$$ if there is an even amount. The only other case is when $$$n \\ge 2$$$. We claim that the second player wins if and only if, for all $$$i \\ge 2$$$, $$$d_i \\equiv 0 \\; \\bmod 2$$$  If $$$d_i = 0$$$ for all $$$i \\ge 2$$$: The game is automatically a losing state. $$$d_i \\equiv 0 \\; \\bmod 2$$$ for all $$$i \\ge 2$$$ turns out to also be a losing state. Any move would cause some $$$d_j$$$ (in particular, $$$j = b_1$$$) to go from even to odd; thus, the opponent is given a winning game, as we will prove below. We claim that $$$d_j \\equiv 1 \\; \\bmod 2$$$ for some $$$j \\ge 2$$$ is a winning state. Denote the maximum of all such $$$j$$$ as $$$j_{max}$$$. Our objective will be to give the opponent a game which falls under the first or second bullet point ($$$d_i \\equiv 0 \\; \\bmod 2$$$ for all $$$i \\ge 2$$$). If such a thing is always possible, after a finite amount of moves, the state given to the opponent will necessarily be exactly that of the first bullet point (the \"minimal\" losing state), proving these states are winning.By definition of $$$j_{max}$$$, $$$d_i \\equiv 0 \\; \\bmod 2$$$ for all ($$$i > j_{max}$$$). Performing a turn with chosen token $$$c$$$ in column $$$j_{max}$$$ causes $$$d_{j_{max}}$$$ to become $$$0 \\bmod 2$$$. For all columns $$$i$$$ ($$$i < j_{max}$$$) a move that achieves $$$d_i \\equiv 0 \\; \\bmod 2$$$ is as follows:  If $$$d_i \\equiv 0 \\; \\bmod 2$$$: Make sure $$$2$$$ tokens are added to column $$$i$$$. If $$$d_i \\equiv 1 \\; \\bmod 2$$$: Make sure $$$1$$$ token is added to column $$$i$$$. Such a move is possible because $$$n \\ge 2$$$. This is an example of how it could look like:Time complexity: $$$\\mathcal{O}(k)$$$ or $$$\\mathcal{O}(k\\log m)$$$ depending on implementation.",
        "codes": []
      },
      {
        "title": "code",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector <ll>;\n \nvoid tc () {\n    ll n, m, k;\n    cin >> n >> m >> k;\n    set <ll> st;\n    for (ll id = 0; id < k; id++) {\n        ll i, j;\n        cin >> i >> j;\n        if (j == 1) continue;\n        if (n == 1 && j != 2) continue;\n        if (st.count(j))\n            st.erase(j);\n        else\n            st.insert(j);\n    }\n    cout << (st.size() > 0 ? \"Mimo\" : \"Yuyu\") << '\\n';\n}\n \nint main () {\n    cin.tie(nullptr) -> sync_with_stdio(false);\n    ll T; cin >> T; while (T--) { tc(); }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector <ll>;\n \nvoid tc () {\n    ll n, m, k;\n    cin >> n >> m >> k;\n    set <ll> st;\n    for (ll id = 0; id < k; id++) {\n        ll i, j;\n        cin >> i >> j;\n        if (j == 1) continue;\n        if (n == 1 && j != 2) continue;\n        if (st.count(j))\n            st.erase(j);\n        else\n            st.insert(j);\n    }\n    cout << (st.size() > 0 ? \"Mimo\" : \"Yuyu\") << '\\n';\n}\n \nint main () {\n    cin.tie(nullptr) -> sync_with_stdio(false);\n    ll T; cin >> T; while (T--) { tc(); }\n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2155F": {
    "contest_title": "Codeforces Round 1056 (Div. 2)",
    "problem_id": "2155F",
    "problem_title": "2155F - Juan's Colorful Tree",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1056 (Div. 2) Editorial",
          "url": "/blog/entry/147174",
          "full_url": "https://codeforces.com/blog/entry/147174"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Consider the graph formed by the vertices with color $$$x$$$ and the edges between them. What happens if a query contains two vertices in the one of this graph's connected components (\"color components\")?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "After assigning IDs to each \"color component\" (for all colors), we can calculate the answer for two vertices by counting the number of components which contain both of them.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "We can precompute the answer for all possible queries containing vertex $$$x$$$ with DFS.",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "Determining all answers with only one of the two aforementioned methods is very expensive. Is there some way to balance the complexity by using one over the other in certain situations?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "There are some solutions with square-root complexity with an additional log factor that can pass if optimized enough, but we will present an $$$\\mathcal{O}((n+q+s)\\sqrt s)$$$ solution. Let's first transform the problem from calculating the intersection of $$$C_w$$$ for all nodes $$$w$$$ in the path from $$$a_i$$$ to $$$b_i$$$ ($$$\\left| C_{a_i} \\cap \\dots \\cap C_{b_i} \\right|$$$) to calculating the intersection of 2 sets: $$$D_{a_i}$$$ and $$$D_{b_i}$$$. We will calculate $$$\\left|D_{a_i} \\cap D_{b_i}\\right|$$$ in average square-root complexity, using the best of 2 algorithms for each type of query.First, let's define the sets $$$D_1, D_2, \\dots D_n$$$. Let a maximal color component be a set of vertices, all of which contain some color $$$x$$$ in their sets, such that there is no other vertex with color $$$x$$$ adjacent to some vertex of the maximal component. We will assign an arbitrary ID to each maximal color component, and $$$D_u$$$ will contain the IDs of the maximal color components which node $$$u$$$ belongs to. Note that $$$\\left| D_u \\right| = \\left| C_u \\right|$$$. Also note that the answer now is simply $$$\\left|D_{a_i} \\cap D_{b_i}\\right|$$$. A possible $$$\\mathcal{O}\\left(n+s+k\\right)$$$ algorithm calculating the sets $$$D_i$$$ is to maintain $$$k$$$ stacks while doing a DFS where, when visiting node $$$u$$$, stack $$$c$$$ contains the ancestors of node $$$u$$$ with color $$$c$$$. Checking the top of the stack suffices to know if a new component is created, or inherited from one's parent.Here are 2 algorithms which calculate the cardinality of the intersection: One answers a query for a given pair of nodes $$$a_i$$$, $$$b_i$$$ and runs in $$$\\mathcal{O}\\left( |D_{a_i}|+|D_{b_i}| \\right)$$$. The other calculates the answer between a fixed node $$$u$$$ and all $$$n$$$ nodes in $$$\\mathcal{O}\\left( n+s \\right)$$$.The first algorithm relies on sorting the sets $$$D_u$$$ (stored in lists or arrays), and then using the two-pointers technique to calculate the intersection of two sorted arrays in linear time. The second algorithm roots the tree in $$$u$$$ and starts a DFS, where the frequency of all $$$k$$$ colors across ancestors is maintained. For every node $$$v$$$, it calculates if the frequency of every color in $$$C_v$$$ is equal to its depth.Let $$$B$$$ be a fixed integer. We precompute answers when $$$|D_u| \\ge B$$$ using the $$$\\mathcal{O}\\left( n+s \\right)$$$ algorithm. Otherwise, we use the $$$\\mathcal{O}\\left( |D_{a_i}|+|D_{b_i}| \\right)$$$ algorithm for queries in which $$$|D_{a_i}|, |D_{b_i}| \\le B$$$. The complexity of this approach is $$$\\mathcal{O}\\left( qB + (s/B)(n+s) \\right)$$$ because there are at most $$$s/B$$$ vertices whose sets have a cardinality greater than $$$B$$$. Setting $$$B$$$ to be around $$$\\sqrt s$$$, we get that our procedure runs in $$$\\mathcal{O}\\left(q\\sqrt s + \\sqrt s (n+s) \\right) = \\mathcal{O}\\left( (n+q+s)\\sqrt s \\right)$$$. Time complexity: $$$\\mathcal{O}\\left( (n+q+s)\\sqrt s \\right)$$$Memory complexity: $$$\\mathcal{O}\\left( s + n\\sqrt s \\right)$$$",
        "codes": []
      },
      {
        "title": "code",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector <ll>;\n \nconst ll MAXN = 3E5+16, B = 800;\nvll adj[MAXN];\nvll cols[MAXN], comps[MAXN];\nll comp_col[MAXN];\nll timer = 1, cur = 1;\nll last[MAXN];\nbool active[MAXN];\nll curMap[MAXN];\nint preProc[MAXN/B+16][MAXN];\n \nvoid dfs1 (ll u, ll par) {\n    vll th(cols[u].size()), th2(cols[u].size());\n    comps[u].resize(cols[u].size());\n    for (ll i = 0; i < cols[u].size(); i++) {\n        ll c = cols[u][i];\n        th[i] = last[c];\n        th2[i] = comp_col[c];\n        comp_col[c] = (last[c] == par ? comp_col[c] : timer++);\n        comps[u][i] = comp_col[c];\n        last[c] = u;\n    }\n    for (ll v : adj[u]) {\n        if (v == par) continue;\n        dfs1(v, u);\n    }\n    for (ll i = 0; i < cols[u].size(); i++) {\n        ll c = cols[u][i];\n        last[c] = th[i];\n        comp_col[c] = th2[i];\n    }\n}\n \nvoid tc () {\n    ll n, k, s, q;\n    cin >> n >> k >> s >> q;\n    fill(adj, adj+n, vll({}));\n    for (ll i = 1; i < n; i++) {\n        ll u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    timer = 1;\n    cur = 1;\n    fill(cols, cols+n, vll({}));\n    fill(comps, comps+n, vll({}));\n    fill(comp_col, comp_col+k, -16);\n    fill(last, last+k, -16);\n    for (ll i = 0; i < s; i++) {\n        ll x, c;\n        cin >> x >> c;\n        x--; c--;\n        cols[x].push_back(c);\n    }\n    dfs1(0, 0);\n    for (ll u = 0; u < n; u++) {\n        sort(comps[u].begin(), comps[u].end());\n    }\n    for (ll u = 0; u < n; u++) {\n        if (cols[u].size() < B) continue;\n        // >= B\n        for (ll c : comps[u]) active[c] = true;\n        for (ll v = 0; v < n; v++) {\n            preProc[cur][v] = 0;\n            for (ll c : comps[v]) {\n                preProc[cur][v] += active[c];\n            }\n        }\n        for (ll c : comps[u]) active[c] = false;\n        curMap[u] = cur++;\n    }\n    while (q--) {\n        ll u, v;\n        cin >> u >> v;\n        u--; v--;\n        if (cols[u].size() >= B) {\n            cout << preProc[curMap[u]][v] << ' ';\n            continue;\n        }\n        if (cols[v].size() >= B) {\n            cout << preProc[curMap[v]][u] << ' ';\n            continue;\n        }\n        ll ans = 0;\n        ll p1 = 0;\n        for (ll p2 = 0; p2 < comps[v].size(); p2++) {\n            while (p1 < comps[u].size() && comps[u][p1] < comps[v][p2]) p1++;\n            if (p1 == comps[u].size() || comps[u][p1] != comps[v][p2]) continue;\n            ans++;\n        }\n        cout << ans << ' ';\n    }\n    cout << '\\n';\n}\n \nint main () {\n    cin.tie(nullptr) -> sync_with_stdio(false);\n    ll T; cin >> T; while (T--) { tc(); }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector <ll>;\n \nconst ll MAXN = 3E5+16, B = 800;\nvll adj[MAXN];\nvll cols[MAXN], comps[MAXN];\nll comp_col[MAXN];\nll timer = 1, cur = 1;\nll last[MAXN];\nbool active[MAXN];\nll curMap[MAXN];\nint preProc[MAXN/B+16][MAXN];\n \nvoid dfs1 (ll u, ll par) {\n    vll th(cols[u].size()), th2(cols[u].size());\n    comps[u].resize(cols[u].size());\n    for (ll i = 0; i < cols[u].size(); i++) {\n        ll c = cols[u][i];\n        th[i] = last[c];\n        th2[i] = comp_col[c];\n        comp_col[c] = (last[c] == par ? comp_col[c] : timer++);\n        comps[u][i] = comp_col[c];\n        last[c] = u;\n    }\n    for (ll v : adj[u]) {\n        if (v == par) continue;\n        dfs1(v, u);\n    }\n    for (ll i = 0; i < cols[u].size(); i++) {\n        ll c = cols[u][i];\n        last[c] = th[i];\n        comp_col[c] = th2[i];\n    }\n}\n \nvoid tc () {\n    ll n, k, s, q;\n    cin >> n >> k >> s >> q;\n    fill(adj, adj+n, vll({}));\n    for (ll i = 1; i < n; i++) {\n        ll u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    timer = 1;\n    cur = 1;\n    fill(cols, cols+n, vll({}));\n    fill(comps, comps+n, vll({}));\n    fill(comp_col, comp_col+k, -16);\n    fill(last, last+k, -16);\n    for (ll i = 0; i < s; i++) {\n        ll x, c;\n        cin >> x >> c;\n        x--; c--;\n        cols[x].push_back(c);\n    }\n    dfs1(0, 0);\n    for (ll u = 0; u < n; u++) {\n        sort(comps[u].begin(), comps[u].end());\n    }\n    for (ll u = 0; u < n; u++) {\n        if (cols[u].size() < B) continue;\n        // >= B\n        for (ll c : comps[u]) active[c] = true;\n        for (ll v = 0; v < n; v++) {\n            preProc[cur][v] = 0;\n            for (ll c : comps[v]) {\n                preProc[cur][v] += active[c];\n            }\n        }\n        for (ll c : comps[u]) active[c] = false;\n        curMap[u] = cur++;\n    }\n    while (q--) {\n        ll u, v;\n        cin >> u >> v;\n        u--; v--;\n        if (cols[u].size() >= B) {\n            cout << preProc[curMap[u]][v] << ' ';\n            continue;\n        }\n        if (cols[v].size() >= B) {\n            cout << preProc[curMap[v]][u] << ' ';\n            continue;\n        }\n        ll ans = 0;\n        ll p1 = 0;\n        for (ll p2 = 0; p2 < comps[v].size(); p2++) {\n            while (p1 < comps[u].size() && comps[u][p1] < comps[v][p2]) p1++;\n            if (p1 == comps[u].size() || comps[u][p1] != comps[v][p2]) continue;\n            ans++;\n        }\n        cout << ans << ' ';\n    }\n    cout << '\\n';\n}\n \nint main () {\n    cin.tie(nullptr) -> sync_with_stdio(false);\n    ll T; cin >> T; while (T--) { tc(); }\n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": []
  }
}