{
  "2128A": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128A",
    "problem_title": "2128A - Центр переработки",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's say a bag is expensive if $$$a_i > c$$$ and free if $$$a_i \\leq c$$$.First, observe that as long as there is at least one free bag remaining, we should destroy a free bag. We will perform all expensive destructions at the end. The goal is to perform as much free destructions as possible.When there are multiple free bags, which one to choose? The bigger a bag is, the less time you have to destroy it before it becomes expensive. Hence, at each second, you should destroy the biggest remaining free bag.This process can be naively simulated in $$$\\mathcal{O}(n^2)$$$, which was sufficient under given constraints. If you sort the array beforehand and keep the current multiplier in a separate variable (instead of multiplying all weights), it can be done in $$$\\mathcal{O}(n \\log n)$$$ time.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199790",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n\n\n\n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128B": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128B",
    "problem_title": "2128B - Процесс на Деке",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Instead of taking either the leftmost or rightmost element, think about taking either the minimum or maximum element.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "It's possible to ensure that $$$q_1 < q_2 > q_3 < q_4 > q_5 \\ldots$$$",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's number turns from $$$1$$$ to $$$n$$$. On odd turns, we take the minimum element and on even turns, we take the maximum element. We claim that $$$q_1 < q_2 > q_3 < q_4 > q_5 \\ldots$$$ (which is actually stronger than what the statement asked).Proof: consider taking the minimum on an odd turn : $$$q_i = \\min(p_l, p_r)$$$ where $$$l, r$$$ were the endpoints of the remaining array at turn $$$i$$$. Suppose without loss of generality the minimum was on the left, i.e. $$$q_i = p_l < p_r$$$. Then at the next turn, $$$p_r$$$ is still available:  $$$q_{i+1} = \\max(p_{l+1}, p_r) \\geq p_r > p_l = q_i$$$For example, if the remaining array at an odd turn is $$$[5, ?, \\ldots, 10]$$$, we take the minimum $$$5$$$, and then no matter what the $$$?$$$ is, we take at least $$$10$$$ which is greater than $$$5$$$. This proves $$$q_i < q_{i+1}$$$ when $$$i$$$ is odd. Similarly, we can prove $$$q_i > q_{i+1}$$$ when $$$i$$$ is even.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199677",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128C": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128C",
    "problem_title": "2128C - Самый левый меньший",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "Try to come up with a sufficient condition first, then prove it's necessary. Doing some examples with $$$n = 3$$$ might be useful.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let $$$m_i = \\min(b_1, \\ldots, b_{i-1})$$$ for every $$$2 \\leq i \\leq n$$$, which can be computed in linear time. We claim we can achieve $$$a = b$$$ if and only if $$$b_i - m_i < m_i$$$ for every $$$2 \\leq i \\leq n$$$.Proof that it's sufficient: we can build the array from left to right. For every $$$i$$$, if $$$b_i < m_i$$$ then we directly add $$$b_i$$$. Otherwise, we first add $$$b_i - m_i$$$, then $$$m_i$$$.Proof that it's necessary: suppose we managed to reach $$$b$$$. At every step, $$$a_i \\leq b_i$$$ for every $$$i$$$. Consider the last operation $$$x$$$ that incremented $$$a_i$$$. Then, by the definition of $$$i$$$, we must have  $$$a_i < x \\leq \\min(a_1, \\ldots, a_{i-1}) \\leq \\min(b_1, \\ldots, b_{i-1}).$$$Hence, $$$b_i = a_i + x \\leq 2x-1 \\leq 2m_i - 1$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199604",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128E1": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128E1",
    "problem_title": "2128E1 - Подмедианы (легкая версия)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "You can use binary search on the answer. Why ?",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "Let's start with a, perhaps, more natural task: finding whether or not $$$v$$$ is a submedian. To do so, we create an array $$$\\text{big}$$$ such that $$$\\text{big}[i] = 1 \\text{ if } \\text{a}[i] \\geq v \\text{ else } -1$$$We also create an array $$$\\text{small}$$$ such that $$$\\text{small}[i] = 1 \\text{ if } \\text{a}[i] \\leq v \\text{ else } -1$$$Knowing whether v is a submedian or not requires using both $$$\\mathrm{big}$$$ and $$$\\mathrm{small}$$$ ; when you want to know if the largest submedian is larger than or equal to v, do you actually need both arrays?",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Solve the relaxed problem where we only consider the first three constraints (and neglect the constraint on $$$\\mathrm{small}$$$) i.e finding the largest $$$v$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$",
        "codes": []
      },
      {
        "title": "hint4",
        "text": "Use binary search and prefix sums to rewrite the constraint on $$$\\text{big}$$$",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "Is the resulting value a submedian ?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "First, note that the predicate ``there exists a submedian $$$\\geq v$$$'' is monotonic. That is, if there exists a submedian $$$\\geq v$$$, then for all $$$v' < v$$$, there exists a submedian $$$\\geq v$$$. Thus, we can binary search to find the largest $$$v$$$ such that there exists a submedian $$$\\geq v$$$. Such a $$$v$$$ will be the largest submedian.Now, what is left is to check is, for a fixed $$$v$$$, whether or not there exists a submedian $$$\\geq v$$$. Let's start with a, perhaps, more natural task: finding whether or not $$$v$$$ is a submedian. To do so, we create an array $$$\\text{big}$$$ such that $$$\\text{big}[i] = 1 \\text{ if } \\text{a}[i] \\geq v \\text{ else } -1$$$We also create an array $$$\\text{small}$$$ such that $$$\\text{small}[i] = 1 \\text{ if } \\text{a}[i] \\leq v \\text{ else } -1$$$Using these notations, $$$v$$$ is a submedian iff there exists $$$(l, r)$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ $$$\\text{small}[l] + \\dots + \\text{small}[r] \\geq 0$$$ Let's try to solve a relaxed problem where we only consider the first three constraints (and neglect the constraint on $$$\\text{small}$$$ i.e finding the largest $$$v$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ Such a problem is standard and can be easily solved in $$$\\mathcal{O}(n \\log n)$$$ by binary search and prefix sums. Indeed, for a fixed $$$v$$$, we can iterate over the value of $$$r$$$. Now: $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ iff $$$\\text{pref}[r] - \\text{pref}[l-1] \\geq 0$$$ i.e $$$\\text{pref}[r] \\geq \\text{pref}[l-1]$$$ so taking $$$l$$$ that minimizes $$$\\text{pref}[l-1]$$$ is optimal. Thus, it is enough to maintain such an $$$l$$$ in constant time (when you increase $$$r$$$, there is only one new candidate for $$$l$$$).Now, I claim that the value of $$$v$$$ we get happens to be the largest submedian. Indeed, if it doesn't satisfy $$$\\text{small}[l] + \\dots + \\text{small}[r] \\geq 0$$$, then $$$v + 1$$$ would still satisfy $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ which contradicts the maximality of $$$v$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199376",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128E2": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128E2",
    "problem_title": "2128E2 - Подмедианы (сложная версия)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "The set of submedians is a range. Try to prove it.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "For $$$l_1 \\leq r_1$$$ and $$$l_2, r_2$$$ such that $$$|l_1 - l_2| + |r_1 - r_2| \\leq 1$$$, both subarrays share at least one median. How to prove it ? Knowing this fact, how to prove Hint 1 ?",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Find a discretely ``continuous'' path from the subarray of the minimum submedian, to the subarray of the maximum submedian",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Read the editorial of E1 first.In such problems, it can be useful to try an easier version, for example, finding maximal/minimal values (which is why the subtask is helpful).Now, one can observe that if $$$x \\leq y$$$ are submedians, then any $$$z$$$ such that $$$x \\leq z \\leq y$$$ is also a submedian ! One can prove this using the intermediate value theorem. Let's fix $$$x \\leq z \\leq y$$$ and $$$[l_1, r_1]$$$ (resp. $$$[l_2, r_2]$$$) be a range where $$$x$$$ (resp. $$$y$$$) is a submedian. wlog, assume $$$l_1 < l_2$$$. Start by sweeping $$$r_1$$$ to $$$l_2$$$. Then $$$r_1$$$ to $$$r_2$$$. And finally, $$$l_1$$$ to $$$l_2$$$. Then one of the ranges that we covered has submedian $$$z$$$. Intuitively, when incrementing one of the ends of a range, the +1/-1 in the arrays big and small are not changing that much (the norm 1 distance is bounded by 2) so we can think of using the intermediate value theorem (see proof below). Also, note that at any time, the covered range is of length at least $$$k$$$.Thus, it is enough to find the smallest and largest submedians (using the solution of E1) and maintain the set of submedians while sweeping. One way to do that is to use a fenwick tree to simulate an ordered set (or you can also use two range sum point update queries to simulate the \\text{big} and \\text{small} arrays). Alternatively, you can use two sets (one with the lower half of the values of the current range, and one with the upper half). For each $$$[l, r]$$$ that our algorithm covers, we consider the point $$$(|{i \\in [l,r] \\mid a[i] \\geq z}| - |{i \\in [l,r] \\mid a[i] < z}|, |{i \\in [l,r] \\mid a[i] \\leq z}| - |{i \\in [l,r] \\mid a[i] > z}|)$$$ where $$$|A|$$$ is the cardinal of set $$$A$$$. Essentially, you can think of this point as an encoding of both conditions on small and big for $$$z$$$ to be a submedian.Note that, when moving one end of the range, each coordinate of the point changes by at most 1 (in absolute value). Also note that, by a simple computation, the sum of both coordinates is positive (it is equal to twice the number of $$$i$$$ such that $$$a[i] = z$$$).I claim that one of these points will have positive coordinates (thus, $$$z$$$ will be a submedian). Indeed: our path starts at a point with (negative first coordinate, positive second coordinate) and ends at a point with (positive first coordinate, negative second coordinate). Each move allows moving to a point at distance at most 2. However, you can see on the drawing below that one must pass through points with positive coordinates to achieve this (otherwise, you would be stuck in (negative first coordinate, positive second coordinate)).In red, the area with points such that $$$x+y \\geq 0$$$, below the green line are forbidden points. The blue points are our starting and ending points. Finally, the arrows are the possible moves after incrementing/decrementing one end of the range.",
        "codes": []
      },
      {
        "title": "code",
        "text": "Fenwick tree solution: 331199080 Two sets solution: 331198693",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128F": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128F",
    "problem_title": "2128F - Строгий треугольник",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Hint1aSay an edge is green if its weight is $$$l_i$$$ and red if its weight is $$$r_i$$$. If the answer is YES, prove there exists a solution that colors a path from $$$1$$$ to $$$n$$$ in green and the rest of the edges in red. Hint1bConsider an arbitrary solution $$$w$$$ and let $$$P$$$ be the shortest path from $$$1$$$ to $$$n$$$ with respect to $$$w$$$. Decreasing the weight of an edge in $$$P$$$ will decrease $$$d(1, n)$$$ by exactly one and will decrease $$$d(1, k) + d(k, n)$$$ by at most one. Increasing the weight of an edge outside $$$P$$$ will not increase $$$d(1, n)$$$ and will not decrease $$$d(1, k) + d(k, n)$$$. By repeating these operations, we can make $$$P$$$ green and the rest red.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "Hint2aLet $$$P$$$ be the chosen green path. Find a necessary condition for the corresponding weight assignment to be correct. Then, prove if it's sufficient. Hint2bThe condition is $$$d_L(u, v) < d_R(u, k) + d_R(k, v)$$$ for all $$$u, v \\in P$$$. Hint2cIt's obviously necessary; otherwise, $$$1 \\rightarrow_L u \\rightarrow_R k \\rightarrow_R v \\rightarrow_L n$$$ would have length $$$d(1, n)$$$. Conversely, if there exists a $$$1-n$$$ shortest path going through $$$k$$$, if you consider the last node in $$$P$$$ you visited before reaching $$$k$$$ and the first node in $$$P$$$ you visited after reaching $$$k$$$, this pair of nodes will violate the condition.",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Try to build a correct path using a Dijkstra-like algorithm. It might be helpful to have an intuitive understanding of the condition found in the previous hint in order to quantify with a single integer how good the current path is. Imagine you're a robber going from $$$1$$$ to $$$n$$$ and you don't want to be caught by cops.",
        "codes": []
      },
      {
        "title": "hint4",
        "text": "Imagine nodes are cities, $$$k$$$ is a police station, and you're some robber. Traversing the $$$i$$$-th edge takes $$$l_i$$$ seconds for the robber, and $$$r_i$$$ seconds for the citizens and the cops.Each time you go through a city, the citizens of this city will run to the police station to warn the cops. Once the cops are warned, they start dispatching in all directions as fast as they can to catch up to you.",
        "codes": []
      },
      {
        "title": "hint5",
        "text": "The current danger can be represented by an integer timer $$$x$$$. If $$$x < 0$$$, it means the cops will be warned in $$$-x$$$ seconds. If $$$x \\geq 0$$$, it means the cops have been warned since $$$0$$$ seconds. It's the only information you need to remember.",
        "codes": []
      },
      {
        "title": "hint6",
        "text": "Try to find for each node $$$u$$$ what is the corresponding minimum timer $$$t_u$$$. As the robber runs through the graph, the timer always increases, so you can do this with Dijkstra.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Please read all the hints first.We first make a classical Dijkstra from $$$k$$$ with $$$r$$$-weighted edges. Let $$$d_u$$$ be the distance between $$$u$$$ and $$$k$$$ for citizens/cops.We then make a modified Dijkstra, starting from the situation $$$(1, t_1)$$$ with $$$t_1 = -d_1$$$ (meaning the cops will be warned in $$$d_1$$$ seconds).When you traverse the $$$i$$$-th edge to go from $$$(u, t)$$$ to $$$v$$$, the new timer will be  $$$t' = \\max(t + l_i, -d_v).$$$We have $$$t' \\geq t+l_i$$$ because the previous timer continued to advance while the robber was traversing the edge, and $$$t' \\geq -d_v$$$ because a new citizen started running from $$$v$$$ to the police station.Each time, we take the situation with the minimum timer from the priority queue. If the node has already been processed, or if $$$d_u \\leq t_u$$$ (meaning the cops can catch up to the robber in $$$v$$$), the situation is skipped. The answer is YES if and only if we processed the node $$$n$$$.The time complexity is $$$\\mathcal{O}((n + m) \\log (n+m))$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331198575",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128D": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128D",
    "problem_title": "D. Sum of LDS",
    "time_limit": "2 seconds",
    "memory_limit": "256 megabytes",
    "statement": "You're given a permutation$$$^{\\text{∗}}$$$ $$$p_1, \\ldots, p_n$$$ such that $$$\\max(p_i, p_{i+1}) > p_{i+2}$$$ for all $$$1 \\leq i \\leq n-2$$$.Compute the sum of the length of the longest decreasing subsequence$$$^{\\text{†}}$$$ of the subarray $$$[p_l, p_{l+1}, \\ldots, p_r]$$$ over all pairs $$$1 \\leq l \\leq r \\leq n$$$.$$$^{\\text{∗}}$$$A permutation of length $$$n$$$ is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array), and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).$$$^{\\text{†}}$$$Given an array $$$b$$$ of size $$$|b|$$$, a decreasing subsequence of length $$$k$$$ is a sequence of indices $$$i_1, \\ldots, i_k$$$ such that:$$$1 \\leq i_1 < i_2 < \\ldots < i_k \\leq |b|$$$$$$b_{i_1} > b_{i_2} > \\ldots > b_{i_k}$$$\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10\\,000$$$). The description of the test cases follows.The first line of each test case contains a single integer $$$n$$$ ($$$3 \\leq n \\leq 500\\,000$$$).The second line of each test case contains $$$n$$$ integers $$$p_1, p_2, \\ldots, p_n$$$ ($$$1 \\le p_i \\le n$$$, $$$p_i$$$ are pairwise distinct).It is guaranteed that $$$\\max(p_i, p_{i+1}) > p_{i+2}$$$ for all $$$1 \\leq i \\leq n-2$$$.The sum of $$$n$$$ over all test cases does not exceed $$$500\\,000$$$.\n\nOutputFor each test case, output the sum over all subarrays of the length of its longest decreasing subsequence.",
    "sample_inputs": [
      "433 2 144 3 1 266 1 5 2 4 332 3 1"
    ],
    "sample_outputs": [
      "10\n17\n40\n8"
    ],
    "notes": "NoteFor any array $$$a$$$, we define $$$\\text{LDS}(a)$$$ as the length of the longest decreasing subsequence of $$$a$$$.In the first test case, all subarrays are decreasing.In the second one, we have$$$\\text{LDS}([4]) = \\text{LDS}([3]) = \\text{LDS}([1]) = \\text{LDS}([2]) = 1$$$$$$\\text{LDS}([4,3]) = \\text{LDS}([3,1]) = 2, \\text{LDS}([1, 2]) = 1$$$$$$\\text{LDS}([4,3,1]) = 3, \\text{LDS}([3,1,2]) = 2$$$$$$\\text{LDS}([4,3,1,2]) = 3$$$So the answer is $$$1+1+1+1+2+2+1+3+2+3=17$$$.",
    "tags": [
      "brute force",
      "combinatorics",
      "dp",
      "greedy",
      "math",
      "*1600"
    ],
    "url": "https://codeforces.com/problemset/problem/2128/D",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Let $$$b_i = \\max(a_i, a_{i+1})$$$, show that $$$b_1 \\geq b_2 \\geq \\ldots \\geq b_{n-1}$$$.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "If $$$a_i < a_{i+1}$$$, show that $$$a_{i+1} > \\max(a_{i+2}, a_{i+3}, \\ldots a_{n})$$$.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let $$${i_1, \\ldots, i_m}$$$ be the set of $$$i \\in [1, n]$$$ such that $$$a_i > a_{i+1}$$$. Let us show that the sequence $$$(i_1, \\ldots, i_m)$$$ is an LDS:  It is a decreasing subsequence: let $$$k \\in [1, m -1]$$$. If $$$i_{k+1} = i_{k}+1$$$, then $$$a_{i_k} > a_{(i_k) + 1} = a_{i_{k+1}}$$$. Else, we have $$$a_{(i_k) + 2} < \\max(a_{i_k}, a_{(i_k)+1})$$$, but $$$i_k + 1$$$ is such that $$$a_{i_{k}+2} \\geq a_{i_{k+1}}$$$, so $$$a_{(i_k) + 2} < a_{i_k}$$$. We have also $$$a_{i_k + 1} < a_{i_k}$$$ by definition so we can easily prove by induction on $$$j > 0$$$ that $$$a_{i_k + j} < a_{i_k}$$$ where it makes sense. It's optimal : let $$$E$$$ be the set of indexes taken by a LDS. For each i such that $$$a_i \\leq a_{i+1}$$$, at least one of the elements of $$${i, i+1}$$$ does not belong to $$$E$$$. Now, these sets are disjoint : if $$$a_i < a_{i+1}$$$ we cannot have $$$a_{i+2} < a_{i+1}$$$ (otherwise the condition $$$\\max(a_i, a_{i+1}) > a_{i+2}$$$ is not met. So $$$|E| \\leq m$$$. To calculate the sum of the LDS of the sub-arrays, it is therefore sufficient to count for each $$$i$$$ such that $$$a_i < a_{i+1}$$$ the number of sub-arrays $$$a[l,r]$$$ which contain $$$i$$$ and $$$i + 1$$$. It's $$$(i+1) \\cdot (n - i - 1)$$$ for $$$0$$$-indexation : a necessary and sufficient condition is that $$$l \\leq i$$$ and $$$r \\geq i + 1$$$.Note that there also exists a dp approach, see this comment.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199533",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2126A": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126A",
    "problem_title": "2126A - Only One Digit",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int x;\n    cin >> x;\n    int mn = 9;\n    while(x > 0) {\n      mn = min(mn, x % 10);\n      x/=10;\n    }\n    cout << mn << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int x;\n    cin >> x;\n    int mn = 9;\n    while(x > 0) {\n      mn = min(mn, x % 10);\n      x/=10;\n    }\n    cout << mn << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126B": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126B",
    "problem_title": "2126B - No Casino in the Mountains",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    int cnt = 0;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] == 1) {\n        ans+=(cnt + 1)/(k + 1);\n        cnt = 0;\n        continue;\n      }\n      else {\n        cnt++;\n      }\n    }\n    ans+=(cnt + 1)/(k + 1);\n    cout << ans << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    int cnt = 0;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] == 1) {\n        ans+=(cnt + 1)/(k + 1);\n        cnt = 0;\n        continue;\n      }\n      else {\n        cnt++;\n      }\n    }\n    ans+=(cnt + 1)/(k + 1);\n    cout << ans << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126C": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126C",
    "problem_title": "2126C - I Will Definitely Make It",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,p;\n    cin >> n >> p;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int cur = a[p];\n    int dist = a[p];\n    sort(a + 1,a + n + 1);\n    bool ans = true;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] < cur) continue;\n      if(a[i] &mdash; cur > dist) {\n        ans = false;\n      }\n      cur = a[i];\n    }\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,p;\n    cin >> n >> p;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int cur = a[p];\n    int dist = a[p];\n    sort(a + 1,a + n + 1);\n    bool ans = true;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] < cur) continue;\n      if(a[i] &mdash; cur > dist) {\n        ans = false;\n      }\n      cur = a[i];\n    }\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126D": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126D",
    "problem_title": "2126D - This Is the Last Time",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    pair <int,pair <int,int> > p[n + 1];\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[ыi].second.first >> p[i].second.second;\n    sort(p + 1,p + n + 1);\n    int cur = k;\n    for(int i = 1;i <= n;i++) {\n      if(p[i].first > cur) break;\n      cur = max(cur,p[i].second.second);\n    }\n    cout << cur << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    pair <int,pair <int,int> > p[n + 1];\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[ыi].second.first >> p[i].second.second;\n    sort(p + 1,p + n + 1);\n    int cur = k;\n    for(int i = 1;i <= n;i++) {\n      if(p[i].first > cur) break;\n      cur = max(cur,p[i].second.second);\n    }\n    cout << cur << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126E": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126E",
    "problem_title": "2126E - G-C-D, Unlucky!",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nmain() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long a[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        long long b[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        long long ans[n + 1];\n        for (int i = n; i >= 1; i--) {\n            ans[i] = lcm(a[i], b[i]);\n        }\n        bool ch = 1;\n        if(ans[1] != a[1]) ch = 0;\n        if(ans[n] != b[n]) ch = 0;\n        for (int i = 2; i <= n; i++) {\n            if (__gcd(a[i &mdash; 1], ans[i]) != a[i]) {\n                ch = 0;\n            }\n        }\n        for (int i = n &mdash; 1; i >= 1; i--) {\n            if (__gcd(b[i + 1], ans[i]) != b[i]) {\n                ch = 0;\n            }\n        }\n        if (ch) {\n            cout << \"YES\" << \"\\n\";\n        } else {\n            cout << \"NO\" << \"\\n\";\n        }\n    }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nmain() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long a[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        long long b[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        long long ans[n + 1];\n        for (int i = n; i >= 1; i--) {\n            ans[i] = lcm(a[i], b[i]);\n        }\n        bool ch = 1;\n        if(ans[1] != a[1]) ch = 0;\n        if(ans[n] != b[n]) ch = 0;\n        for (int i = 2; i <= n; i++) {\n            if (__gcd(a[i &mdash; 1], ans[i]) != a[i]) {\n                ch = 0;\n            }\n        }\n        for (int i = n &mdash; 1; i >= 1; i--) {\n            if (__gcd(b[i + 1], ans[i]) != b[i]) {\n                ch = 0;\n            }\n        }\n        if (ch) {\n            cout << \"YES\" << \"\\n\";\n        } else {\n            cout << \"NO\" << \"\\n\";\n        }\n    }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126F": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126F",
    "problem_title": "2126F - 1-1-1, Free Tree!",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\nint n;\nint col[B];\nlong long costt = 0;\nvector <pair <int,int> > reb[B];\nbool was[B];\nmap <int,long long> cnt[B];\nint pred[B];\nlong long zn[B];\nvoid dfs(int v) {\n  was[v] = true;\n  for(auto u:reb[v]) {\n    if(was[u.first]) {\n      pred[v] = u.first;\n      continue;\n    }\n    if(col[v] != col[u.first]) costt+=u.second;\n    dfs(u.first);\n    zn[u.first] = u.second;\n    cnt[v][col[u.first]]+=zn[u.first];\n  }\n}\nvoid update(int v,int x) {\n  if(v != 1) {\n    cnt[pred[v]][col[v]]-=zn[v];\n    if(col[pred[v]] == col[v]) costt+=zn[v];\n    cnt[pred[v]][x]+=zn[v];\n    if(col[pred[v]] == x) costt-=zn[v];\n  }\n  else {\n      \n  }\n  costt+=cnt[v][col[v]];\n  costt-=cnt[v][x];\n  col[v] = x;\n}\nvoid clr() {\n  for(int i = 1;i <= n;i++) {\n    reb[i].clear();\n    was[i] = false;\n    cnt[i].clear();\n    zn[i] = 0;\n  }\n  costt = 0;\n}\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int q;\n    cin >> n >> q;\n    for(int i = 1; i <= n; i++) cin >> col[i];\n    for(int i = 1; i < n; i++) {\n      int u, v, c;\n      cin >> u >> v >> c;\n      reb[v].push_back({u,c});\n      reb[u].push_back({v,c});\n    }\n    dfs(1);\n    while(q--) {\n      int pos,x;\n      cin >> pos >> x;\n      update(pos,x);\n      cout << costt << \"\\n\";\n    }\n    clr();\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\nint n;\nint col[B];\nlong long costt = 0;\nvector <pair <int,int> > reb[B];\nbool was[B];\nmap <int,long long> cnt[B];\nint pred[B];\nlong long zn[B];\nvoid dfs(int v) {\n  was[v] = true;\n  for(auto u:reb[v]) {\n    if(was[u.first]) {\n      pred[v] = u.first;\n      continue;\n    }\n    if(col[v] != col[u.first]) costt+=u.second;\n    dfs(u.first);\n    zn[u.first] = u.second;\n    cnt[v][col[u.first]]+=zn[u.first];\n  }\n}\nvoid update(int v,int x) {\n  if(v != 1) {\n    cnt[pred[v]][col[v]]-=zn[v];\n    if(col[pred[v]] == col[v]) costt+=zn[v];\n    cnt[pred[v]][x]+=zn[v];\n    if(col[pred[v]] == x) costt-=zn[v];\n  }\n  else {\n      \n  }\n  costt+=cnt[v][col[v]];\n  costt-=cnt[v][x];\n  col[v] = x;\n}\nvoid clr() {\n  for(int i = 1;i <= n;i++) {\n    reb[i].clear();\n    was[i] = false;\n    cnt[i].clear();\n    zn[i] = 0;\n  }\n  costt = 0;\n}\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int q;\n    cin >> n >> q;\n    for(int i = 1; i <= n; i++) cin >> col[i];\n    for(int i = 1; i < n; i++) {\n      int u, v, c;\n      cin >> u >> v >> c;\n      reb[v].push_back({u,c});\n      reb[u].push_back({v,c});\n    }\n    dfs(1);\n    while(q--) {\n      int pos,x;\n      cin >> pos >> x;\n      update(pos,x);\n      cout << costt << \"\\n\";\n    }\n    clr();\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126G1": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126G1",
    "problem_title": "2126G1 - Big Wins! (easy version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    for(int i = 1;i <= 100;i++) {\n      int b[n + 1] = {};\n      for(int j = 1;j <= n;j++) {\n        if(a[j] >= i) b[j] = 1;\n        else b[j] = -1;\n      }\n      int pref[n + 1] = {};\n      for(int j = 1; j <= n; j++) {\n        pref[j] = pref[j - 1] + b[j]; \n      }\n      int prefmn[n + 2] = {},suffmx[n + 1] = {};\n      prefmn[0] = 0,suffmx[n] = pref[n];\n      for(int j = 1; j <= n; j++) {\n        prefmn[j] = min(prefmn[j - 1],pref[j]);\n      }\n      for(int j = n - 1; j >= 1; j--) {\n        suffmx[j] = max(suffmx[j + 1],pref[j]);\n      }\n      for(int j = 1; j <= n; j++) {\n        if(prefmn[j - 1] <= pref[j] || pref[j - 1] <= suffmx[j]) {\n          ans = max(ans,i - a[j]);\n        }\n      }\n    } \n    cout << ans << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    for(int i = 1;i <= 100;i++) {\n      int b[n + 1] = {};\n      for(int j = 1;j <= n;j++) {\n        if(a[j] >= i) b[j] = 1;\n        else b[j] = -1;\n      }\n      int pref[n + 1] = {};\n      for(int j = 1; j <= n; j++) {\n        pref[j] = pref[j - 1] + b[j]; \n      }\n      int prefmn[n + 2] = {},suffmx[n + 1] = {};\n      prefmn[0] = 0,suffmx[n] = pref[n];\n      for(int j = 1; j <= n; j++) {\n        prefmn[j] = min(prefmn[j - 1],pref[j]);\n      }\n      for(int j = n - 1; j >= 1; j--) {\n        suffmx[j] = max(suffmx[j + 1],pref[j]);\n      }\n      for(int j = 1; j <= n; j++) {\n        if(prefmn[j - 1] <= pref[j] || pref[j - 1] <= suffmx[j]) {\n          ans = max(ans,i - a[j]);\n        }\n      }\n    } \n    cout << ans << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126G2": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126G2",
    "problem_title": "G2. Big Wins! (hard version)",
    "time_limit": "4 seconds",
    "memory_limit": "256 megabytes",
    "statement": "This is the hard version of the problem. The difference between the versions is that in this version $$$a_i \\leq n$$$.You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$.Your task is to find a subarray $$$a[l, r]$$$ (a continuous sequence of elements $$$a_l, a_{l + 1}, \\dots, a_r$$$) for which the value of the expression $$$\\text{med}(a[l, r]) - \\min(a[l, r])$$$ is maximized.Here:$$$\\text{med}$$$ is the median of the subarray, that is, the element at position $$$\\left\\lceil \\frac{k + 1}{2} \\right\\rceil$$$ after sorting the subarray, where $$$k$$$ is its length;$$$\\min$$$ is the minimum element of this subarray.For example, consider the array $$$a=[1, 4, 1, 5, 3, 3]$$$ and choose the subarray $$$a[2, 5] = [4, 1, 5, 3]$$$. In sorted form, it looks like $$$[1, 3, 4, 5]$$$.$$$\\text{med}(a[2, 5]) = 4$$$, since $$$\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil = $$$ the third element in the sorted subarray is $$$4$$$;$$$\\min(a[2, 5]) = 1$$$, since the minimum element is $$$1$$$.In this example, the value $$$\\text{med} - \\min = 4 - 1 = 3$$$.\n\nInputThe first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the array.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.\n\nOutputFor each test case, output one integer — the maximum possible value of $$$\\text{med} - \\min$$$ among all subarrays of the array.",
    "sample_inputs": [
      "553 2 5 3 144 1 1 376 1 3 4 6 2 744 2 3 151 2 3 4 5"
    ],
    "sample_outputs": [
      "3\n3\n5\n2\n2"
    ],
    "notes": "NoteIn the first example, consider the array: $$$a=[3,\\ 2,\\ 5,\\ 3,\\ 1]$$$ you can choose the subarray $$$a[2,\\ 3]$$$, that is, the elements $$$[2,\\ 5]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[2,\\ 5]$$$, $$$\\text{med} = 5$$$.The minimum element of the subarray: $$$\\min = 2$$$.Therefore, $$$\\text{med} - \\min = 5 - 2 = 3$$$, which is the maximum answer.In the second test, the array: $$$a=[4,\\ 1,\\ 1,\\ 3]$$$ you can choose the subarray $$$a[1,\\ 2]$$$, that is, the elements $$$[4,\\ 1]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[1,\\ 4]$$$, $$$\\text{med} = 4$$$.The minimum element of the subarray: $$$\\min = 1$$$.Therefore, $$$\\text{med} - \\min = 4 - 1 = 3$$$.It can be proven that both of these subarrays are optimal and yield the maximum value of the expression $$$\\text{med} - \\min$$$.",
    "tags": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dsu",
      "trees",
      "two pointers",
      "*2400"
    ],
    "url": "https://codeforces.com/contest/2126/problem/G2",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint a[200005 + 2];\narray<int, 4> t[800005];\narray<int, 4> merge(array<int, 4>a, array<int, 4>b) {\n    int ans = max(a[0], b[0]);\n    int mxpref = max(a[1], a[3] + b[1]);\n    int mxsuff = max(b[2], a[2] + b[3]);\n    ans = max({ans, mxpref, mxsuff});\n    int sum = a[3] + b[3];\n    return {ans, mxpref, mxsuff, sum};\n}\nvoid update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n        t[v] = {max(val, 0), max(val, 0), max(val, 0), val};\n    } else {\n        int tm = (tl + tr) >> 1;\n        if (pos <= tm) {\n            update(v * 2, tl, tm, pos, val);\n        } else {\n            update(v * 2 + 1, tm + 1, tr, pos, val);\n        }\n        t[v] = merge(t[v * 2], t[v * 2 + 1]);\n    }\n}\narray<int, 4> get(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n        return t[v];\n    } else if (l > r) {\n        return {0, 0, 0, 0};\n    } else {\n        int tm = (tl + tr) >> 1;\n        return merge(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n}\nint solve(int n, vector<int>A) {\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n        m = max(m, a[i]);\n    }\n    vector<int>ind[m + 1];\n    for (int i = 1; i <= n; i++) {\n        ind[a[i]].push_back(i);\n    }\n    stack<int>s;\n    s.push(0);\n    a[0] = -INT_MAX;\n    int l[n + 1];\n    for (int i = 1; i <= n; i++) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        l[i] = s.top() + 1;\n        s.push(i);\n    }\n    a[n + 1] = -INT_MAX;\n    s.push(n + 1);\n    int r[n + 1];\n    for (int i = n; i >= 1; i--) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        r[i] = s.top() &mdash; 1;\n        s.push(i);\n    }\n    int med = 1;\n    for (int i = 1; i <= n; i++) {\n        update(1, 1, n, i, 1);\n    }\n    for (auto u : ind[1]) {\n        update(1, 1, n, u, -1);\n    }\n    int ans = 0;\n    for (int mn = 1; mn <= m; mn++) {\n        for (auto u : ind[mn]) {\n            int lg = l[u], rg = r[u];\n            while (med < m && get(1, 1, n, lg, u &mdash; 1)[2] + get(1, 1, n, u + 1, rg)[1] + (a[u] < (med) ? -1 : 1) >= 0) {\n                med++;\n                for (auto u : ind[med]) {\n                    update(1, 1, n, u, -1);\n                }\n            }\n        }\n        // cout << med << ' ' << mn << endl;\n        ans = max(ans, med &mdash; mn);\n    }\n    return ans;\n}\nint solveslow(int n, vector<int>A) {\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        vector<int>v;\n        for (int j = i; j <= n; j++) {\n            v.push_back(a[j]);\n            sort(v.begin(), v.end());\n            mx = max(mx, v[v.size() / 2] &mdash; v[0]);\n        }\n    }\n    return mx;\n}\nint rnd() {\n    return (rand() + rand() * RAND_MAX);\n}\nmain() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while(tt--) {\n        int n;\n        cin >> n;\n        vector<int>v;\n        for (int i = 1; i <= n; i++) {\n            int x;\n            cin >> x;\n            v.push_back(x);\n        }\n        cout << solve(n, v) << endl;\n        // cout << solveslow(n, v) << endl;\n        for(int i = 0;i <= n*4;i++) {\n            t[i][0] = 0;\n            t[i][1] = 0;\n            t[i][2] = 0;\n            t[i][3] = 0;\n        }\n    }\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint a[200005 + 2];\narray<int, 4> t[800005];\narray<int, 4> merge(array<int, 4>a, array<int, 4>b) {\n    int ans = max(a[0], b[0]);\n    int mxpref = max(a[1], a[3] + b[1]);\n    int mxsuff = max(b[2], a[2] + b[3]);\n    ans = max({ans, mxpref, mxsuff});\n    int sum = a[3] + b[3];\n    return {ans, mxpref, mxsuff, sum};\n}\nvoid update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n        t[v] = {max(val, 0), max(val, 0), max(val, 0), val};\n    } else {\n        int tm = (tl + tr) >> 1;\n        if (pos <= tm) {\n            update(v * 2, tl, tm, pos, val);\n        } else {\n            update(v * 2 + 1, tm + 1, tr, pos, val);\n        }\n        t[v] = merge(t[v * 2], t[v * 2 + 1]);\n    }\n}\narray<int, 4> get(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n        return t[v];\n    } else if (l > r) {\n        return {0, 0, 0, 0};\n    } else {\n        int tm = (tl + tr) >> 1;\n        return merge(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n}\nint solve(int n, vector<int>A) {\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n        m = max(m, a[i]);\n    }\n    vector<int>ind[m + 1];\n    for (int i = 1; i <= n; i++) {\n        ind[a[i]].push_back(i);\n    }\n    stack<int>s;\n    s.push(0);\n    a[0] = -INT_MAX;\n    int l[n + 1];\n    for (int i = 1; i <= n; i++) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        l[i] = s.top() + 1;\n        s.push(i);\n    }\n    a[n + 1] = -INT_MAX;\n    s.push(n + 1);\n    int r[n + 1];\n    for (int i = n; i >= 1; i--) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        r[i] = s.top() &mdash; 1;\n        s.push(i);\n    }\n    int med = 1;\n    for (int i = 1; i <= n; i++) {\n        update(1, 1, n, i, 1);\n    }\n    for (auto u : ind[1]) {\n        update(1, 1, n, u, -1);\n    }\n    int ans = 0;\n    for (int mn = 1; mn <= m; mn++) {\n        for (auto u : ind[mn]) {\n            int lg = l[u], rg = r[u];\n            while (med < m && get(1, 1, n, lg, u &mdash; 1)[2] + get(1, 1, n, u + 1, rg)[1] + (a[u] < (med) ? -1 : 1) >= 0) {\n                med++;\n                for (auto u : ind[med]) {\n                    update(1, 1, n, u, -1);\n                }\n            }\n        }\n        // cout << med << ' ' << mn << endl;\n        ans = max(ans, med &mdash; mn);\n    }\n    return ans;\n}\nint solveslow(int n, vector<int>A) {\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        vector<int>v;\n        for (int j = i; j <= n; j++) {\n            v.push_back(a[j]);\n            sort(v.begin(), v.end());\n            mx = max(mx, v[v.size() / 2] &mdash; v[0]);\n        }\n    }\n    return mx;\n}\nint rnd() {\n    return (rand() + rand() * RAND_MAX);\n}\nmain() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while(tt--) {\n        int n;\n        cin >> n;\n        vector<int>v;\n        for (int i = 1; i <= n; i++) {\n            int x;\n            cin >> x;\n            v.push_back(x);\n        }\n        cout << solve(n, v) << endl;\n        // cout << solveslow(n, v) << endl;\n        for(int i = 0;i <= n*4;i++) {\n            t[i][0] = 0;\n            t[i][1] = 0;\n            t[i][2] = 0;\n            t[i][3] = 0;\n        }\n    }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "problemG2": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "problemG2",
    "problem_title": "G2. Big Wins! (hard version)",
    "time_limit": "4 seconds",
    "memory_limit": "256 megabytes",
    "statement": "This is the hard version of the problem. The difference between the versions is that in this version $$$a_i \\leq n$$$.You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$.Your task is to find a subarray $$$a[l, r]$$$ (a continuous sequence of elements $$$a_l, a_{l + 1}, \\dots, a_r$$$) for which the value of the expression $$$\\text{med}(a[l, r]) - \\min(a[l, r])$$$ is maximized.Here:$$$\\text{med}$$$ is the median of the subarray, that is, the element at position $$$\\left\\lceil \\frac{k + 1}{2} \\right\\rceil$$$ after sorting the subarray, where $$$k$$$ is its length;$$$\\min$$$ is the minimum element of this subarray.For example, consider the array $$$a=[1, 4, 1, 5, 3, 3]$$$ and choose the subarray $$$a[2, 5] = [4, 1, 5, 3]$$$. In sorted form, it looks like $$$[1, 3, 4, 5]$$$.$$$\\text{med}(a[2, 5]) = 4$$$, since $$$\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil = $$$ the third element in the sorted subarray is $$$4$$$;$$$\\min(a[2, 5]) = 1$$$, since the minimum element is $$$1$$$.In this example, the value $$$\\text{med} - \\min = 4 - 1 = 3$$$.\n\nInputThe first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the array.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.\n\nOutputFor each test case, output one integer — the maximum possible value of $$$\\text{med} - \\min$$$ among all subarrays of the array.",
    "sample_inputs": [
      "553 2 5 3 144 1 1 376 1 3 4 6 2 744 2 3 151 2 3 4 5"
    ],
    "sample_outputs": [
      "3\n3\n5\n2\n2"
    ],
    "notes": "NoteIn the first example, consider the array: $$$a=[3,\\ 2,\\ 5,\\ 3,\\ 1]$$$ you can choose the subarray $$$a[2,\\ 3]$$$, that is, the elements $$$[2,\\ 5]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[2,\\ 5]$$$, $$$\\text{med} = 5$$$.The minimum element of the subarray: $$$\\min = 2$$$.Therefore, $$$\\text{med} - \\min = 5 - 2 = 3$$$, which is the maximum answer.In the second test, the array: $$$a=[4,\\ 1,\\ 1,\\ 3]$$$ you can choose the subarray $$$a[1,\\ 2]$$$, that is, the elements $$$[4,\\ 1]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[1,\\ 4]$$$, $$$\\text{med} = 4$$$.The minimum element of the subarray: $$$\\min = 1$$$.Therefore, $$$\\text{med} - \\min = 4 - 1 = 3$$$.It can be proven that both of these subarrays are optimal and yield the maximum value of the expression $$$\\text{med} - \\min$$$.",
    "tags": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dsu",
      "trees",
      "two pointers",
      "*2400"
    ],
    "url": "https://codeforces.com/contest/2126/problem/G2",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [],
    "tutorials": [],
    "editorials": []
  },
  "2129E": {
    "contest_title": "Codeforces Round 1040 (Div. 1)",
    "problem_id": "2129E",
    "problem_title": "E. Induced Subgraph Queries",
    "time_limit": "5 seconds",
    "memory_limit": "512 megabytes",
    "statement": "You are given an unweighted, undirected graph $$$G$$$ with $$$n$$$ nodes and $$$m$$$ edges. The graph $$$G$$$ contains no self-loops or multiple edges.We denote the node set of $$$G$$$ as $$$V$$$. For any node subset $$$V' \\subseteq V$$$, the corresponding induced subgraph, denoted by $$$G[V']$$$, is defined as follows:$$$G[V']$$$ is the graph whose node set is $$$V'$$$, and whose edge set consists of all edges in $$$G$$$ with both endpoints in $$$V'$$$.Your task is to answer $$$q$$$ queries. Each query provides three integers $$$l$$$, $$$r$$$, and $$$k$$$. Denoting $$$V'=\\{l,l+1,\\ldots,r\\}$$$, you need to find the $$$k$$$-th smallest value among $$$f(l,G[V'])$$$, $$$f(l+1,G[V'])$$$, $$$\\ldots$$$ , $$$f(r,G[V'])$$$ (i.e., the $$$k$$$-th value in increasing order; repeated values are counted multiple times).Here, $$$f(u,G[V'])=\\bigoplus_{(u,v)\\in G[V']}v$$$. In other words, it is thebitwise XORvalue of the labels of all adjacent nodes of node $$$u$$$ in graph $$$G[V']$$$.You might want to read the notes for a better understanding.\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 1.5 \\cdot 10^4$$$). The description of the test cases follows.Each test case begins with two integers $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 1.5 \\cdot 10^5$$$, $$$1 \\leq m \\leq 1.5 \\cdot 10^5$$$) — the number of nodes and edges, respectively.The next $$$m$$$ lines each contain two integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\leq u_i, v_i \\leq n$$$, $$$u_i \\neq v_i$$$), representing an undirected edge between nodes $$$u_i$$$ and $$$v_i$$$.The next line contains a single integer $$$q$$$ ($$$1 \\leq q \\leq 1.5 \\cdot 10^5$$$) — the number of queries.Each of the next $$$q$$$ lines contains three integers $$$l$$$, $$$r$$$, and $$$k$$$ ($$$1 \\leq l \\leq r \\leq n$$$, $$$1 \\le k \\le r-l+1$$$), defining a query about the induced subgraph $$$G[\\{l,\\ldots,r\\}]$$$.It is guaranteed that the graph contains no self-loops or multiple edges.It is guaranteed that the sum of $$$n$$$,$$$m$$$, and $$$q$$$ over all test cases does not exceed $$$1.5 \\cdot 10^5$$$, respectively.\n\nOutputFor each test case, output $$$q$$$ integers, representing the answer for each query.",
    "sample_inputs": [
      "24 51 31 42 32 43 431 2 21 3 12 4 32 12 131 1 12 2 11 2 2"
    ],
    "sample_outputs": [
      "0\n3\n7\n0\n0\n2"
    ],
    "notes": "NoteIn the first test case, the input graph $$$G$$$ is the one in the following picture.The given graph $$$G$$$.In the first query, the induced subgraph $$$G[\\{1,2\\}]$$$ is the one in the following picture. We can see that nodes $$$1$$$ and $$$2$$$ have no adjacent nodes. Thus, $$$f(1,G[\\{1,2\\}])=f(2,G[\\{1,2\\}])=0$$$. The $$$2$$$-nd smallest value is $$$0$$$.$$$G[\\{1,2\\}]$$$.In the second query, the induced subgraph $$$G[\\{1,2,3\\}]$$$ is the one in the following picture. We can see that $$$f(1,G[\\{1,2,3\\}])=3$$$, $$$f(2,G[\\{1,2,3\\}])=3$$$, and $$$f(3,G[\\{1,2,3\\}])=1 \\oplus 2=3$$$. The $$$1$$$-st smallest value is $$$3$$$.$$$G[\\{1,2,3\\}]$$$.In the third query, the induced subgraph $$$G[\\{2,3,4\\}]$$$ is the one in the following picture. We can see that $$$f(2,G[\\{2,3,4\\}])=3 \\oplus 4=7$$$, $$$f(3,G[\\{2,3,4\\}])=2 \\oplus 4=6$$$, and $$$f(4,G[\\{2,3,4\\}])=2 \\oplus 3=1$$$. The $$$3$$$-rd smallest value is $$$7$$$.$$$G[\\{2,3,4\\}]$$$.",
    "tags": [
      "data structures",
      "graphs",
      "sortings",
      "*3000"
    ],
    "url": "https://codeforces.com/problemset/problem/2129/E",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1040 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145152",
          "full_url": "https://codeforces.com/blog/entry/145152"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [],
    "tutorials": [],
    "editorials": []
  },
  "2132B": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132B",
    "problem_title": "2132B - The Secret Number",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "If Vadim appends $$$k$$$ zeros to the number $$$x$$$, what will be the ratio between $$$n$$$ and $$$x$$$? Answer$$$n = x \\cdot (10^k + 1)$$$",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long r;\n        cin >> r;\n        \n        long long d = 11;\n        vector <long long> ans;\n        while (r >= d) {\n            if (r % d == 0)\n                ans.push_back(r / d);\n            d = (d - 1) * 10 + 1;\n        }\n        \n        cout << (int)ans.size() << '\\n';\n        for (int i = (int)ans.size() - 1; i >= 0; --i)\n            cout << ans[i] << ' ';\n        cout << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long r;\n        cin >> r;\n        \n        long long d = 11;\n        vector <long long> ans;\n        while (r >= d) {\n            if (r % d == 0)\n                ans.push_back(r / d);\n            d = (d - 1) * 10 + 1;\n        }\n        \n        cout << (int)ans.size() << '\\n';\n        for (int i = (int)ans.size() - 1; i >= 0; --i)\n            cout << ans[i] << ' ';\n        cout << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132C1": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132C1",
    "problem_title": "2132C1 - The Cunning Seller (easy version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Does it make sense to use the same type of deal more than 2 times?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "The solution with the minimum number of deals is unique.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "Ternary numeral system.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n;\n        cin >> n;\n        long long min_k = 0;\n        long long min_cost = 0;\n        int sz = 0;\n        while (n) {\n            min_k += n % 3;\n            min_cost += (n % 3) * cost[sz];\n            n /= 3;\n            sz++;\n        }\n        cout << min_cost << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n;\n        cin >> n;\n        long long min_k = 0;\n        long long min_cost = 0;\n        int sz = 0;\n        while (n) {\n            min_k += n % 3;\n            min_cost += (n % 3) * cost[sz];\n            n /= 3;\n            sz++;\n        }\n        cout << min_cost << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132C2": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132C2",
    "problem_title": "2132C2 - The Cunning Seller (hard version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "What is more profitable: 3 deals for $$$3^x$$$ watermelons each, or 1 deal for $$$3^{x+1}$$$ watermelons?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Recall the solution to problem C1.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n, k;\n        cin >> n >> k;\n        vector <long long> tr;\n        long long min_k = 0;\n        while (n) {\n            tr.push_back(n % 3);\n            min_k += n % 3;\n            n /= 3;\n        }\n        if (min_k > k) {\n            cout << -1 << '\\n';\n            continue;\n        }\n        k -= min_k;\n        k /= 2;\n        for (int i = (int)tr.size() - 1; i >= 1; --i) {\n            if (tr[i] <= k) {\n                tr[i - 1] += 3 * tr[i];\n                k -= tr[i];\n                tr[i] = 0;\n            } else {\n                tr[i - 1] += k * 3;\n                tr[i] -= k;\n                break;\n            }\n        }\n        ll an = 0;\n        for (int i = (int)tr.size() - 1; i >= 0; --i)\n            an += cost[i] * tr[i];\n        cout << an << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n, k;\n        cin >> n >> k;\n        vector <long long> tr;\n        long long min_k = 0;\n        while (n) {\n            tr.push_back(n % 3);\n            min_k += n % 3;\n            n /= 3;\n        }\n        if (min_k > k) {\n            cout << -1 << '\\n';\n            continue;\n        }\n        k -= min_k;\n        k /= 2;\n        for (int i = (int)tr.size() - 1; i >= 1; --i) {\n            if (tr[i] <= k) {\n                tr[i - 1] += 3 * tr[i];\n                k -= tr[i];\n                tr[i] = 0;\n            } else {\n                tr[i - 1] += k * 3;\n                tr[i] -= k;\n                break;\n            }\n        }\n        ll an = 0;\n        for (int i = (int)tr.size() - 1; i >= 0; --i)\n            an += cost[i] * tr[i];\n        cout << an << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132D": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132D",
    "problem_title": "2132D - From 1 to Infinity",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Find out which number the $$$k$$$-th digit belongs to in the infinite sequence. Let this number be $$$n$$$. Instead of analyzing the sequence, we can calculate the sum of the sums of the digits of all integers from $$$0$$$ to $$$n - 1$$$ and add to this the sum of the required digits of the number $$$n$$$.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Mentally add leading zeros to all numbers from $$$0$$$ to $$$n - 1$$$ so that their lengths become the same. The sum of the sums of the digits will not change, but it will be more convenient to determine the formulas in this case.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long k;\n        cin >> k;\n        long long cur = 9, len = 1;\n        while (k - cur * len > 0) {\n            k -= cur * len;\n            cur *= 10;\n            len++;\n        }\n        string s = to_string(cur / 9 + (k - 1) / len);\n        long long ans = 0;\n        for (int i = 0; i < (k - 1) % len + 1; i++)\n            ans += s[i] - '0';\n        long long pr_s = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int curd = s[i] - '0';\n            if (curd)\n                ans += curd * (len - 1) * cur / 2 + curd * (2 * pr_s + curd - 1) / 2 * cur / 9;\n            cur /= 10, len--;\n            pr_s += curd;\n        }\n        cout << ans << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long k;\n        cin >> k;\n        long long cur = 9, len = 1;\n        while (k - cur * len > 0) {\n            k -= cur * len;\n            cur *= 10;\n            len++;\n        }\n        string s = to_string(cur / 9 + (k - 1) / len);\n        long long ans = 0;\n        for (int i = 0; i < (k - 1) % len + 1; i++)\n            ans += s[i] - '0';\n        long long pr_s = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int curd = s[i] - '0';\n            if (curd)\n                ans += curd * (len - 1) * cur / 2 + curd * (2 * pr_s + curd - 1) / 2 * cur / 9;\n            cur /= 10, len--;\n            pr_s += curd;\n        }\n        cout << ans << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132E": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132E",
    "problem_title": "2132E - Arithmetics Competition",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "If we know how many specific cards Vadim should take, and how many should take Kostya (for example when $$$x + y = z$$$). How can we then obtain the maximum possible sum?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "We need to quickly compute the sum of the $$$x$$$ maximum elements in array $$$a$$$ and the sum of the $$$y$$$ maximum elements in array $$$b$$$. What should we do to be able to compute this for arbitrary $$$x$$$ and $$$y$$$ in $$$O(1)$$$?",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "How can we solve this problem if $$$x = n$$$ and $$$y = m$$$ — that is, each person can choose any number of cards, as long as their total is $$$z$$$?",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "If $$$x = n$$$ and $$$y = m$$$, then the optimal set of $$$z$$$ cards consists of $$$x'$$$ maximum cards from Vadim and $$$y'$$$ maximum cards from Kostya (where $$$x' + y' = z$$$). How should we adjust this optimal answer if the optimal number for Vadim or Kostya exceeds their limits (that is, if $$$x < x'$$$ or $$$y < y'$$$)?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution 1",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n\n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n\n    vector <pair <int, int>> ans(n + m + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i < ans.size(); i++) {\n        if (l < n && r < m) {\n            if (a[l] < b[r])\n                r++;\n            else\n                l++;\n        }\n        else if (l == n)\n            r++;\n        else if (r == m)\n            l++;\n        ans[i] = { l, r };\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        l = ans[z].first, r = ans[z].second;\n        if (l > x)\n            cout << pa[x] + pb[z - x] << '\\n';\n        else if (r > y)\n            cout << pa[z - y] + pb[y] << '\\n';\n        else\n            cout << pa[l] + pb[r] << '\\n';\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n\n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n\n    vector <pair <int, int>> ans(n + m + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i < ans.size(); i++) {\n        if (l < n && r < m) {\n            if (a[l] < b[r])\n                r++;\n            else\n                l++;\n        }\n        else if (l == n)\n            r++;\n        else if (r == m)\n            l++;\n        ans[i] = { l, r };\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        l = ans[z].first, r = ans[z].second;\n        if (l > x)\n            cout << pa[x] + pb[z - x] << '\\n';\n        else if (r > y)\n            cout << pa[z - y] + pb[y] << '\\n';\n        else\n            cout << pa[l] + pb[r] << '\\n';\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      },
      {
        "title": "solution 2",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n \n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n \n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n \n        int l = max(0, z - y);\n        int r = min(z, x);\n        while (l + 2 < r) {\n            int m1 = (l + l + r) / 3;\n            int m2 = (l + r + r) / 3;\n            if (pa[m1] + pb[z - m1] > pa[m2] + pb[z - m2]) {\n                r = m2;\n            } else {\n                l = m1;\n            }\n        }\n \n        long long s = 0;\n        for (int i = l; i <= r; i++)\n            s = max(s, pa[i] + pb[z - i]);\n \n        cout << s << '\\n';\n    }\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n \n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n \n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n \n        int l = max(0, z - y);\n        int r = min(z, x);\n        while (l + 2 < r) {\n            int m1 = (l + l + r) / 3;\n            int m2 = (l + r + r) / 3;\n            if (pa[m1] + pb[z - m1] > pa[m2] + pb[z - m2]) {\n                r = m2;\n            } else {\n                l = m1;\n            }\n        }\n \n        long long s = 0;\n        for (int i = l; i <= r; i++)\n            s = max(s, pa[i] + pb[z - i]);\n \n        cout << s << '\\n';\n    }\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132F": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132F",
    "problem_title": "2132F - Rada and the Chamomile Valley",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Recall or learn what bridges are and understand how this is related to the lanes that lie on all paths from $$$1$$$ to $$$n$$$.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "How to find all the bridges that lie on every path from $$$1$$$ to $$$n$$$?",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "Solve the problem for the case where $$$n = q$$$ and $$$c_i = i$$$.",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "How to find the nearest vertex from a given set of vertices $$$S$$$ for each vertex?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvector <vector <int>> g;\nvector <bool> used;\nvector <int> d, h;\nvector <pair <int, int>> edges;\nvector <int> cut, path;\nint mark = 1;\n\nvoid dfs(int v, int p, int n) {\n    used[v] = true;\n    d[v] = h[v] = (p == -1 ? 0 : d[p] + 1);\n    if (v == n) mark = 0;\n    for (auto e : g[v]) {\n        int to = edges[e].first + edges[e].second - v;\n        if (to == p) continue;\n        if (used[to])\n            h[v] = min(h[v], d[to]);\n        else {\n            path[e] ^= mark;\n            dfs(to, v, n);\n            path[e] ^= mark;\n            h[v] = min(h[v], h[to]);\n            if (h[to] > d[v]) cut[e] = 1;\n        }\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        g.assign(n + 1, {});\n        used.assign(n + 1, false);\n        d.assign(n + 1, 0);\n        h.assign(n + 1, 0);\n        edges = {};\n        cut.assign(m, false);\n        path.assign(m, false);\n        mark = 1;\n        for (int i = 0; i < m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            edges.push_back({a, b});\n            g[a].push_back(i);\n            g[b].push_back(i);\n        }\n        \n        dfs(1, -1, n);\n        \n        vector <int> ans(n + 1, n + m);\n        vector <int> dist(n + 1, n + m);\n        queue <int> q;\n        for (int i = 0; i < m; ++i) {\n            if (cut[i] && path[i]) {\n                ans[edges[i].first] = min(ans[edges[i].first], i + 1);\n                ans[edges[i].second] = min(ans[edges[i].second], i + 1);\n                if (dist[edges[i].first]) {\n                    dist[edges[i].first] = 0;\n                    q.push(edges[i].first);\n                }\n                if (dist[edges[i].second]) {\n                    dist[edges[i].second] = 0;\n                    q.push(edges[i].second);\n                }\n            }\n        }\n        \n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (auto e : g[v]) {\n                int to = edges[e].first + edges[e].second - v;\n                if (dist[to] > dist[v] + 1) {\n                    dist[to] = dist[v] + 1;\n                    ans[to] = ans[v];\n                    q.push(to);\n                }\n                else if (dist[to] == dist[v] + 1)\n                    ans[to] = min(ans[to], ans[v]);\n            }\n        }\n        \n        int Q;\n        cin >> Q;\n        while (Q--) {\n            int v;\n            cin >> v;\n            if (ans[v] == n + m) cout << -1;\n            else cout << ans[v];\n            if (t || Q) cout << '\\n';\n        }\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvector <vector <int>> g;\nvector <bool> used;\nvector <int> d, h;\nvector <pair <int, int>> edges;\nvector <int> cut, path;\nint mark = 1;\n\nvoid dfs(int v, int p, int n) {\n    used[v] = true;\n    d[v] = h[v] = (p == -1 ? 0 : d[p] + 1);\n    if (v == n) mark = 0;\n    for (auto e : g[v]) {\n        int to = edges[e].first + edges[e].second - v;\n        if (to == p) continue;\n        if (used[to])\n            h[v] = min(h[v], d[to]);\n        else {\n            path[e] ^= mark;\n            dfs(to, v, n);\n            path[e] ^= mark;\n            h[v] = min(h[v], h[to]);\n            if (h[to] > d[v]) cut[e] = 1;\n        }\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        g.assign(n + 1, {});\n        used.assign(n + 1, false);\n        d.assign(n + 1, 0);\n        h.assign(n + 1, 0);\n        edges = {};\n        cut.assign(m, false);\n        path.assign(m, false);\n        mark = 1;\n        for (int i = 0; i < m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            edges.push_back({a, b});\n            g[a].push_back(i);\n            g[b].push_back(i);\n        }\n        \n        dfs(1, -1, n);\n        \n        vector <int> ans(n + 1, n + m);\n        vector <int> dist(n + 1, n + m);\n        queue <int> q;\n        for (int i = 0; i < m; ++i) {\n            if (cut[i] && path[i]) {\n                ans[edges[i].first] = min(ans[edges[i].first], i + 1);\n                ans[edges[i].second] = min(ans[edges[i].second], i + 1);\n                if (dist[edges[i].first]) {\n                    dist[edges[i].first] = 0;\n                    q.push(edges[i].first);\n                }\n                if (dist[edges[i].second]) {\n                    dist[edges[i].second] = 0;\n                    q.push(edges[i].second);\n                }\n            }\n        }\n        \n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (auto e : g[v]) {\n                int to = edges[e].first + edges[e].second - v;\n                if (dist[to] > dist[v] + 1) {\n                    dist[to] = dist[v] + 1;\n                    ans[to] = ans[v];\n                    q.push(to);\n                }\n                else if (dist[to] == dist[v] + 1)\n                    ans[to] = min(ans[to], ans[v]);\n            }\n        }\n        \n        int Q;\n        cin >> Q;\n        while (Q--) {\n            int v;\n            cin >> v;\n            if (ans[v] == n + m) cout << -1;\n            else cout << ans[v];\n            if (t || Q) cout << '\\n';\n        }\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132G": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132G",
    "problem_title": "2132G - Famous Choreographer",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "There is no point in adding new symbols both above and below the original table simultaneously. Similarly, there is no point in adding symbols both to the left and to the right of the table at the same time.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "The center of the optimal answer table lies within the original one.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "We do not need to construct the answer; it is sufficient to check that an answer exists for the current center. Think about how to do this.",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "An answer exists for the current center if the subtable, which is the intersection of the original table and the one rotated around the center by $$$180^{\\circ}$$$, becomes identical to the original when rotated by $$$180^{\\circ}$$$. This subtable must contain at least one of the corners of the original table.",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "The checking of centers can be replaced by the checking of subtables that contain at least one of the corners of the original table.",
        "codes": []
      },
      {
        "title": "hint 6",
        "text": "To check the subtables to see if they become identical to the original when rotated by $$$180^{\\circ}$$$, we can use hashing.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MOD = 998244353;\nconst int P[2] = { 107, 61 };\nint BP[2];\n\nlong long bin_pow(long long a, int n) {\n    long long ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % MOD;\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return ret;\n}\n\ninline int add(int a, int b) {\n    int res = a + b;\n    if (res >= MOD) return res - MOD;\n    return res;\n}\n\ninline int sub(int a, int b) {\n    int res = a - b;\n    if (res < 0) return res + MOD;\n    return res;\n}\n\ninline int mult(int a, int b) {\n    long long res = (long long)a * b;\n    if (res >= MOD) return res % MOD;\n    return res;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    BP[0] = bin_pow(P[0], MOD - 2);\n    BP[1] = bin_pow(P[1], MOD - 2);\n    vector <int> pows[2];\n    vector <int> bpows[2];\n    for (int j = 0; j < 2; j++) {\n        pows[j].resize(1e6, 1);\n        bpows[j].resize(1e6, 1);\n        for (int i = 1; i < 1e6; i++) {\n            pows[j][i] = mult(pows[j][i - 1], P[j]);\n            bpows[j][i] = mult(bpows[j][i - 1], BP[j]);\n        }\n    }\n    \n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector <string> f(n);\n        for (int i = 0; i < n; i++)\n            cin >> f[i];\n        \n        vector <vector <int>> hash(n + 2, vector <int> (m + 2, 0));\n        vector <vector <int>> bhash(n + 2, vector <int> (m + 2, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][i - 1], pows[1][j - 1]));\n                hash[i][j] = add(sub(add(hash[i - 1][j], hash[i][j - 1]), hash[i - 1][j - 1]), cur);\n            }\n        }\n        for (int i = n; i >= 1; i--) {\n            for (int j = m; j >= 1; j--) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][n - i], pows[1][m - j]));\n                bhash[i][j] = add(sub(add(bhash[i + 1][j], bhash[i][j + 1]), bhash[i + 1][j + 1]), cur);\n            }\n        }\n        \n        auto isp = [&](int x1, int y1, int x2, int y2) {\n            int hsh = add(sub(sub(hash[x2][y2], hash[x1-1][y2]), hash[x2][y1-1]), hash[x1-1][y1-1]);\n            int bhsh = add(sub(sub(bhash[x1][y1], bhash[x2+1][y1]), bhash[x1][y2+1]), bhash[x2+1][y2+1]);\n            hsh = mult(hsh, mult(bpows[0][x1 - 1], bpows[1][y1 - 1]));\n            bhsh = mult(bhsh, mult(bpows[0][n - x2], bpows[1][m - y2]));\n            return hsh == bhsh;\n        };\n        \n        int mn = n * m * 4;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (isp(1, 1, i, j)) mn = min(mn, (2 * n - i) * (2 * m - j));\n                if (isp(1, j, i, m)) mn = min(mn, (2 * n - i) * (m + j - 1));\n                if (isp(i, 1, n, j)) mn = min(mn, (n + i - 1) * (2 * m - j));\n                if (isp(i, j, n, m)) mn = min(mn, (n + i - 1) * (m + j - 1));\n            }\n        }\n        \n        cout << mn - m * n << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MOD = 998244353;\nconst int P[2] = { 107, 61 };\nint BP[2];\n\nlong long bin_pow(long long a, int n) {\n    long long ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % MOD;\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return ret;\n}\n\ninline int add(int a, int b) {\n    int res = a + b;\n    if (res >= MOD) return res - MOD;\n    return res;\n}\n\ninline int sub(int a, int b) {\n    int res = a - b;\n    if (res < 0) return res + MOD;\n    return res;\n}\n\ninline int mult(int a, int b) {\n    long long res = (long long)a * b;\n    if (res >= MOD) return res % MOD;\n    return res;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    BP[0] = bin_pow(P[0], MOD - 2);\n    BP[1] = bin_pow(P[1], MOD - 2);\n    vector <int> pows[2];\n    vector <int> bpows[2];\n    for (int j = 0; j < 2; j++) {\n        pows[j].resize(1e6, 1);\n        bpows[j].resize(1e6, 1);\n        for (int i = 1; i < 1e6; i++) {\n            pows[j][i] = mult(pows[j][i - 1], P[j]);\n            bpows[j][i] = mult(bpows[j][i - 1], BP[j]);\n        }\n    }\n    \n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector <string> f(n);\n        for (int i = 0; i < n; i++)\n            cin >> f[i];\n        \n        vector <vector <int>> hash(n + 2, vector <int> (m + 2, 0));\n        vector <vector <int>> bhash(n + 2, vector <int> (m + 2, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][i - 1], pows[1][j - 1]));\n                hash[i][j] = add(sub(add(hash[i - 1][j], hash[i][j - 1]), hash[i - 1][j - 1]), cur);\n            }\n        }\n        for (int i = n; i >= 1; i--) {\n            for (int j = m; j >= 1; j--) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][n - i], pows[1][m - j]));\n                bhash[i][j] = add(sub(add(bhash[i + 1][j], bhash[i][j + 1]), bhash[i + 1][j + 1]), cur);\n            }\n        }\n        \n        auto isp = [&](int x1, int y1, int x2, int y2) {\n            int hsh = add(sub(sub(hash[x2][y2], hash[x1-1][y2]), hash[x2][y1-1]), hash[x1-1][y1-1]);\n            int bhsh = add(sub(sub(bhash[x1][y1], bhash[x2+1][y1]), bhash[x1][y2+1]), bhash[x2+1][y2+1]);\n            hsh = mult(hsh, mult(bpows[0][x1 - 1], bpows[1][y1 - 1]));\n            bhsh = mult(bhsh, mult(bpows[0][n - x2], bpows[1][m - y2]));\n            return hsh == bhsh;\n        };\n        \n        int mn = n * m * 4;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (isp(1, 1, i, j)) mn = min(mn, (2 * n - i) * (2 * m - j));\n                if (isp(1, j, i, m)) mn = min(mn, (2 * n - i) * (m + j - 1));\n                if (isp(i, 1, n, j)) mn = min(mn, (n + i - 1) * (2 * m - j));\n                if (isp(i, j, n, m)) mn = min(mn, (n + i - 1) * (m + j - 1));\n            }\n        }\n        \n        cout << mn - m * n << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132A": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132A",
    "problem_title": "A. Homework",
    "time_limit": "1 second",
    "memory_limit": "256 megabytes",
    "statement": "Vlad and Dima have been assigned a task in school for their English class. They were given two strings $$$a$$$ and $$$b$$$ and asked to append all characters from $$$b$$$ to string $$$a$$$ in any order. The guys decided to divide the work between themselves and, after lengthy negotiations, determined who would add each character from string $$$b$$$ to $$$a$$$.Due to his peculiarities, Vlad can only add characters to the beginning of the word, while Dima can only add them to the end. They add characters in the order they appear in string $$$b$$$. Your task is to determine what string Vlad and Dima will end up with.\n\nInputEach test consists of several test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The description of the test cases follows.The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10$$$) — the length of the string $$$a$$$.The second line contains the string $$$a$$$, consisting of lowercase letters of the English alphabet.The third line contains an integer $$$m$$$ ($$$1 \\le m \\le 10$$$) — the length of the strings $$$b$$$ and $$$c$$$.The fourth line contains the string $$$b$$$, consisting of lowercase letters of the English alphabet.The fifth line contains the string $$$c$$$, consisting of the characters'V'and'D'— the distribution of the characters of string $$$b$$$ between Dima and Vlad. If $$$c_i$$$ ='V', then the $$$i$$$-th letter is added by Vlad; otherwise, it is added by Dima.\n\nOutputFor each test case, output the string that will result from Dima and Vlad's work.",
    "sample_inputs": [
      "42ot2adDV3efo7rdcoecsDVDVDVD3aca4bbaaDVDV3biz4abonVVDD"
    ],
    "sample_outputs": [
      "dota\ncodeforces\nabacaba\nbabizon"
    ],
    "notes": "NoteIn the first test case, there is initially a string $$$ot$$$. Then Dima appends the character $$$a$$$ to the end of the string, resulting in $$$ota$$$, and Vlad appends the last character, resulting in $$$dota$$$.In the second test case, the string will change as follows: $$$efo \\rightarrow efor \\rightarrow defor \\rightarrow deforc \\rightarrow odeforc \\rightarrow odeforce \\rightarrow codeforce \\rightarrow codeforces$$$In the third test case: $$$aca \\rightarrow acab \\rightarrow bacab \\rightarrow bacaba \\rightarrow abacaba$$$In the fourth test case: $$$biz \\rightarrow abiz \\rightarrow babiz \\rightarrow babizo \\rightarrow babizon$$$",
    "tags": [
      "brute force",
      "implementation",
      "strings",
      "*800"
    ],
    "url": "https://codeforces.com/problemset/problem/2132/A",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve() {\n    string a, b, c;\n    int n, m;\n    cin >> n >> a;\n    cin >> m >> b >> c;\n    string add_left = \"\";\n    for (int i = 0; i < m; ++i) {\n        if (c[i] == 'V') {\n            add_left += b[i];\n        } else {\n            a += b[i];\n        }\n    }\n    reverse(add_left.begin(), add_left.end());\n    cout << add_left + a << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve() {\n    string a, b, c;\n    int n, m;\n    cin >> n >> a;\n    cin >> m >> b >> c;\n    string add_left = \"\";\n    for (int i = 0; i < m; ++i) {\n        if (c[i] == 'V') {\n            add_left += b[i];\n        } else {\n            a += b[i];\n        }\n    }\n    reverse(add_left.begin(), add_left.end());\n    cout << add_left + a << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2138C1": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138C1",
    "problem_title": "C1. Maple and Tree Beauty (Easy Version)",
    "time_limit": "3 seconds",
    "memory_limit": "1024 megabytes",
    "statement": "This is the easy version of the problem. The difference between the versions is that in this version, the constraints on $$$t$$$ and $$$n$$$ are smaller. You can hack only if you solved all versions of this problem.Maple is given a rooted tree consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$, where the root has index $$$1$$$. Each vertex of the tree is labeled either zero or one. Unfortunately, Maple forgot how the vertices are labeled and only remembers that there are exactly $$$k$$$ zeros and $$$n - k$$$ ones.For each vertex, we define thenameof the vertex as the binary string formed by concatenating the labels of the vertices from the root to the vertex. More formally, $$$\\text{name}_1 = \\text{label}_1$$$ and $$$\\text{name}_u = \\text{name}_{p_u} + \\text{label}_u$$$ for all $$$2\\le u\\le n$$$, where $$$p_u$$$ is the parent of vertex $$$u$$$ and $$$+$$$ represents string concatenation.Thebeautyof the tree is equal to the length of the longest common subsequence$$$^{\\text{∗}}$$$ of the names of all theleaves$$$^{\\text{†}}$$$. Your task is to determine the maximum beauty among all labelings of the tree with exactly $$$k$$$ zeros and $$$n - k$$$ ones.$$$^{\\text{∗}}$$$A sequence $$$a$$$ is a subsequence of a sequence $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by the deletion of several (possibly, zero or all) element from arbitrary positions.  The longest common subsequence of strings $$$s_1, s_2, \\ldots s_m$$$ is the longest string that is a subsequence of all of $$$s_1, s_2, \\ldots, s_m$$$.$$$^{\\text{†}}$$$A leaf is any vertex without children.\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 50$$$). The description of the test cases follows.The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\leq n \\leq 1000$$$, $$$0 \\leq k \\leq n$$$) — the number of vertices and the number of vertices labeled with zero, respectively.The second line contains $$$n - 1$$$ integers $$$p_2, p_3, \\ldots, p_{n}$$$ ($$$1 \\leq p_i \\le i - 1$$$) — the parent of vertex $$$i$$$.Note that there areno constraintson the sum of $$$n$$$ over all test cases.\n\nOutputFor each test case, output a single integer representing the maximum beauty among all labelings of the tree with exactly $$$k$$$ zeros and $$$n - k$$$ ones.",
    "sample_inputs": [
      "57 31 1 2 2 3 37 21 1 2 3 1 15 01 2 3 45 21 1 1 15 41 1 1 1",
      "52 012 113 01 13 11 23 11 1"
    ],
    "sample_outputs": [
      "3\n2\n5\n1\n2",
      "2\n2\n2\n3\n2"
    ],
    "notes": "NoteIn the first test case, the maximum beauty is $$$3$$$, when the vertices are labeled with $$$[0, 0, 0, 1, 1, 1, 1]$$$, and the longest common subsequence is001.In the second test case, the maximum beauty is $$$2$$$, when the vertices are labeled with $$$[1, 0, 0, 1, 1, 1, 1]$$$, and the longest common subsequence is11.",
    "tags": [
      "dfs and similar",
      "dp",
      "graphs",
      "trees"
    ],
    "url": "https://codeforces.com/problemset/problem/2138/C1",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "We can first find out that the maximum possible answer is the minimum depth among all leaves $$$d=\\min{dep_u}$$$, as the LCS can't be greater than the minimum length of all names.We consider a special case first where all leaves have the same depth. If we want to achieve the maximum answer $$$d$$$, the names of all leaves should be exactly the same. Which means, for any two vertices with the same depth, their label has to be the same.For each depth $$$i$$$, we group all vertices with depth $$$i$$$ together as the $$$i$$$-th group (suppose root has depth $$$1$$$). For each group, all vertices in the group should have the same label. Let the size of groups $$$1,\\cdots,d$$$ be $$$c_1,\\cdots,c_d$$$. Now the problem can be considered as a knapsack problem, where you have $$$d$$$ items with weight $$$c_1,\\cdots,c_d$$$. We need to find out whether you can take several numbers from $$$c$$$ that have sum equal to $$$k$$$. This can be solved in $$$O(n^2)$$$.If the maximum answer $$$d$$$ is not achievable, we can show that you can always achieve $$$w-1$$$. From for each group from the first to the $$$d$$$-th, we assgin an arbitrary label which still have at least $$$c_i$$$ numbers remaining to all vertices in the group. As all leaves have the same depth, $$$c_d$$$ should be the maximum element in the array, so you are always able to select a label for groups $$$1$$$ to $$$d-1$$$. Then arbitrarily distribute the remaining labels among vertices in the last groups (which are leaves)..Now consider the general case where not all leaves have the same depth. If we want to achieve answer $$$=d$$$, we need to select $$$d$$$ groups. For each leaf vertex $$$v$$$, there should exist a vertex in the $$$d$$$-th group which is an ancestor of $$$v$$$. And for every $$$2\\le i\\le d$$$, for each vertex $$$v$$$ in the $$$i$$$-th group, there should exist a vertex in the $$$i-1$$$-th group which is an ancestor of $$$v$$$. All vertices in the same group should have the same label. Suppose the $$$i$$$-th group has label $$$l_i$$$, then we can achieve $$$\\text{LCS}=l_1l_2\\ldots l_d$$$ which has length $$$d$$$.We can still group all vertices with depth $$$1\\le i\\le d$$$ together as the $$$i$$$-th group. For all vertices with depth $$$>d$$$, we can set their label arbitrarily. We can view them as items with weight $$$1$$$ in the knapsack problem.And we can show this is the optimal way to select $$$d$$$ groups. If some vertex $$$u$$$ with depth $$$\\le d$$$ is not selected, there must be some vertices selected in some group in the subtree of $$$u$$$, because the path from root to $$$u$$$ consists of less than $$$d$$$ vertices. If the smallest group index that some vertex in the subtree of $$$u$$$ belongs to is $$$i$$$, we can instead let $$$u$$$ be inside the $$$i$$$-th group, and then the labels of all vertices in the subtree $$$u$$$ that were previously in group $$$i$$$ can be selected arbitrarily. If we consider the knapsack problem, we have reduced some $$$c_i$$$ by $$$x$$$ and added $$$x$$$ items with weight $$$1$$$. All achievable values still remain achievable, while some previously unachievable values become achievable.The time complexity is $$$O(n^2)$$$, the bottleneck is knapsack.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "// n^2/w\n#include <bits/stdc++.h>\nusing namespace std;\nint solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> fa(n, -1), dep(n, 0);\n    vector<int> noson(n, 1), cnt(n + 1);\n    cnt[0]++;\n    for (int i = 1; i < n; i++) {\n        cin >> fa[i], fa[i]--;\n        dep[i] = dep[fa[i]] + 1;\n        cnt[dep[i]]++;\n        noson[fa[i]] = 0;\n    }\n    int mxdep = 1e9;\n    for (int i = 0; i < n; i++)\n        if (noson[i]) mxdep = min(mxdep, dep[i]);\n \n    int sum = 0;\n \n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    for (int i = 0; i <= mxdep; i++) {\n        for (int j = sum; j >= 0; j--) dp[j + cnt[i]] |= dp[j];\n        sum += cnt[i];\n    }\n    if (sum <= k || sum <= n - k) return mxdep + 1;\n    for (int i = 0; i <= sum; i++)\n        if (dp[i]) {\n            if (i <= k && sum - i <= n - k) return mxdep + 1;\n        }\n    return mxdep;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) cout << solve() << \"\\n\";\n    return 0;\n}",
        "codes": [
          "// n^2/w\n#include <bits/stdc++.h>\nusing namespace std;\nint solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> fa(n, -1), dep(n, 0);\n    vector<int> noson(n, 1), cnt(n + 1);\n    cnt[0]++;\n    for (int i = 1; i < n; i++) {\n        cin >> fa[i], fa[i]--;\n        dep[i] = dep[fa[i]] + 1;\n        cnt[dep[i]]++;\n        noson[fa[i]] = 0;\n    }\n    int mxdep = 1e9;\n    for (int i = 0; i < n; i++)\n        if (noson[i]) mxdep = min(mxdep, dep[i]);\n \n    int sum = 0;\n \n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    for (int i = 0; i <= mxdep; i++) {\n        for (int j = sum; j >= 0; j--) dp[j + cnt[i]] |= dp[j];\n        sum += cnt[i];\n    }\n    if (sum <= k || sum <= n - k) return mxdep + 1;\n    for (int i = 0; i <= sum; i++)\n        if (dp[i]) {\n            if (i <= k && sum - i <= n - k) return mxdep + 1;\n        }\n    return mxdep;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) cout << solve() << \"\\n\";\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139A": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139A",
    "problem_title": "2139A - Maple and Multiplication",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "If $$$a=b$$$ we need $$$0$$$ steps.If $$$a$$$ can be divided by $$$b$$$, we only need $$$1$$$ step, which is to multiply $$$b$$$ by $$$\\frac{a}{b}$$$. Same for the case when $$$b$$$ can be divided by $$$a$$$.Otherwise, we need at most $$$2$$$ steps. As both $$$a$$$ and $$$b$$$ are positive integers, we can first multiply $$$a$$$ by $$$b$$$ and then multiply $$$b$$$ by the original value of $$$a$$$. Both number will be equal to $$$a\\times b$$$.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nint solve(){\n    int a,b;\n    cin >> a >> b;\n    if(a == b) return 0;\n    if(a % b == 0 || b % a == 0) return 1;\n    return 2;\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    int TC;\n    cin >> TC;\n    while(TC --){\n        cout << solve() << '\\n';\n    }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nint solve(){\n    int a,b;\n    cin >> a >> b;\n    if(a == b) return 0;\n    if(a % b == 0 || b % a == 0) return 1;\n    return 2;\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    int TC;\n    cin >> TC;\n    while(TC --){\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n\n\n\n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139B": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139B",
    "problem_title": "2139B - Cake Collection",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "The number of cakes collected from an oven depends only on the last time Maple visits it. Therefore, in the optimal strategy, she should visit distinct ovens in the last $$$\\min(m,n)$$$ seconds.Let's think in reverse: suppose we fix an order $$$p_1,\\dots,p_n$$$ of the ovens. Then at second $$$m$$$ we visit oven $$$p_1$$$, at second $$$m-1$$$ we visit oven $$$p_2$$$, and so on. For the $$$i$$$-th oven in this order, we collect $$$a_{p_i}\\cdot \\max(0, m-i+1)$$$ cakes.To maximize the total number of cakes collected, ovens with larger $$$a_i$$$ should be visited later (i.e., assigned larger multipliers). Thus we sort $$$a$$$ in non-increasing order first.The final answer is $$$\\sum_{i=1}^n a_i \\cdot \\max(0, m-i+1)$$$.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\n \nvoid solve(){\n    int n,t;\n    cin >> n >> t;\n    ll ans = 0;\n    vector <int> a(n);\n    for(int i = 0;i < n;i ++) cin >> a[i];\n    sort(a.begin(),a.begin() + n,greater <int>());\n    for(int i = 0;i < n;i ++) ans += 1ll * a[i] * max(0,t - i);\n    cout << ans << '\\n';\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    int TC;\n    cin >> TC;\n    while(TC --){\n        solve();\n    }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\n \nvoid solve(){\n    int n,t;\n    cin >> n >> t;\n    ll ans = 0;\n    vector <int> a(n);\n    for(int i = 0;i < n;i ++) cin >> a[i];\n    sort(a.begin(),a.begin() + n,greater <int>());\n    for(int i = 0;i < n;i ++) ans += 1ll * a[i] * max(0,t - i);\n    cout << ans << '\\n';\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    int TC;\n    cin >> TC;\n    while(TC --){\n        solve();\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2138A": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138A",
    "problem_title": "2138A - Cake Assignment",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "You can backtrack from the final state.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Denote the state $$$(a,b)$$$ that indicates Chocola has $$$a$$$ cakes and Vanilla has $$$b$$$ cakes.After one operation of type $$$1$$$, Vanilla's number of cakes will definitely be at least half of the total, and similarly for operation $$$2$$$. If $$$0 < a < 2^{k}$$$, then $$$2^{k} < b < 2^{k+1}$$$, meaning the previous operation must have been type $$$1$$$. Similarly, if $$$0 < b < 2^{k}$$$, the previous operation must have been type $$$2$$$.Therefore, you can backtrack from the final state $$$(x,2^{k+1}-x)$$$, until it reaches the initial state $$$(2^k,2^k)$$$.Now let's analyze how many steps we need to do during the process.For the state $$$(a, b)$$$, where $$$a, b \\neq 0$$$, assume $$$a = i \\cdot 2^{p_a}$$$ and $$$b = j \\cdot 2^{p_b}$$$, $$$i$$$ and $$$j$$$ are positive odd integers.Since $$$a + b = 2^{k+1}$$$, it must be true that $$$ 0 \\le p_a = p_b \\le k$$$ , and after one operation $$$1$$$ or $$$2$$$, both $$$p_a$$$ and $$$p_b$$$ decrease by exactly $$$1$$$.Therefore, the whole process takes at most $$$k$$$ steps, so we solve the problem with $$$O(tk)$$$ time complexity.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h> \nusing namespace std;\nint main(){\n    int t; cin>>t;\n    while(t--){\n        long long k,x,kk; cin>>k>>x; kk=1ll<<k;\n        if (!x||x==kk*2) {cout<<\"-1\\n\"; continue;}\n        long long y=kk*2-x;\n        vector<int> ans; ans.clear();\n        while(x!=kk){\n            if (x>y) ans.push_back(2),x-=y,y*=2;\n            else ans.push_back(1),y-=x,x*=2;\n        }\n        cout<<ans.size()<<\"\\n\";\n        while(!ans.empty()) cout<<ans.back()<<' ',ans.pop_back();\n        cout<<\"\\n\";\n    }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h> \nusing namespace std;\nint main(){\n    int t; cin>>t;\n    while(t--){\n        long long k,x,kk; cin>>k>>x; kk=1ll<<k;\n        if (!x||x==kk*2) {cout<<\"-1\\n\"; continue;}\n        long long y=kk*2-x;\n        vector<int> ans; ans.clear();\n        while(x!=kk){\n            if (x>y) ans.push_back(2),x-=y,y*=2;\n            else ans.push_back(1),y-=x,x*=2;\n        }\n        cout<<ans.size()<<\"\\n\";\n        while(!ans.empty()) cout<<ans.back()<<' ',ans.pop_back();\n        cout<<\"\\n\";\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2138B": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138B",
    "problem_title": "2138B - Antiamuny Wants to Learn Swap",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "For array $$$b$$$, we can prove that $$$f(b)\\neq g(b)$$$ if and only if there exists indexes $$$1\\le i<j<k\\le m$$$ which satisfies $$$b_i>b_j>b_k$$$.Since $$$a$$$ is a permutation, all elements in $$$b$$$ should be distinct. $$$g(b)$$$ is equal to the number of inversions in $$$b$$$. When there exists some index $$$i$$$ that satisfies $$$a_i>a_{i+1}>a_{i+2}$$$, we can reduce the number of inversions by $$$3$$$ by applying operation $$$2$$$, allowing $$$f(b)$$$ to become less than $$$g(b)$$$. This is the only case where you can reduce more than $$$1$$$ inversion with one operation.If there exists indexes $$$1\\le i<j<k\\le m$$$ which satisfies $$$b_i>b_j>b_k$$$. We can first choose index $$$i,k$$$, then move all elements greater than $$$b_i$$$ to the right of $$$b_k$$$ and move all elements less than $$$b_k$$$ to the left of $$$b_i$$$ by swapping adjacent numbers (applying the first operation). Now all elements $$$b_p$$$ between $$$b_i,b_k$$$ satisfy $$$b_i>b_p>b_k$$$. We then swap them to the left of $$$b_i$$$ until there is only one element $$$b_j$$$ left. Now $$$b_i>b_j>b_k$$$ and they are adjacent, and we can apply operation $$$2$$$ on the current index of $$$b_i$$$.If we only apply operation 1 on indexes $$$i$$$ which satisfy $$$b_i>b_{i+1}$$$, there will never exist any index $$$i$$$ satisfying $$$b_i>b_{i+1}>b_{i+2}$$$ in $$$b$$$ during the process. If we apply an operation $$$1$$$ on some index $$$i$$$ where $$$b_i<b_{i+1}$$$, the number of inversions will be increased by $$$1$$$ instead of decreased by $$$1$$$, which makes it impossible to reach $$$f(b)<g(b)$$$ with one operation $$$2$$$, even i it decreases number of inversions by $$$3$$$. Therefore, in this case $$$f(b)=g(b)$$$.For each element $$$a_i$$$, we define:  $$$l_i$$$: the maximum index $$$< i$$$ such that $$$a_{l_i} > a_i$$$, $$$r_i$$$: the minimum index $$$> i$$$ such that $$$a_{r_i} < a_i$$$. Then the answer to a query $$$[l, r]$$$ is $$$\\texttt{NO}$$$ if and only if some segment $$$[l_i, r_i]$$$ lies fully inside $$$[l, r]$$$.To answer multiple queries, you can preprocess the smallest $$$r$$$ for every $$$l$$$ such that the answers for all $$$[l,x](x\\ge r)$$$ should be $$$\\texttt{NO}$$$.The time complexity is $$$O(n)$$$ if you find $$$l_i,r_i$$$ with the Monotonic Stack trick. $$$O(n\\log n)$$$ solutions can also pass.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n + 2);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n \n    vector<int> mxl(n + 1), mir(n + 1);\n    for (int i = 1; i <= n; i++)\n    {\n        mxl[i] = i - 1;\n        while (mxl[i] > 0 && a[mxl[i]] < a[i])\n            mxl[i] = mxl[mxl[i]];\n    }\n    for (int i = n; i >= 1; i--)\n    {\n        mir[i] = i + 1;\n        while (mir[i] <= n && a[mir[i]] > a[i])\n            mir[i] = mir[mir[i]];\n    }\n    vector<int> L(n + 1, 0);\n    for (int i = 2; i < n; i++)\n    {\n        if (mxl[i] > 0 && mir[i] <= n)\n        {\n            L[mir[i]] = max(L[mir[i]], mxl[i]);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        L[i] = max(L[i], L[i - 1]);\n    }\n \n    for (int i = 0; i < q; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        if (l <= L[r])\n            cout << \"NO\\n\";\n        else\n            cout << \"YES\\n\";\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        solve();\n    }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n + 2);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n \n    vector<int> mxl(n + 1), mir(n + 1);\n    for (int i = 1; i <= n; i++)\n    {\n        mxl[i] = i - 1;\n        while (mxl[i] > 0 && a[mxl[i]] < a[i])\n            mxl[i] = mxl[mxl[i]];\n    }\n    for (int i = n; i >= 1; i--)\n    {\n        mir[i] = i + 1;\n        while (mir[i] <= n && a[mir[i]] > a[i])\n            mir[i] = mir[mir[i]];\n    }\n    vector<int> L(n + 1, 0);\n    for (int i = 2; i < n; i++)\n    {\n        if (mxl[i] > 0 && mir[i] <= n)\n        {\n            L[mir[i]] = max(L[mir[i]], mxl[i]);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        L[i] = max(L[i], L[i - 1]);\n    }\n \n    for (int i = 0; i < q; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        if (l <= L[r])\n            cout << \"NO\\n\";\n        else\n            cout << \"YES\\n\";\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        solve();\n    }\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2138C2": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138C2",
    "problem_title": "2138C2 - Maple and Tree Beauty (Hard Version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "We focus on optimizing the knapsack problem. In the knapsack problem we only need to know $$$f_i=0/1$$$ which means whether you can achieve sum $$$i$$$, so we can optimize the knapsack with bitset. The time complexity is $$$O(\\frac{n^2}{\\omega})$$$ which is enough to pass E2.But actually we can do better. For the knapsack problem, it has at most $$$n$$$ items, and the sum of weights of all items is also at most $$$n$$$. We can do a sqrt decomposition trick here.   For items with weight $$$\\ge\\sqrt{n}$$$, there are at most $$$\\sqrt{n}$$$ such items. For items with weight $$$<\\sqrt{n}$$$, we count the number of items for each different weight. If there are $$$c_w$$$ items for weight $$$w$$$, we decompose $$$x$$$ into $$$c_w=2^0+2^1+\\cdots+2^k+y$$$ where $$$k$$$ is the largest integer satisfying $$$2^0+2^1+\\ldots+2^k\\le c_w$$$. Then we create new items new items with weights $$$2^0\\cdot w,2^1\\cdot w,\\ldots,2^k\\cdot w,y\\cdot w$$$. The set of new items is same as $$$c_w$$$ items with weight $$$w$$$ if we only consider the different sum of weights the set of items can achieve. Now we only have $$$\\sum_{w=1}^{\\sqrt{n}}\\log(c_w)=\\sqrt{n}$$$ items. The total time complexity is $$$O(\\sqrt{n}\\cdot n+\\sqrt{n}\\cdot n)=O(n\\sqrt{n})$$$.And this can also be optimized with bitset, leading to an $$$O(\\frac{n\\sqrt{n}}{\\omega})$$$ solution.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "// nsqrtn/w\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\ntemplate <int maxn>\nint solve(int n, int k) {\n    if (maxn <= n) {\n        return solve<min(N, maxn * 2)>(n, k);\n    }\n    bitset<maxn> dp;\n    vector<int> fa(n, -1), dep(n, 0);\n    vector<int> noson(n, 1), cnt(n + 1);\n    cnt[0]++;\n    for (int i = 1; i < n; i++) {\n        cin >> fa[i], fa[i]--;\n        dep[i] = dep[fa[i]] + 1;\n        cnt[dep[i]]++;\n        noson[fa[i]] = 0;\n    }\n    dp.reset();\n    dp[0] = 1;\n    int mxdep = 1e9;\n    for (int i = 0; i < n; i++)\n        if (noson[i]) mxdep = min(mxdep, dep[i]);\n \n    int sum = 0;\n    vector<int> all(cnt.begin(), cnt.begin() + mxdep + 1);\n    sort(all.begin(), all.end());\n    vector<int> v;\n    for (int i = 0; i < (int)all.size(); i++) {\n        int j = i;\n        while (j + 1 < (int)all.size() && all[i] == all[j + 1]) j++;\n        int t = j - i + 1;\n        for (int z = 1; z <= t; z *= 2) {\n            v.push_back(z * all[i]);\n            t -= z;\n        }\n        if (t > 0) v.push_back(t * all[i]);\n        i = j;\n    }\n    dp[0] = 1;\n    for (auto val : v) {\n        sum += val;\n        dp |= (dp << val);\n    }\n    if (sum <= k || sum <= n - k) return mxdep + 1;\n    for (int i = 0; i <= sum; i++)\n        if (dp[i]) {\n            if (i <= k && sum - i <= n - k) return mxdep + 1;\n        }\n    return mxdep;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, k;\n        cin >> n >> k;\n        cout << solve<1>(n, k) << \"\\n\";\n    }\n    return 0;\n}",
        "codes": [
          "// nsqrtn/w\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\ntemplate <int maxn>\nint solve(int n, int k) {\n    if (maxn <= n) {\n        return solve<min(N, maxn * 2)>(n, k);\n    }\n    bitset<maxn> dp;\n    vector<int> fa(n, -1), dep(n, 0);\n    vector<int> noson(n, 1), cnt(n + 1);\n    cnt[0]++;\n    for (int i = 1; i < n; i++) {\n        cin >> fa[i], fa[i]--;\n        dep[i] = dep[fa[i]] + 1;\n        cnt[dep[i]]++;\n        noson[fa[i]] = 0;\n    }\n    dp.reset();\n    dp[0] = 1;\n    int mxdep = 1e9;\n    for (int i = 0; i < n; i++)\n        if (noson[i]) mxdep = min(mxdep, dep[i]);\n \n    int sum = 0;\n    vector<int> all(cnt.begin(), cnt.begin() + mxdep + 1);\n    sort(all.begin(), all.end());\n    vector<int> v;\n    for (int i = 0; i < (int)all.size(); i++) {\n        int j = i;\n        while (j + 1 < (int)all.size() && all[i] == all[j + 1]) j++;\n        int t = j - i + 1;\n        for (int z = 1; z <= t; z *= 2) {\n            v.push_back(z * all[i]);\n            t -= z;\n        }\n        if (t > 0) v.push_back(t * all[i]);\n        i = j;\n    }\n    dp[0] = 1;\n    for (auto val : v) {\n        sum += val;\n        dp |= (dp << val);\n    }\n    if (sum <= k || sum <= n - k) return mxdep + 1;\n    for (int i = 0; i <= sum; i++)\n        if (dp[i]) {\n            if (i <= k && sum - i <= n - k) return mxdep + 1;\n        }\n    return mxdep;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, k;\n        cin >> n >> k;\n        cout << solve<1>(n, k) << \"\\n\";\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139D": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139D",
    "problem_title": "2139D - Antiamuny and Slider Movement",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "Let’s define $$$b_i$$$ as the position of the $$$i$$$-th slider decreased by $$$i$$$. Every operation on the sliders can be interpreted as a modification of the array $$$b$$$.  If we increase the position of slider $$$i$$$, then $$$b_i$$$ increases. At the same time, every suffix element $$$b_{i+1}, b_{i+2}, \\dots, b_n$$$ gets updated to $$$b_j := \\max(b_j, b_i)$$$. If we decrease the position of slider $$$i$$$, then $$$b_i$$$ decreases. At the same time, every prefix element $$$b_1, b_2, \\dots, b_{i-1}$$$ gets updated to $$$b_j := \\min(b_j, b_i)$$$. Since the array $$$b$$$ always remains non-decreasing, we can reinterpret operations as follows:  Every operation simultaneously applies a $$$\\min$$$ operation to all elements on the left, and a $$$\\max$$$ operation to all elements on the right. For a fixed slider $$$b_i$$$, the effect of each operation on the slider should be one of the following:  $$$b_i := \\max(b_i, x)$$$ $$$b_i := \\min(b_i, x)$$$ $$$b_i := x$$$ (assignment) Our task is to compute the sum of final values of $$$b_i$$$ after all possible sequences of operations.We sort all operations by their parameter $$$x$$$. If multiple operations share the same $$$x$$$, we give them a consistent order and then assume all $$$x$$$ are distinct in the following part of the editorial.We first suppose that the position of the slider is changed at least once. Suppose the final value for slider $$$i$$$ is $$$b_e$$$, let’s consider which operation sets $$$b_i = b_e$$$ at the very end.At this point, we no longer care about the exact value of $$$b_i$$$ during the process — only whether it is less than, equal to, or greater than $$$b_e$$$.All operations of type $$$\\max$$$ with $$$x < b_e$$$ and type $$$\\min$$$ with $$$x > b_e$$$ are irrelevant. We can insert them anywhere after deciding the order of other operations without affecting the result. We won't consider these operations in the following parts of the editorial.All assignment operations $$$b_i := x$$$ can be reinterpreted:  If $$$x < b_e$$$, treat it as $$$b_i := \\min(b_i, x)$$$. If $$$x > b_e$$$, treat it as $$$b_i := \\max(b_i, x)$$$. The last operation, that makes $$$b_i = b_e$$$ must be the one with parameter $$$x = b_e$$$.  If this operation is assignment, then all other operations can appear in any order. If this operation is $$$\\max$$$ type, then immediately before it we must have $$$b_i < b_e$$$.   Either the last preceding valid operation is some $$$\\min$$$ type operation making $$$b_i < b_e$$$;    Or no other effective operation occurs, and the initial value of $$$b_i$$$ was already smaller than $$$b_e$$$.  If this operation is $$$\\min$$$ type operation, it is symmetric: either the last preceding valid operation is a $$$\\max$$$ type operation, or the initial value of $$$b_i$$$ was already larger than $$$b_e$$$. Finally, don’t forget the case where a slider is never touched, where it simply keeps its initial value.For each of the $$$n$$$ sliders, we need to check contributions over all $$$m$$$ operations. The overall time complexity is $$$O(nm)$$$.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=1000000007;\nlong long a[5000],ans[5000],tt[5001],inv[5001];\nstruct apos{\n\tlong long id;\n\tlong long x;\n\tfriend bool operator<(apos a,apos b){\n\t\treturn a.x<b.x;\n\t}\n}ap[5000];\nint main(){\n\tios::sync_with_stdio(false),cin.tie(0);\n\tint T,flag;\n\tlong long n,m,p,q,x,i,j,cl,cr;\n\ttt[0]=1;\n\tfor(i=1;i<=5000;i++)tt[i]=tt[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(i=2;i<=5000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(cin>>T;T>0;T--)\n\t{\n\t\tcin>>n>>m>>p;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>a[i];\n\t\t\ta[i]-=i;\n\t\t}\n\t\tfor(i=0;i<p;i++)\n\t\t{\n\t\t\tcin>>ap[i].id>>ap[i].x;\n\t\t\tap[i].id--;\n\t\t\tap[i].x-=ap[i].id;\n\t\t}\n\t\tsort(ap,ap+p);\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tflag=0;\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i&&ap[j].x>=a[i])flag=1;\n\t\t\t\tif(ap[j].id>=i&&ap[j].x<a[i])flag=1;\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\tans[i]=a[i]+i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i]=0;\n\t\t\tcl=0;\n\t\t\tcr=0;\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i)cr++;\n\t\t\t}\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i)cr--;\n\t\t\t\tif(ap[j].id==i)ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1])%mod;\n\t\t\t\tif(ap[j].id<i)\n\t\t\t\t{\n\t\t\t\t\tif(cl==0&&cr==0&&a[i]<=ap[j].x)ans[i]=(ans[i]+ap[j].x+i)%mod;\n\t\t\t\t\telse ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1]%mod*inv[cl+cr]%mod*cl)%mod;\n\t\t\t\t}\n\t\t\t\tif(ap[j].id>i)\n\t\t\t\t{\n\t\t\t\t\tif(cl==0&&cr==0&&a[i]>ap[j].x)ans[i]=(ans[i]+ap[j].x+i)%mod;\n\t\t\t\t\telse ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1]%mod*inv[cl+cr]%mod*cr)%mod;\n\t\t\t\t}\n\t\t\t\tif(ap[j].id>=i)cl++;\n\t\t\t}\n\t\t}\n\t\tfor(int x = 0;x < n;x ++)\n\t\t{\n\t\t\tcout<<ans[x]*tt[p]%mod<<' ';\n\t\t}\n\t\tcout<<'\\n';\n\t}\n\treturn 0;\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=1000000007;\nlong long a[5000],ans[5000],tt[5001],inv[5001];\nstruct apos{\n\tlong long id;\n\tlong long x;\n\tfriend bool operator<(apos a,apos b){\n\t\treturn a.x<b.x;\n\t}\n}ap[5000];\nint main(){\n\tios::sync_with_stdio(false),cin.tie(0);\n\tint T,flag;\n\tlong long n,m,p,q,x,i,j,cl,cr;\n\ttt[0]=1;\n\tfor(i=1;i<=5000;i++)tt[i]=tt[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(i=2;i<=5000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(cin>>T;T>0;T--)\n\t{\n\t\tcin>>n>>m>>p;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>a[i];\n\t\t\ta[i]-=i;\n\t\t}\n\t\tfor(i=0;i<p;i++)\n\t\t{\n\t\t\tcin>>ap[i].id>>ap[i].x;\n\t\t\tap[i].id--;\n\t\t\tap[i].x-=ap[i].id;\n\t\t}\n\t\tsort(ap,ap+p);\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tflag=0;\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i&&ap[j].x>=a[i])flag=1;\n\t\t\t\tif(ap[j].id>=i&&ap[j].x<a[i])flag=1;\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\tans[i]=a[i]+i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i]=0;\n\t\t\tcl=0;\n\t\t\tcr=0;\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i)cr++;\n\t\t\t}\n\t\t\tfor(j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(ap[j].id<=i)cr--;\n\t\t\t\tif(ap[j].id==i)ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1])%mod;\n\t\t\t\tif(ap[j].id<i)\n\t\t\t\t{\n\t\t\t\t\tif(cl==0&&cr==0&&a[i]<=ap[j].x)ans[i]=(ans[i]+ap[j].x+i)%mod;\n\t\t\t\t\telse ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1]%mod*inv[cl+cr]%mod*cl)%mod;\n\t\t\t\t}\n\t\t\t\tif(ap[j].id>i)\n\t\t\t\t{\n\t\t\t\t\tif(cl==0&&cr==0&&a[i]>ap[j].x)ans[i]=(ans[i]+ap[j].x+i)%mod;\n\t\t\t\t\telse ans[i]=(ans[i]+(ap[j].x+i)*inv[cl+cr+1]%mod*inv[cl+cr]%mod*cr)%mod;\n\t\t\t\t}\n\t\t\t\tif(ap[j].id>=i)cl++;\n\t\t\t}\n\t\t}\n\t\tfor(int x = 0;x < n;x ++)\n\t\t{\n\t\t\tcout<<ans[x]*tt[p]%mod<<' ';\n\t\t}\n\t\tcout<<'\\n';\n\t}\n\treturn 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139E1": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139E1",
    "problem_title": "2139E1 - Determinant Construction (Easy Version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution 1",
        "text": "Thanks to jqdai0815 for his significant contribution to this solution. Step 1We can consider transforming the construction of a matrix into the construction of a directed graph, as the determinant and permutations are closely related to the cycle covers of a directed graph.If we have a directed graph with $$$n$$$ vertices, a cycle cover is a set of $$$n$$$ edges such that each vertex has exactly one incoming edge and one outgoing edge in this set (self-loops are allowed). In other words, these $$$n$$$ edges form one or more cycles that together cover all vertices in the graph.In a complete directed graph (with self-loops), every permutation of the vertices determines a cycle cover and vice versa. (The cycles of the permutation are precisely the cycles in the cover.)We consider the definition of the determinant: $$$ \\det(M)=\\sum_{\\begin{subarray}{c}B=(b_{0},\\ldots,b_{n-1})\\\\ B\\in\\mathcal{P}_{n}\\end{subarray}}(-1)^{\\mathrm{inv}(B)}\\cdot\\prod_{i=0}^{n-1}m_ {i,b_{i}} $$$This summation goes over all permutations $$$B$$$, in other words, over all cycle covers of the directed graph determined by the adjacency matrix $$$M$$$. We can also interpret $$$m_{i,j}=0$$$ as \"the edge from $$$i$$$ to $$$j$$$ does not exist at all\". Thus, the product term $$$\\prod_{i=0}^{n-1}m_ {i,b_{i}}$$$ is non-zero only if all $$$m_ {i,b_{i}} \\neq 0$$$, which corresponds to the existence of a cycle cover in the graph.We want to construct a directed graph such that the sum of the weights of its cycle covers equals $$$x$$$. Since the current problem only allows the use of $$$-1, 0, 1$$$, the edge weights can only be $$$1$$$ or $$$-1$$$, and the contribution of a valid cycle cover to the answer can only be $$$1$$$ or $$$-1$$$.PS: You can refer to pages 56-58 of https://ipsc.ksp.sk/2012/real/solutions/booklet.pdf for more information. Step 2There might be many ways to construct a legal directed graph. We will demonstrate a method that transforms the problem into constructing a DAG with exactly $$$x$$$ paths from source vertex $$$1$$$ to sink vertex $$$n$$$.For a directed acyclic graph $$$G$$$ with source vertex $$$1$$$ and sink vertex $$$n$$$, we can construct the following adjacency matrix:  $$$g_{i,j} = -1$$$ if there is an edge $$$i \\rightarrow j$$$ in $$$G$$$. Set the weight of all original edges in $$$G$$$ to $$$-1$$$. $$$g_{i,i} = 1$$$ for all $$$1 < i < n$$$. Add a self-loop with weight $$$1$$$ to all vertices in $$$G$$$ except the source and sink. $$$g_{n,1} = 1$$$. Add an edge from the sink to the source with weight $$$1$$$. Everything else $$$= 0$$$. We analyze all cycle covers of this new graph. Due to the presence of the edge $$$n \\rightarrow 1$$$ , any cycle cover must contain a main cycle that includes nodes $$$1$$$ and $$$n$$$, formed by a path $$$P$$$ from $$$1$$$ to $$$n$$$ in $$$G$$$ and the edge $$$n \\rightarrow 1$$$. For nodes not on path $$$P$$$ (i.e., intermediate nodes not covered by path $$$P$$$), they must be covered by self-loops with weight $$$1$$$. Therefore, each cycle cover uniquely corresponds to a path $$$P$$$ from $$$1$$$ to $$$n$$$.Since there are $$$x$$$ paths in $$$G$$$, we only need to ensure that the contribution of each cycle cover is $$$1$$$ to obtain a determinant value of $$$x$$$. Next, we will analyze how to achieve this by setting the weight of all original edges in $$$G$$$ to $$$-1$$$.For each cycle cover, first consider the product of all edge weights:  The main cycle has $$$k$$$ edges, among which $$$k-1$$$ edges come from path $$$P$$$ (each with weight $$$-1$$$), and one edge is $$$n \\rightarrow 1$$$ (with weight $$$1$$$). Thus, the product term is $$$(-1)^{k-1}$$$. The weights of all other self-loops are $$$1$$$. Therefore, the product of all edge weights is $$$(-1)^{k-1}$$$.Then we consider the sign term $$$(-1)^{\\mathrm{inv}(B)}$$$. In fact, the parity of the number of inversions $$$\\mathrm{inv}(B)$$$ in the permutation is consistent with the parity of the number of even cycles in the permutation. The main cycle is a cycle of length $$$k$$$, and the self-loops are all cycles of length $$$1$$$. Therefore, the sign term is $$$(-1)^{k-1}$$$.Thus, the contribution of each cycle cover is $$$(-1)^{k-1} \\cdot (-1)^{k-1}=1$$$.Due to the constraints in the problem that the matrix size is at most $$$80$$$ and there are at most $$$3$$$ non-zero entries per row and column, we need to construct a DAG that satisfies:  Exactly $$$x$$$ paths from source vertex $$$1$$$ to sink vertex $$$n$$$. At most $$$80$$$ nodes. The in-degree of each node $$$\\le 2$$$ and the out-degree of each node $$$\\le 2$$$.  Step 3Since $$$80$$$ is a loose boundary, there might be many constructions that satisfy it. We will introduce a construction method that encodes $$$x$$$ in base three.The basic unit shown in the figure can form a base-three digit because the number of paths from $$$1$$$ to $$$3$$$ is $$$2$$$, and from $$$1$$$ to $$$4$$$ is $$$3$$$. Node $$$4$$$ can be connected to the next unit, forming a chain of units, where each unit corresponds to a base-three digit. Nodes $$$3$$$ and $$$4$$$ have one free out-degree, which can contribute to the final answer.The example figure below shows how to construct $$$22=1+3+2 \\cdot 3^2$$$ in this way. There are $$$\\log_3 n$$$ basic units, each with $$$4$$$ nodes. The answer chain has at most $$$\\log_3 n$$$ nodes. Therefore, the total number of nodes is $$$5\\log_3 n + O(1)$$$, which can pass the problem. Code (C++)#include<bits/stdc++.h> \nusing namespace std;\nconst int N=81;\nint a[N][N];\nvector<pair<int,int>> e;\nvoid add(int x,int y){\n    e.push_back({x,y});\n}\nvoid make_matrix(int n){\n    for(int i=2;i<n;++i) a[i][i]=1;\n    a[n][1]=1;\n    for(auto [x,y]:e) a[x][y]=-1;\n}\nint main(){\n    int _; scanf(\"%d\",&_); //cin>>_;\n    int max_bit=15;\n    while(_--){\n        memset(a,0,sizeof(a)); e.clear();\n        int n=1;\n        for(int i=0;i<max_bit;++i){\n            add(n,n+1); add(n+1,n+2); add(n+2,n+3); add(n+3,n+4);\n            add(n+1,n+3); add(n+2,n+4);\n            n+=4;\n        }\n        int x,bit_1=1,bit_2=4; scanf(\"%d\",&x); ++n;\n        for(int i=0;i<max_bit;++i){\n            if (x%3==1) add(bit_1,n),add(n,n+1),++n;\n            if (x%3==2) add(bit_2,n),add(n,n+1),++n;\n            bit_1+=4; bit_2+=4; x/=3;\n        }\n        make_matrix(n);\n        cout << n <<'\\n';\n        for (int r = 1; r <= n; r++) {\n            for (int c = 1; c <= n; c++) {\n                printf(\"%d \",a[r][c]);\n            }\n            cout << '\\n';\n        }\n    }\n}",
        "codes": [
          "#include<bits/stdc++.h> \nusing namespace std;\nconst int N=81;\nint a[N][N];\nvector<pair<int,int>> e;\nvoid add(int x,int y){\n    e.push_back({x,y});\n}\nvoid make_matrix(int n){\n    for(int i=2;i<n;++i) a[i][i]=1;\n    a[n][1]=1;\n    for(auto [x,y]:e) a[x][y]=-1;\n}\nint main(){\n    int _; scanf(\"%d\",&_); //cin>>_;\n    int max_bit=15;\n    while(_--){\n        memset(a,0,sizeof(a)); e.clear();\n        int n=1;\n        for(int i=0;i<max_bit;++i){\n            add(n,n+1); add(n+1,n+2); add(n+2,n+3); add(n+3,n+4);\n            add(n+1,n+3); add(n+2,n+4);\n            n+=4;\n        }\n        int x,bit_1=1,bit_2=4; scanf(\"%d\",&x); ++n;\n        for(int i=0;i<max_bit;++i){\n            if (x%3==1) add(bit_1,n),add(n,n+1),++n;\n            if (x%3==2) add(bit_2,n),add(n,n+1),++n;\n            bit_1+=4; bit_2+=4; x/=3;\n        }\n        make_matrix(n);\n        cout << n <<'\\n';\n        for (int r = 1; r <= n; r++) {\n            for (int c = 1; c <= n; c++) {\n                printf(\"%d \",a[r][c]);\n            }\n            cout << '\\n';\n        }\n    }\n}"
        ]
      },
      {
        "title": "solution 2",
        "text": "Step 1We can consider using Tridiagonal Matrices, where the advantage lies in transforming the calculation of the determinant value into a recursive formula.Let $$$d_{i,j}$$$ denote the element in the i-th row and j-th column of matrix $$$D$$$, $$$D_k$$$ represents the submatrix composed of the upper-left $$$k \\times k$$$ elements, and $$$A_k$$$ denotes the determinant value of $$$D_k$$$.When $$$k \\ge 2$$$, there are two ways to obtain $$$D_{k+1}$$$ from $$$D_k$$$:  Let $$$ d_{k+1,k+1}=1, d_{k+1,k}=1,d_{k,k+1}=1$$$ to get $$$A_{k+1}=A_k-A_{k-1}$$$ Let $$$ d_{k+1,k+1}=1, d_{k+1,k}=1,d_{k,k+1}=-1$$$ to get $$$A_{k+1}=A_k+A_{k-1}$$$ Thus, we transform the problem into constructing a sequence $$$A_1,\\ldots,A_m$$$ satisfying:  $$$A_1 = |D_1|, A_2 = |D_2|$$$ For any $$$k=2,3,\\ldots,m-1$$$, one of the following two equations holds: $$$A_{k+1}=A_k-A_{k-1}$$$, or $$$A_{k+1}=A_k+A_{k-1}$$$ $$$A_m=n (m \\le 80)$$$  Step 2Consider recursively generating the entire sequence from $$$A_m=n$$$ backwards.  Choose a positive integer as $$$A_{m−1}$$$. At a certain moment, we have $$$A_k$$$ and $$$A_{k+1}$$$, and obtain $$$A_{k−1}$$$ as follows:If $$$A_k > A_{k+1}$$$, let $$$A_{k-1}=A_k-A_{k+1}$$$; otherwise, let $$$A_{k-1}=A_{k+1}-A_k$$$This ensures that each number in the sequence is a non-negative integer. If at some point there exist $$$D_1,D_2$$$ satisfying $$$A_k = |D_1|, A_{k+1} = |D_2|$$$, successfully finish the construction. For example,if we have $$$A_m=7$$$ and $$$A_{m−1}=3$$$, the final sequence will be $$$1,2,3,1,4,3,7$$$, and we will generate the matrix as $$$\\begin{pmatrix} 1 & -1 & 0 & 0 & 0 & 0 & 0 \\\\ 1 & 1 & -1 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & 1 & 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 1 & -1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 1 & -1 \\\\ 0 & 0 & 0 & 0 & 0 & 1 & 1 \\end{pmatrix}$$$Denote $$$(A_k,A_{k+1})=(x,y)$$$.When $$$x>y$$$, the recursion process can be written as $$$(x,y) \\rightarrow (x-y,x) \\rightarrow (y,x-y)$$$, increasing the length of the sequence by $$$2$$$, completing one iteration of subtraction.When $$$x \\le y$$$, the recursion process can be written as $$$(x,y) \\rightarrow (y-x,x)$$$, increasing the length of the sequence by $$$1$$$, completing one iteration of subtraction.The process will eventually lead to $$$(x,0)$$$ or $$$(0,x)$$$, where $$$x$$$ is the GCD of $$$A_m$$$ and $$$A_{m−1}$$$.When $$$A_m$$$ and $$$A_{m−1}$$$ are coprime, we have $$$x=1$$$, meeting the requirements for the sequence. In fact, we can stop earlier when $$$(1,2)$$$, and the sequence is still legal.When $$$A_m$$$ and $$$A_{m−1}$$$ are not coprime, we have $$$x>1$$$, and this method can't obtain a sequence that meets the requirements. Step 3Given $$$A_m=n$$$, we need to find a suitable $$$A_{m−1}$$$ such that the length of the final sequence is less than or equal to $$$80$$$.Since $$$80$$$ is a relaxed constraint, and you only need to find one valid $$$A_{m−1}$$$, you can try various approaches. For example, you could enumerate all possibilities within the range $$$[1, n-1]$$$ for some large $$$n$$$, and then discover that there are many valid $$$A_{m−1}$$$ values that meet the criteria. If you randomly search for $$$A_{m−1}$$$ within the range, the expected number of attempts required is very low. In fact, the verification program tested all integers $$$n$$$ from $$$10$$$ to $$$10^7$$$, randomly selecting $$$1000$$$ possible $$$A_{m−1}$$$ values for each n and testing them. The results showed that in the worst case (when $$$n = 9827370$$$), there were still $$$24$$$ valid $$$A_{m−1}$$$ values that met the requirements out of the $$$1000$$$ randomly chosen values. Code (C++)Code: #include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=80){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[105][105]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main(){\n    int _; cin>>_; mt19937 rd(time(0));\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        while(1){\n            int y=rd()%(n-1)+1;\n            int tmp=work(n,y);\n            if (tmp<=80) {gen(n,y); break;}\n        }\n    }\n    return 0;\n}\nVerification Program: #pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\nint inf=1e9;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=80){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nint main(){\n    mt19937 rd(114514);\n    int n=1e7,minn=1e3;\n    for(int x=n;x>=5;x--){\n        int _=1e3,c=0;\n        while(_--){\n            int y=rd()%(x-1)+1;\n            int tmp=work(x,y);\n            if (tmp<=80) ++c;\n        }\n        if (c<minn) minn=c,cout<<' '<<minn<<' '<<x<<endl;\n        if (x%10000==1) cout<<clock()<<'#'<<x<<endl;\n    }\n    return 0;\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=80){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[105][105]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main(){\n    int _; cin>>_; mt19937 rd(time(0));\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        while(1){\n            int y=rd()%(n-1)+1;\n            int tmp=work(n,y);\n            if (tmp<=80) {gen(n,y); break;}\n        }\n    }\n    return 0;\n}",
          "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\nint inf=1e9;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=80){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nint main(){\n    mt19937 rd(114514);\n    int n=1e7,minn=1e3;\n    for(int x=n;x>=5;x--){\n        int _=1e3,c=0;\n        while(_--){\n            int y=rd()%(x-1)+1;\n            int tmp=work(x,y);\n            if (tmp<=80) ++c;\n        }\n        if (c<minn) minn=c,cout<<' '<<minn<<' '<<x<<endl;\n        if (x%10000==1) cout<<clock()<<'#'<<x<<endl;\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139E2": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139E2",
    "problem_title": "2139E2 - Determinant Construction (Hard Version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "In Solution 2, the first two steps remain consistent with G1, but we need a better method to find a suitable $$$A_{m−1}$$$ such that the length of the final sequence is less than or equal to $$$50$$$. Randomly searching for $$$A_{m−1}$$$ within the range $$$[1, n-1]$$$ may result in TLE.We noticed that if $$$A_{m−1}$$$ and $$$A_m$$$ are two adjacent fibonacci numbers, the sequence will converge rapidly (with a length within $$$40$$$). Although not all $$$A_m=n$$$ are fibonacci numbers, we can still draw inspiration from this.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution a",
        "text": "We attempt to decompose $$$n$$$ as $$$n=a \\cdot \\operatorname{fib}(i)+b \\cdot \\operatorname{fib}(i-1), a,b \\ge 0$$$, where $$$\\operatorname{fib}(i)$$$ denotes the $$$i$$$-th fibonacci number.Then, we set $$$A_{m-1}=a \\cdot \\operatorname{fib}(i-1)+b \\cdot \\operatorname{fib}(i-2)$$$By iterating further, we obtain $$$A_{m-2}=a \\cdot \\operatorname{fib}(i-2)+b \\cdot \\operatorname{fib}(i-3)$$$, $$$\\dots$$$The purpose of this is to make the iteration process rapidly decrease the value in the initial steps, similar to the fibonacci sequence. Intuitively, the larger the $$$i$$$ chosen, the higher the probability of finding a legal $$$A_{m-1}$$$.The author did not provide a rigorous mathematical proof for this, but using a verification program which found a legal $$$A_{m-1}$$$ for all $$$A_m=n \\in [2,10^7]$$$ within one minute. Therefore, it is feasible to prove the correctness of this approach within the data range during the contest. Code (C++)#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=50){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[55][55]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\ntypedef long long ll;\nll fib[55]={1,1};\nll exgcd(ll a,ll b,ll &x,ll &y){\n\tif(!b){\n\t\tx=1; y=0; return a;\n\t}\n\tll d=exgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n\treturn d;\n}\nmap<int,int> mp;\nint main(){\n    for(int i=2;i<=50;++i) fib[i]=fib[i-1]+fib[i-2];\n    int _; cin>>_;\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        if (n<=10){\n            gen(n,n-1); continue;\n        }\n        if (mp[n]) {gen(n,mp[n]); continue;}\n        int noww=0;\n        while(fib[noww]<n) ++noww;\n        int now=noww;\n        while(now>=3){\n            ll a=fib[now-1],b=fib[now-2],x,y,c=n;\n            ll d=exgcd(a,b,x,y);\n            x*=c,y*=c;\n            //find x,y\n            x=(x%b+b)%b;  y=(c-a*x)/b; if (y<0) {--now; continue;}\n            int s=inf,o;\n            while(y>=0){\n                o=fib[now-2]*x+fib[now-3]*y;\n                s=work(n,o);\n                if (s>50) {x+=b,y-=a; continue;}\n                else break;\n            }\n            if (s>50) {--now; continue;}\n            else{\n                gen(n,o); mp[n]=o; break;\n            }\n        }\n        //\n    }\n    return 0;\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=50){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[55][55]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\ntypedef long long ll;\nll fib[55]={1,1};\nll exgcd(ll a,ll b,ll &x,ll &y){\n\tif(!b){\n\t\tx=1; y=0; return a;\n\t}\n\tll d=exgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n\treturn d;\n}\nmap<int,int> mp;\nint main(){\n    for(int i=2;i<=50;++i) fib[i]=fib[i-1]+fib[i-2];\n    int _; cin>>_;\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        if (n<=10){\n            gen(n,n-1); continue;\n        }\n        if (mp[n]) {gen(n,mp[n]); continue;}\n        int noww=0;\n        while(fib[noww]<n) ++noww;\n        int now=noww;\n        while(now>=3){\n            ll a=fib[now-1],b=fib[now-2],x,y,c=n;\n            ll d=exgcd(a,b,x,y);\n            x*=c,y*=c;\n            //find x,y\n            x=(x%b+b)%b;  y=(c-a*x)/b; if (y<0) {--now; continue;}\n            int s=inf,o;\n            while(y>=0){\n                o=fib[now-2]*x+fib[now-3]*y;\n                s=work(n,o);\n                if (s>50) {x+=b,y-=a; continue;}\n                else break;\n            }\n            if (s>50) {--now; continue;}\n            else{\n                gen(n,o); mp[n]=o; break;\n            }\n        }\n        //\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "solution b",
        "text": "We note that for the fibonacci sequence, $$$\\lim_{x \\to \\infty} \\frac{\\operatorname{fib}(x-1)}{\\operatorname{fib}(x)} = \\frac{\\sqrt 5 -1}{2}$$$, which suggests that searching for $$$A_{m-1}$$$ around $$$\\frac{\\sqrt 5 -1}{2}n$$$ might be a promising approach.In fact, directly enumerating $$$A_{m-1}$$$ starting from $$$\\frac{\\sqrt 5 -1}{2}n$$$ and trying each one is a efficient method. The author also verified through a verification program that for all $$$A_m=n \\in [2,10^7]$$$, a legal $$$A_{m-1}$$$ was found within one minute. Thus, it is feasible to prove the correctness of this approach within the data range during the contest.Considering that the time limit for this problem is relatively loose (5s), most attempts to search for $$$A_{m-1}$$$ around $$$\\frac{\\sqrt 5 -1}{2}n$$$ may be able to pass. Code (C++)#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=50){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[55][55]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nmap<int,int> mp;\nint main(){\n    int _; cin>>_;\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        if (mp[n]) {gen(n,mp[n]); continue;}\n        double s=(sqrt(5)-1.0)/2.0;\n        int st=s*n,l=max(1,st),r=n-1;\n        //int l=1,r=n-1;\n        int nowy,nows=50;\n        if (n%2==0){\n            if (l%2==0) ++l;\n            for(int y=l;y<=r;y+=2){\n                int tmp=work(n,y);\n                if (tmp<=nows) {gen(n,y); mp[n]=y; break;}\n            }\n        }\n        else{\n            for(int y=l;y<=r;++y){\n                int tmp=work(n,y);\n                if (tmp<=nows) {gen(n,y); mp[n]=y; break;}\n            }\n        }\n    }\n    return 0;\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint fl[1005],inf=1e9,cnt;\nint work(int x,int y){\n    int ans=0,tmp;\n    while(y&&ans<=50){\n        ++ans; tmp=y;\n        if (x>y) y=x-y; else y=y-x;\n        x=tmp;\n    }\n    if (x>1) return inf;\n    return ans;\n}\nvoid gen(int x,int y){\n    //printf(\"%d\\n\",work(x,y));\n    vector<int> seq; seq.clear(); seq.push_back(x); seq.push_back(y);\n    int tmp;\n    while(!(x==2&&y==1)){\n        tmp=y;\n        if (x>y) y=x-y; else y=y-x;//x=tmp;\n        x=tmp; \n        seq.push_back(y);\n    }\n    int ans[55][55]={0};\n    int pre=seq.back(),n=1; seq.pop_back(); ans[1][1]=1;\n    while(!seq.empty()){\n        ++n;\n        if (seq.back()>pre) ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=-1;\n        else ans[n][n]=1,ans[n][n-1]=1,ans[n-1][n]=1;\n        pre=seq.back(); seq.pop_back();\n    }\n    printf(\"%d\\n\",n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            printf(\"%d \",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nmap<int,int> mp;\nint main(){\n    int _; cin>>_;\n    while(_--){\n        int n; cin>>n;\n        if (n==0) {printf(\"1\\n0\\n\"); continue;}\n        if (n==1) {printf(\"1\\n1\\n\"); continue;}\n        if (mp[n]) {gen(n,mp[n]); continue;}\n        double s=(sqrt(5)-1.0)/2.0;\n        int st=s*n,l=max(1,st),r=n-1;\n        //int l=1,r=n-1;\n        int nowy,nows=50;\n        if (n%2==0){\n            if (l%2==0) ++l;\n            for(int y=l;y<=r;y+=2){\n                int tmp=work(n,y);\n                if (tmp<=nows) {gen(n,y); mp[n]=y; break;}\n            }\n        }\n        else{\n            for(int y=l;y<=r;++y){\n                int tmp=work(n,y);\n                if (tmp<=nows) {gen(n,y); mp[n]=y; break;}\n            }\n        }\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2139F": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2139F",
    "problem_title": "2139F - Ode to the Bridge Builder",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1048 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/146172",
          "full_url": "https://codeforces.com/blog/entry/146172"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "For convenience, we mark the targets point and the points on the initial segment with $$$A(0,0),B(1,0),C(p,q)$$$.The problem asks us to do at most $$$\\left\\lceil 2|AC|\\right\\rceil$$$ moves. This constraint is actually not quite usual. We can first show that the theoretical lower bound should be $$$x=\\left\\lceil |AC|\\right\\rceil+\\left\\lceil |BC|\\right\\rceil−1$$$. We can show we can't get less moves by following: If we have already constructed the final structure, then $$$AC$$$ and $$$BC$$$ should be connected with a path, and we can find a path from $$$A$$$ to $$$C$$$ and a path from $$$B$$$ to $$$C$$$ that don't intersect (except at point $$$C$$$), otherwise the structure can't be built with non-degenerate triangles.And we have to alternate progressing through two paths every time we construct a triangle, otherwise we must draw a line longer than $$$1$$$. The last triangle will cover both paths, so the number of steps will be decreased by one. The optimal path is two straight segments (which is not always possible).Case 1.1: We first try some simple strategies. Two triangles can form a parallelogram, so we can connect $$$AC$$$, choose a point $$$D$$$ on $$$AC$$$ which makes $$$|AD|=\\frac{|AC|}{\\lceil|AC|\\rceil}$$$, which is always in range $$$[0.5,1]$$$ when $$$|AC|\\ge 1$$$. And from $$$\\triangle ADB$$$ we can construct a parallelogram. We draw a line passing $$$D$$$ that is parallel to $$$AB$$$, a line passing $$$B$$$ that is parallel to $$$AC$$$, and they intersects at $$$E$$$. Then we pile up the same parallelogram structure until we reach $$$C$$$. This always works when $$$30^\\circ\\le\\angle CAB\\le60^\\circ$$$.Proof: We first prove that all segments has length between $$$0.5$$$ and $$$1$$$. Because we stack the same parallelogram structure, all segments have length equal to $$$AB,BD$$$ or $$$AD$$$. $$$AB$$$ and $$$AD$$$ already meets the requirement. When $$$30^\\circ\\le\\angle CAB\\le60^\\circ$$$, the length of $$$BD$$$ is at least $$$0.5$$$ as the distance between two parallel lines is at least $$$0.5$$$, and at most $$$1$$$ as $$$AB=1$$$ and $$$\\angle CAB$$$ is never the largest angle in $$$\\triangle DAB$$$. We can calculate that the number of moves we used is $$$2\\left\\lceil |AC|\\right\\rceil-1\\le\\left\\lceil 2|AC|\\right\\rceil$$$ which matches the requirement (for the last parallelogram we only need one triangle).Case 1.2: We can change the way we construct parallelograms (with sides $$$AB,BC$$$) and this method always works when $$$30^\\circ\\le\\angle CBx\\le60^\\circ$$$. The number of moves is $$$\\left\\lceil2|BC|\\right\\rceil\\le \\left\\lceil 2|AC|\\right\\rceil$$$. This case is actually necessary, which will be explained in the following part.Case 2: If $$$\\angle CAB< \\angle CBx<30^\\circ$$$. We first build a point $$$D$$$ which makes $$$AD=1$$$ and $$$\\angle DAB=30^\\circ$$$ and construct $$$\\triangle DAB$$$. We can show that the constraint is actually easier to meet in this situation, because when $$$\\angle CAB<\\angle CBx<30^\\circ$$$, $$$|BC|<|AC|-0.5$$$. With this, $$$\\left\\lceil |AC|\\right\\rceil+\\left\\lceil |BC|\\right\\rceil−1=\\left\\lceil 2|AC|\\right\\rceil-1$$$ always holds, allowing us one extra move.Then we draw a line passing $$$D$$$ parallel to $$$BC$$$. We can show that if $$$\\angle DAB=30^\\circ$$$ and $$$0\\le \\angle CAB\\le 30^\\circ$$$, the distance from $$$D$$$ to line $$$BC$$$ is at least $$$0.5$$$. So all segments with ends on different lines will have length $$$\\ge 0.5$$$.Then we select a point $$$E$$$ on $$$BC$$$, which makes $$$DE=1$$$. We can show that $$$\\sqrt{3}-1\\le |BE|\\le 1$$$ based on some calculations in this case. Then we do a similar parallelogram construction process to $$$C$$$. The total number of moves is $$$2\\left\\lceil |CE|\\right\\rceil+2$$$.There are still two cases here to analyze to prove the number of steps fulfills our requirement. We write $$$|BC|=a+b$$$ where $$$a$$$ is the integer part of $$$|BC|$$$, then we analyze cases about $$$b$$$.  Case 2.1: When $$$b\\ge\\sqrt{3}-1$$$ or $$$b=0$$$, we can show that $$$2\\left\\lceil |AC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil$$$, and $$$\\left\\lceil |AC|\\right\\rceil=\\left\\lceil |BC|\\right\\rceil+1$$$ if $$$|AC|\\ge 2$$$. The number of steps is $$$2\\left\\lceil |EC|\\right\\rceil+2\\le 2\\left\\lceil |BC|\\right\\rceil+2=2\\left\\lceil |AC|\\right\\rceil$$$. Case 2.2: When $$$0<b<\\sqrt{3}-1$$$, we can show that $$$\\left\\lceil |EC|\\right\\rceil=\\left\\lceil |BC|\\right\\rceil-1$$$. Total moves equals to $$$2+2\\left\\lceil |CE|\\right\\rceil=2\\left\\lceil |BC|\\right\\rceil\\le \\left\\lceil |AC|\\right\\rceil+\\left\\lceil |BC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil$$$.  Be careful with small cases where $$$|BC|$$$ is too short, which may make $$$|DF|=|EG|<0.5$$$.Note that there are some cases where $$$\\angle CBx>30^\\circ$$$ and $$$\\angle CAB<30^\\circ$$$, where Case 2 strategy doesn't work. So case 1.2 is required.Case 3: If $$$\\angle CBx>\\angle CAB>60^\\circ$$$. We first build a point $$$D$$$ which makes $$$AD=1$$$ and $$$\\angle DAB=60^\\circ$$$ and construct $$$\\triangle DAB$$$. We write $$$|AC|=a+b$$$ where $$$a$$$ is integer, then we analyze two cases about $$$b$$$.Case 3.1: When $$$b>0.5$$$ or $$$b=0$$$, $$$2\\left\\lceil |AC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil$$$. We begin a same parallelogram construction as Case 1 where the sides of parallelogram are $$$BC,BD$$$. We can show that $$$30^\\circ\\le\\angle CBD\\le60^\\circ$$$. So it is possible to pile up to $$$C$$$ from $$$BD$$$ in $$$2\\left\\lceil |BC|\\right\\rceil-1$$$ moves. And in total we need $$$2\\left\\lceil |BC|\\right\\rceil\\le2\\left\\lceil |AC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil$$$ moves.Case 3.2: When $$$0<b\\le 0.5$$$, $$$2\\left\\lceil |AC|\\right\\rceil=\\left\\lceil 2|AC|\\right\\rceil+1$$$. We instead connect $$$CD$$$ and construct parallelogram with sides $$$DC,DB$$$. We can show that $$$120^\\circ\\le\\angle CDB\\le150^\\circ$$$ so we can still do the parallelogram construction. When $$$|AC|\\ge \\sqrt{3}$$$, $$$\\left\\lceil |CD|\\right\\rceil=\\left\\lceil |AC||\\right\\rceil-1$$$, making the number of moves $$$2\\left\\lceil |CD|\\right\\rceil+1=2\\left\\lceil |AC|\\right\\rceil-1=\\left\\lceil 2|AC|\\right\\rceil$$$. Actually case 1.1 is not required, because it is impossible to construct a testcase where $$$\\angle CAB<60^\\circ, \\angle CBx>60^\\circ,0<b\\le 0.5$$$ and Case 3.2 fails.",
        "codes": []
      },
      {
        "title": "code (c++)",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\nconst db pi = acos(-1.0);\nconst int N = 1000005;\n\ninline int sgn(db x){\n    if(x < 1e-13 && x > -1e-13) return 0;\n    if(x > 0) return 1;\n    return -1;\n}\n\nstruct point{\n    db x,y;\n    point (db _x = 0.0,db _y = 0.0) : x(_x), y(_y) {}\n};\npoint operator + (const point &p1,const point &p2){\n\treturn point(p1.x + p2.x,p1.y + p2.y);\n}\npoint operator - (const point &p1,const point &p2){\n\treturn point(p1.x - p2.x,p1.y - p2.y);\n}\npoint operator * (db x,const point &p){\n\treturn point(x * p.x,x * p.y);\n} \nbool operator == (point x,point y){\n\treturn sgn(x.x - y.x) == 0 && sgn(x.y - y.y) == 0;\n}\n\ninline db dot(point p1,point p2){\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\ninline db det(point p1,point p2){\n\treturn p1.x * p2.y - p2.x * p1.y;\n}\n\ninline db len(point p){\n    return sqrtl(1.0 * p.x * p.x + 1.0 * p.y * p.y);\n}\n\npoint project_point(point x,point ya,point yb){\n\tpoint v = yb - ya;\n\treturn ya + (dot(v,x - ya) / dot(v,v)) * v;\n}\n\ndb distp(point x,point ya,point yb){\n\treturn fabs(det(ya - x,yb - x)) / len(yb - ya);\n}\n\npoint line_circle_intersec_point(point o,point la,point lb){\n\tdb dis = distp(o,la,lb),l;\n\tpoint pj = project_point(o,la,lb);\n\tl = sqrt(1.0 - dis * dis);\n\tpoint ret = pj + (l / len(lb - la)) * (lb - la);\n\treturn ret;\n}\n\ntuple <int,int,int> ans[N];\npoint p[N],target;\nint step;\n\nbool check(int n){\n    set <pair <int,int> > st;\n    st.insert({1,2});\n    if(n > step) return 0;\n    db eps_len = 1e-8,eps_dis = 1e-4;\n    int fl = 0;\n    for(int i = 1;i <= n;i ++){\n        auto [u,v,w] = ans[i];\n        if(u > v) swap(u,v);\n        if(st.find({u,v}) == st.end()) return 0;\n        if(len(p[u] - p[w]) < 0.5 - eps_len || len(p[u] - p[w]) > 1.0 + eps_len) return 0;\n        if(len(p[v] - p[w]) < 0.5 - eps_len || len(p[v] - p[w]) > 1.0 + eps_len) return 0;\n        st.insert({u,w}); st.insert({v,w});\n        if(len(p[w] - target) <= eps_dis) fl = 1;\n    }\n    return 1;\n}\n\nint solve1a(){\n    point dir = target - p[1];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 2;\n    for(int i = 1;i < split;i ++){\n        ++ c; p[c] = p[1] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        // construct one parallelogram\n    }\n    ++ c; p[c] = target;\n    ans[c - 2] = {c - 2,c - 1,c};\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve1b(){\n    point dir = target - p[2];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 2;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[1] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve2(){\n    p[3] = point(sqrt(3.0) / 2,0.5);\n    p[4] = line_circle_intersec_point(p[3],p[2],target);\n    if(len(p[4] - p[2]) > 1)\n        p[4] = p[2] + (1.0 / len(target - p[2])) * (target - p[2]);\n    ans[1] = {1,2,3};\n    ans[2] = {2,3,4};\n    point dir = target - p[4];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 4;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[4] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve3a(){\n    p[3] = point(0.5,sqrt(3.0) / 2);\n    ans[1] = {1,2,3};\n    point dir = target - p[2];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 3;\n    for(int i = 1;i < split;i ++){\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    ++ c; p[c] = target;\n    ans[c - 2] = {c - 2,c - 1,c};\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve3b(){\n    p[3] = point(0.5,sqrt(3.0) / 2);\n    ans[1] = {1,2,3};\n    point dir = target - p[3];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 3;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve(){\n    if(int res = solve1a()) return res;\n    if(int res = solve1b()) return res;\n    if(int res = solve2()) return res;\n    if(int res = solve3a()) return res;\n    if(int res = solve3b()) return res;\n    return 0;\n}\n\nint main(){\n    int TC; scanf(\"%d\",&TC);\n    p[1] = point(0,0);\n    p[2] = point(1,0);\n    while(TC --){\n        int tx,ty;\n        scanf(\"%d %d %d\",&tx,&ty,&step);\n        step = ceil(2.0 * sqrt(1.0 * tx * tx + 1.0 * ty * ty));\n        target = point(tx,ty);\n        int n = solve();\n        assert(n > 0);\n        printf(\"%d\\n\",n);\n        for(int i = 1;i <= n;i ++){\n            auto [u,v,w] = ans[i];\n            printf(\"%d %d %.12lf %.12lf\\n\",u,v,p[w].x,p[w].y);\n        }\n    }\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\nconst db pi = acos(-1.0);\nconst int N = 1000005;\n\ninline int sgn(db x){\n    if(x < 1e-13 && x > -1e-13) return 0;\n    if(x > 0) return 1;\n    return -1;\n}\n\nstruct point{\n    db x,y;\n    point (db _x = 0.0,db _y = 0.0) : x(_x), y(_y) {}\n};\npoint operator + (const point &p1,const point &p2){\n\treturn point(p1.x + p2.x,p1.y + p2.y);\n}\npoint operator - (const point &p1,const point &p2){\n\treturn point(p1.x - p2.x,p1.y - p2.y);\n}\npoint operator * (db x,const point &p){\n\treturn point(x * p.x,x * p.y);\n} \nbool operator == (point x,point y){\n\treturn sgn(x.x - y.x) == 0 && sgn(x.y - y.y) == 0;\n}\n\ninline db dot(point p1,point p2){\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\ninline db det(point p1,point p2){\n\treturn p1.x * p2.y - p2.x * p1.y;\n}\n\ninline db len(point p){\n    return sqrtl(1.0 * p.x * p.x + 1.0 * p.y * p.y);\n}\n\npoint project_point(point x,point ya,point yb){\n\tpoint v = yb - ya;\n\treturn ya + (dot(v,x - ya) / dot(v,v)) * v;\n}\n\ndb distp(point x,point ya,point yb){\n\treturn fabs(det(ya - x,yb - x)) / len(yb - ya);\n}\n\npoint line_circle_intersec_point(point o,point la,point lb){\n\tdb dis = distp(o,la,lb),l;\n\tpoint pj = project_point(o,la,lb);\n\tl = sqrt(1.0 - dis * dis);\n\tpoint ret = pj + (l / len(lb - la)) * (lb - la);\n\treturn ret;\n}\n\ntuple <int,int,int> ans[N];\npoint p[N],target;\nint step;\n\nbool check(int n){\n    set <pair <int,int> > st;\n    st.insert({1,2});\n    if(n > step) return 0;\n    db eps_len = 1e-8,eps_dis = 1e-4;\n    int fl = 0;\n    for(int i = 1;i <= n;i ++){\n        auto [u,v,w] = ans[i];\n        if(u > v) swap(u,v);\n        if(st.find({u,v}) == st.end()) return 0;\n        if(len(p[u] - p[w]) < 0.5 - eps_len || len(p[u] - p[w]) > 1.0 + eps_len) return 0;\n        if(len(p[v] - p[w]) < 0.5 - eps_len || len(p[v] - p[w]) > 1.0 + eps_len) return 0;\n        st.insert({u,w}); st.insert({v,w});\n        if(len(p[w] - target) <= eps_dis) fl = 1;\n    }\n    return 1;\n}\n\nint solve1a(){\n    point dir = target - p[1];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 2;\n    for(int i = 1;i < split;i ++){\n        ++ c; p[c] = p[1] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        // construct one parallelogram\n    }\n    ++ c; p[c] = target;\n    ans[c - 2] = {c - 2,c - 1,c};\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve1b(){\n    point dir = target - p[2];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 2;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[1] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve2(){\n    p[3] = point(sqrt(3.0) / 2,0.5);\n    p[4] = line_circle_intersec_point(p[3],p[2],target);\n    if(len(p[4] - p[2]) > 1)\n        p[4] = p[2] + (1.0 / len(target - p[2])) * (target - p[2]);\n    ans[1] = {1,2,3};\n    ans[2] = {2,3,4};\n    point dir = target - p[4];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 4;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[4] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve3a(){\n    p[3] = point(0.5,sqrt(3.0) / 2);\n    ans[1] = {1,2,3};\n    point dir = target - p[2];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 3;\n    for(int i = 1;i < split;i ++){\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    ++ c; p[c] = target;\n    ans[c - 2] = {c - 2,c - 1,c};\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve3b(){\n    p[3] = point(0.5,sqrt(3.0) / 2);\n    ans[1] = {1,2,3};\n    point dir = target - p[3];\n    int split = ceil(len(dir) - 1e-9);\n    int c = 3;\n    for(int i = 1;i <= split;i ++){\n        ++ c; p[c] = p[2] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n        ++ c; p[c] = p[3] + (1.0 * i / split) * dir;\n        ans[c - 2] = {c - 2,c - 1,c};\n    }\n    if(check(c - 2)) return c - 2;\n    return 0;\n}\n\nint solve(){\n    if(int res = solve1a()) return res;\n    if(int res = solve1b()) return res;\n    if(int res = solve2()) return res;\n    if(int res = solve3a()) return res;\n    if(int res = solve3b()) return res;\n    return 0;\n}\n\nint main(){\n    int TC; scanf(\"%d\",&TC);\n    p[1] = point(0,0);\n    p[2] = point(1,0);\n    while(TC --){\n        int tx,ty;\n        scanf(\"%d %d %d\",&tx,&ty,&step);\n        step = ceil(2.0 * sqrt(1.0 * tx * tx + 1.0 * ty * ty));\n        target = point(tx,ty);\n        int n = solve();\n        assert(n > 0);\n        printf(\"%d\\n\",n);\n        for(int i = 1;i <= n;i ++){\n            auto [u,v,w] = ans[i];\n            printf(\"%d %d %.12lf %.12lf\\n\",u,v,p[w].x,p[w].y);\n        }\n    }\n    return 0;\n}"
        ]
      },
      {
        "title": "rate this problem",
        "text": "Amazing problem: \n\n    \n\n\n\n\n\n\n Good problem: \n\n    \n\n\n\n\n\n\n Average problem: \n\n    \n\n\n\n\n\n\n Bad problem: \n\n    \n\n\n\n\n\n\n Horrible problem:",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  }
}