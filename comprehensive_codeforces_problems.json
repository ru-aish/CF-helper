{
  "2128A": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128A",
    "problem_title": "2128A - Центр переработки",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's say a bag is expensive if $$$a_i > c$$$ and free if $$$a_i \\leq c$$$.First, observe that as long as there is at least one free bag remaining, we should destroy a free bag. We will perform all expensive destructions at the end. The goal is to perform as much free destructions as possible.When there are multiple free bags, which one to choose? The bigger a bag is, the less time you have to destroy it before it becomes expensive. Hence, at each second, you should destroy the biggest remaining free bag.This process can be naively simulated in $$$\\mathcal{O}(n^2)$$$, which was sufficient under given constraints. If you sort the array beforehand and keep the current multiplier in a separate variable (instead of multiplying all weights), it can be done in $$$\\mathcal{O}(n \\log n)$$$ time.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199790",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n\n\n\n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128B": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128B",
    "problem_title": "2128B - Процесс на Деке",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Instead of taking either the leftmost or rightmost element, think about taking either the minimum or maximum element.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "It's possible to ensure that $$$q_1 < q_2 > q_3 < q_4 > q_5 \\ldots$$$",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's number turns from $$$1$$$ to $$$n$$$. On odd turns, we take the minimum element and on even turns, we take the maximum element. We claim that $$$q_1 < q_2 > q_3 < q_4 > q_5 \\ldots$$$ (which is actually stronger than what the statement asked).Proof: consider taking the minimum on an odd turn : $$$q_i = \\min(p_l, p_r)$$$ where $$$l, r$$$ were the endpoints of the remaining array at turn $$$i$$$. Suppose without loss of generality the minimum was on the left, i.e. $$$q_i = p_l < p_r$$$. Then at the next turn, $$$p_r$$$ is still available:  $$$q_{i+1} = \\max(p_{l+1}, p_r) \\geq p_r > p_l = q_i$$$For example, if the remaining array at an odd turn is $$$[5, ?, \\ldots, 10]$$$, we take the minimum $$$5$$$, and then no matter what the $$$?$$$ is, we take at least $$$10$$$ which is greater than $$$5$$$. This proves $$$q_i < q_{i+1}$$$ when $$$i$$$ is odd. Similarly, we can prove $$$q_i > q_{i+1}$$$ when $$$i$$$ is even.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199677",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128C": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128C",
    "problem_title": "2128C - Самый левый меньший",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "Try to come up with a sufficient condition first, then prove it's necessary. Doing some examples with $$$n = 3$$$ might be useful.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let $$$m_i = \\min(b_1, \\ldots, b_{i-1})$$$ for every $$$2 \\leq i \\leq n$$$, which can be computed in linear time. We claim we can achieve $$$a = b$$$ if and only if $$$b_i - m_i < m_i$$$ for every $$$2 \\leq i \\leq n$$$.Proof that it's sufficient: we can build the array from left to right. For every $$$i$$$, if $$$b_i < m_i$$$ then we directly add $$$b_i$$$. Otherwise, we first add $$$b_i - m_i$$$, then $$$m_i$$$.Proof that it's necessary: suppose we managed to reach $$$b$$$. At every step, $$$a_i \\leq b_i$$$ for every $$$i$$$. Consider the last operation $$$x$$$ that incremented $$$a_i$$$. Then, by the definition of $$$i$$$, we must have  $$$a_i < x \\leq \\min(a_1, \\ldots, a_{i-1}) \\leq \\min(b_1, \\ldots, b_{i-1}).$$$Hence, $$$b_i = a_i + x \\leq 2x-1 \\leq 2m_i - 1$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199604",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128E1": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128E1",
    "problem_title": "2128E1 - Подмедианы (легкая версия)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "You can use binary search on the answer. Why ?",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "Let's start with a, perhaps, more natural task: finding whether or not $$$v$$$ is a submedian. To do so, we create an array $$$\\text{big}$$$ such that $$$\\text{big}[i] = 1 \\text{ if } \\text{a}[i] \\geq v \\text{ else } -1$$$We also create an array $$$\\text{small}$$$ such that $$$\\text{small}[i] = 1 \\text{ if } \\text{a}[i] \\leq v \\text{ else } -1$$$Knowing whether v is a submedian or not requires using both $$$\\mathrm{big}$$$ and $$$\\mathrm{small}$$$ ; when you want to know if the largest submedian is larger than or equal to v, do you actually need both arrays?",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Solve the relaxed problem where we only consider the first three constraints (and neglect the constraint on $$$\\mathrm{small}$$$) i.e finding the largest $$$v$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$",
        "codes": []
      },
      {
        "title": "hint4",
        "text": "Use binary search and prefix sums to rewrite the constraint on $$$\\text{big}$$$",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "Is the resulting value a submedian ?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "First, note that the predicate ``there exists a submedian $$$\\geq v$$$'' is monotonic. That is, if there exists a submedian $$$\\geq v$$$, then for all $$$v' < v$$$, there exists a submedian $$$\\geq v$$$. Thus, we can binary search to find the largest $$$v$$$ such that there exists a submedian $$$\\geq v$$$. Such a $$$v$$$ will be the largest submedian.Now, what is left is to check is, for a fixed $$$v$$$, whether or not there exists a submedian $$$\\geq v$$$. Let's start with a, perhaps, more natural task: finding whether or not $$$v$$$ is a submedian. To do so, we create an array $$$\\text{big}$$$ such that $$$\\text{big}[i] = 1 \\text{ if } \\text{a}[i] \\geq v \\text{ else } -1$$$We also create an array $$$\\text{small}$$$ such that $$$\\text{small}[i] = 1 \\text{ if } \\text{a}[i] \\leq v \\text{ else } -1$$$Using these notations, $$$v$$$ is a submedian iff there exists $$$(l, r)$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ $$$\\text{small}[l] + \\dots + \\text{small}[r] \\geq 0$$$ Let's try to solve a relaxed problem where we only consider the first three constraints (and neglect the constraint on $$$\\text{small}$$$ i.e finding the largest $$$v$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ Such a problem is standard and can be easily solved in $$$\\mathcal{O}(n \\log n)$$$ by binary search and prefix sums. Indeed, for a fixed $$$v$$$, we can iterate over the value of $$$r$$$. Now: $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ iff $$$\\text{pref}[r] - \\text{pref}[l-1] \\geq 0$$$ i.e $$$\\text{pref}[r] \\geq \\text{pref}[l-1]$$$ so taking $$$l$$$ that minimizes $$$\\text{pref}[l-1]$$$ is optimal. Thus, it is enough to maintain such an $$$l$$$ in constant time (when you increase $$$r$$$, there is only one new candidate for $$$l$$$).Now, I claim that the value of $$$v$$$ we get happens to be the largest submedian. Indeed, if it doesn't satisfy $$$\\text{small}[l] + \\dots + \\text{small}[r] \\geq 0$$$, then $$$v + 1$$$ would still satisfy $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ which contradicts the maximality of $$$v$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199376",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128E2": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128E2",
    "problem_title": "2128E2 - Подмедианы (сложная версия)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "The set of submedians is a range. Try to prove it.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "For $$$l_1 \\leq r_1$$$ and $$$l_2, r_2$$$ such that $$$|l_1 - l_2| + |r_1 - r_2| \\leq 1$$$, both subarrays share at least one median. How to prove it ? Knowing this fact, how to prove Hint 1 ?",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Find a discretely ``continuous'' path from the subarray of the minimum submedian, to the subarray of the maximum submedian",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Read the editorial of E1 first.In such problems, it can be useful to try an easier version, for example, finding maximal/minimal values (which is why the subtask is helpful).Now, one can observe that if $$$x \\leq y$$$ are submedians, then any $$$z$$$ such that $$$x \\leq z \\leq y$$$ is also a submedian ! One can prove this using the intermediate value theorem. Let's fix $$$x \\leq z \\leq y$$$ and $$$[l_1, r_1]$$$ (resp. $$$[l_2, r_2]$$$) be a range where $$$x$$$ (resp. $$$y$$$) is a submedian. wlog, assume $$$l_1 < l_2$$$. Start by sweeping $$$r_1$$$ to $$$l_2$$$. Then $$$r_1$$$ to $$$r_2$$$. And finally, $$$l_1$$$ to $$$l_2$$$. Then one of the ranges that we covered has submedian $$$z$$$. Intuitively, when incrementing one of the ends of a range, the +1/-1 in the arrays big and small are not changing that much (the norm 1 distance is bounded by 2) so we can think of using the intermediate value theorem (see proof below). Also, note that at any time, the covered range is of length at least $$$k$$$.Thus, it is enough to find the smallest and largest submedians (using the solution of E1) and maintain the set of submedians while sweeping. One way to do that is to use a fenwick tree to simulate an ordered set (or you can also use two range sum point update queries to simulate the \\text{big} and \\text{small} arrays). Alternatively, you can use two sets (one with the lower half of the values of the current range, and one with the upper half). For each $$$[l, r]$$$ that our algorithm covers, we consider the point $$$(|{i \\in [l,r] \\mid a[i] \\geq z}| - |{i \\in [l,r] \\mid a[i] < z}|, |{i \\in [l,r] \\mid a[i] \\leq z}| - |{i \\in [l,r] \\mid a[i] > z}|)$$$ where $$$|A|$$$ is the cardinal of set $$$A$$$. Essentially, you can think of this point as an encoding of both conditions on small and big for $$$z$$$ to be a submedian.Note that, when moving one end of the range, each coordinate of the point changes by at most 1 (in absolute value). Also note that, by a simple computation, the sum of both coordinates is positive (it is equal to twice the number of $$$i$$$ such that $$$a[i] = z$$$).I claim that one of these points will have positive coordinates (thus, $$$z$$$ will be a submedian). Indeed: our path starts at a point with (negative first coordinate, positive second coordinate) and ends at a point with (positive first coordinate, negative second coordinate). Each move allows moving to a point at distance at most 2. However, you can see on the drawing below that one must pass through points with positive coordinates to achieve this (otherwise, you would be stuck in (negative first coordinate, positive second coordinate)).In red, the area with points such that $$$x+y \\geq 0$$$, below the green line are forbidden points. The blue points are our starting and ending points. Finally, the arrows are the possible moves after incrementing/decrementing one end of the range.",
        "codes": []
      },
      {
        "title": "code",
        "text": "Fenwick tree solution: 331199080 Two sets solution: 331198693",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128F": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128F",
    "problem_title": "2128F - Строгий треугольник",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Hint1aSay an edge is green if its weight is $$$l_i$$$ and red if its weight is $$$r_i$$$. If the answer is YES, prove there exists a solution that colors a path from $$$1$$$ to $$$n$$$ in green and the rest of the edges in red. Hint1bConsider an arbitrary solution $$$w$$$ and let $$$P$$$ be the shortest path from $$$1$$$ to $$$n$$$ with respect to $$$w$$$. Decreasing the weight of an edge in $$$P$$$ will decrease $$$d(1, n)$$$ by exactly one and will decrease $$$d(1, k) + d(k, n)$$$ by at most one. Increasing the weight of an edge outside $$$P$$$ will not increase $$$d(1, n)$$$ and will not decrease $$$d(1, k) + d(k, n)$$$. By repeating these operations, we can make $$$P$$$ green and the rest red.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "Hint2aLet $$$P$$$ be the chosen green path. Find a necessary condition for the corresponding weight assignment to be correct. Then, prove if it's sufficient. Hint2bThe condition is $$$d_L(u, v) < d_R(u, k) + d_R(k, v)$$$ for all $$$u, v \\in P$$$. Hint2cIt's obviously necessary; otherwise, $$$1 \\rightarrow_L u \\rightarrow_R k \\rightarrow_R v \\rightarrow_L n$$$ would have length $$$d(1, n)$$$. Conversely, if there exists a $$$1-n$$$ shortest path going through $$$k$$$, if you consider the last node in $$$P$$$ you visited before reaching $$$k$$$ and the first node in $$$P$$$ you visited after reaching $$$k$$$, this pair of nodes will violate the condition.",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Try to build a correct path using a Dijkstra-like algorithm. It might be helpful to have an intuitive understanding of the condition found in the previous hint in order to quantify with a single integer how good the current path is. Imagine you're a robber going from $$$1$$$ to $$$n$$$ and you don't want to be caught by cops.",
        "codes": []
      },
      {
        "title": "hint4",
        "text": "Imagine nodes are cities, $$$k$$$ is a police station, and you're some robber. Traversing the $$$i$$$-th edge takes $$$l_i$$$ seconds for the robber, and $$$r_i$$$ seconds for the citizens and the cops.Each time you go through a city, the citizens of this city will run to the police station to warn the cops. Once the cops are warned, they start dispatching in all directions as fast as they can to catch up to you.",
        "codes": []
      },
      {
        "title": "hint5",
        "text": "The current danger can be represented by an integer timer $$$x$$$. If $$$x < 0$$$, it means the cops will be warned in $$$-x$$$ seconds. If $$$x \\geq 0$$$, it means the cops have been warned since $$$0$$$ seconds. It's the only information you need to remember.",
        "codes": []
      },
      {
        "title": "hint6",
        "text": "Try to find for each node $$$u$$$ what is the corresponding minimum timer $$$t_u$$$. As the robber runs through the graph, the timer always increases, so you can do this with Dijkstra.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Please read all the hints first.We first make a classical Dijkstra from $$$k$$$ with $$$r$$$-weighted edges. Let $$$d_u$$$ be the distance between $$$u$$$ and $$$k$$$ for citizens/cops.We then make a modified Dijkstra, starting from the situation $$$(1, t_1)$$$ with $$$t_1 = -d_1$$$ (meaning the cops will be warned in $$$d_1$$$ seconds).When you traverse the $$$i$$$-th edge to go from $$$(u, t)$$$ to $$$v$$$, the new timer will be  $$$t' = \\max(t + l_i, -d_v).$$$We have $$$t' \\geq t+l_i$$$ because the previous timer continued to advance while the robber was traversing the edge, and $$$t' \\geq -d_v$$$ because a new citizen started running from $$$v$$$ to the police station.Each time, we take the situation with the minimum timer from the priority queue. If the node has already been processed, or if $$$d_u \\leq t_u$$$ (meaning the cops can catch up to the robber in $$$v$$$), the situation is skipped. The answer is YES if and only if we processed the node $$$n$$$.The time complexity is $$$\\mathcal{O}((n + m) \\log (n+m))$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331198575",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128D": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128D",
    "problem_title": "D. Sum of LDS",
    "time_limit": "2 seconds",
    "memory_limit": "256 megabytes",
    "statement": "You're given a permutation$$$^{\\text{∗}}$$$ $$$p_1, \\ldots, p_n$$$ such that $$$\\max(p_i, p_{i+1}) > p_{i+2}$$$ for all $$$1 \\leq i \\leq n-2$$$.Compute the sum of the length of the longest decreasing subsequence$$$^{\\text{†}}$$$ of the subarray $$$[p_l, p_{l+1}, \\ldots, p_r]$$$ over all pairs $$$1 \\leq l \\leq r \\leq n$$$.$$$^{\\text{∗}}$$$A permutation of length $$$n$$$ is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array), and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).$$$^{\\text{†}}$$$Given an array $$$b$$$ of size $$$|b|$$$, a decreasing subsequence of length $$$k$$$ is a sequence of indices $$$i_1, \\ldots, i_k$$$ such that:$$$1 \\leq i_1 < i_2 < \\ldots < i_k \\leq |b|$$$$$$b_{i_1} > b_{i_2} > \\ldots > b_{i_k}$$$\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10\\,000$$$). The description of the test cases follows.The first line of each test case contains a single integer $$$n$$$ ($$$3 \\leq n \\leq 500\\,000$$$).The second line of each test case contains $$$n$$$ integers $$$p_1, p_2, \\ldots, p_n$$$ ($$$1 \\le p_i \\le n$$$, $$$p_i$$$ are pairwise distinct).It is guaranteed that $$$\\max(p_i, p_{i+1}) > p_{i+2}$$$ for all $$$1 \\leq i \\leq n-2$$$.The sum of $$$n$$$ over all test cases does not exceed $$$500\\,000$$$.\n\nOutputFor each test case, output the sum over all subarrays of the length of its longest decreasing subsequence.",
    "sample_inputs": [
      "433 2 144 3 1 266 1 5 2 4 332 3 1"
    ],
    "sample_outputs": [
      "10\n17\n40\n8"
    ],
    "notes": "NoteFor any array $$$a$$$, we define $$$\\text{LDS}(a)$$$ as the length of the longest decreasing subsequence of $$$a$$$.In the first test case, all subarrays are decreasing.In the second one, we have$$$\\text{LDS}([4]) = \\text{LDS}([3]) = \\text{LDS}([1]) = \\text{LDS}([2]) = 1$$$$$$\\text{LDS}([4,3]) = \\text{LDS}([3,1]) = 2, \\text{LDS}([1, 2]) = 1$$$$$$\\text{LDS}([4,3,1]) = 3, \\text{LDS}([3,1,2]) = 2$$$$$$\\text{LDS}([4,3,1,2]) = 3$$$So the answer is $$$1+1+1+1+2+2+1+3+2+3=17$$$.",
    "tags": [
      "brute force",
      "combinatorics",
      "dp",
      "greedy",
      "math",
      "*1600"
    ],
    "url": "https://codeforces.com/problemset/problem/2128/D",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Let $$$b_i = \\max(a_i, a_{i+1})$$$, show that $$$b_1 \\geq b_2 \\geq \\ldots \\geq b_{n-1}$$$.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "If $$$a_i < a_{i+1}$$$, show that $$$a_{i+1} > \\max(a_{i+2}, a_{i+3}, \\ldots a_{n})$$$.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let $$${i_1, \\ldots, i_m}$$$ be the set of $$$i \\in [1, n]$$$ such that $$$a_i > a_{i+1}$$$. Let us show that the sequence $$$(i_1, \\ldots, i_m)$$$ is an LDS:  It is a decreasing subsequence: let $$$k \\in [1, m -1]$$$. If $$$i_{k+1} = i_{k}+1$$$, then $$$a_{i_k} > a_{(i_k) + 1} = a_{i_{k+1}}$$$. Else, we have $$$a_{(i_k) + 2} < \\max(a_{i_k}, a_{(i_k)+1})$$$, but $$$i_k + 1$$$ is such that $$$a_{i_{k}+2} \\geq a_{i_{k+1}}$$$, so $$$a_{(i_k) + 2} < a_{i_k}$$$. We have also $$$a_{i_k + 1} < a_{i_k}$$$ by definition so we can easily prove by induction on $$$j > 0$$$ that $$$a_{i_k + j} < a_{i_k}$$$ where it makes sense. It's optimal : let $$$E$$$ be the set of indexes taken by a LDS. For each i such that $$$a_i \\leq a_{i+1}$$$, at least one of the elements of $$${i, i+1}$$$ does not belong to $$$E$$$. Now, these sets are disjoint : if $$$a_i < a_{i+1}$$$ we cannot have $$$a_{i+2} < a_{i+1}$$$ (otherwise the condition $$$\\max(a_i, a_{i+1}) > a_{i+2}$$$ is not met. So $$$|E| \\leq m$$$. To calculate the sum of the LDS of the sub-arrays, it is therefore sufficient to count for each $$$i$$$ such that $$$a_i < a_{i+1}$$$ the number of sub-arrays $$$a[l,r]$$$ which contain $$$i$$$ and $$$i + 1$$$. It's $$$(i+1) \\cdot (n - i - 1)$$$ for $$$0$$$-indexation : a necessary and sufficient condition is that $$$l \\leq i$$$ and $$$r \\geq i + 1$$$.Note that there also exists a dp approach, see this comment.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199533",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2126A": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126A",
    "problem_title": "2126A - Only One Digit",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int x;\n    cin >> x;\n    int mn = 9;\n    while(x > 0) {\n      mn = min(mn, x % 10);\n      x/=10;\n    }\n    cout << mn << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int x;\n    cin >> x;\n    int mn = 9;\n    while(x > 0) {\n      mn = min(mn, x % 10);\n      x/=10;\n    }\n    cout << mn << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126B": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126B",
    "problem_title": "2126B - No Casino in the Mountains",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    int cnt = 0;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] == 1) {\n        ans+=(cnt + 1)/(k + 1);\n        cnt = 0;\n        continue;\n      }\n      else {\n        cnt++;\n      }\n    }\n    ans+=(cnt + 1)/(k + 1);\n    cout << ans << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    int cnt = 0;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] == 1) {\n        ans+=(cnt + 1)/(k + 1);\n        cnt = 0;\n        continue;\n      }\n      else {\n        cnt++;\n      }\n    }\n    ans+=(cnt + 1)/(k + 1);\n    cout << ans << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126C": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126C",
    "problem_title": "2126C - I Will Definitely Make It",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,p;\n    cin >> n >> p;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int cur = a[p];\n    int dist = a[p];\n    sort(a + 1,a + n + 1);\n    bool ans = true;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] < cur) continue;\n      if(a[i] &mdash; cur > dist) {\n        ans = false;\n      }\n      cur = a[i];\n    }\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,p;\n    cin >> n >> p;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int cur = a[p];\n    int dist = a[p];\n    sort(a + 1,a + n + 1);\n    bool ans = true;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] < cur) continue;\n      if(a[i] &mdash; cur > dist) {\n        ans = false;\n      }\n      cur = a[i];\n    }\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126D": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126D",
    "problem_title": "2126D - This Is the Last Time",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    pair <int,pair <int,int> > p[n + 1];\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[ыi].second.first >> p[i].second.second;\n    sort(p + 1,p + n + 1);\n    int cur = k;\n    for(int i = 1;i <= n;i++) {\n      if(p[i].first > cur) break;\n      cur = max(cur,p[i].second.second);\n    }\n    cout << cur << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    pair <int,pair <int,int> > p[n + 1];\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[ыi].second.first >> p[i].second.second;\n    sort(p + 1,p + n + 1);\n    int cur = k;\n    for(int i = 1;i <= n;i++) {\n      if(p[i].first > cur) break;\n      cur = max(cur,p[i].second.second);\n    }\n    cout << cur << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126E": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126E",
    "problem_title": "2126E - G-C-D, Unlucky!",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nmain() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long a[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        long long b[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        long long ans[n + 1];\n        for (int i = n; i >= 1; i--) {\n            ans[i] = lcm(a[i], b[i]);\n        }\n        bool ch = 1;\n        if(ans[1] != a[1]) ch = 0;\n        if(ans[n] != b[n]) ch = 0;\n        for (int i = 2; i <= n; i++) {\n            if (__gcd(a[i &mdash; 1], ans[i]) != a[i]) {\n                ch = 0;\n            }\n        }\n        for (int i = n &mdash; 1; i >= 1; i--) {\n            if (__gcd(b[i + 1], ans[i]) != b[i]) {\n                ch = 0;\n            }\n        }\n        if (ch) {\n            cout << \"YES\" << \"\\n\";\n        } else {\n            cout << \"NO\" << \"\\n\";\n        }\n    }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nmain() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long a[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        long long b[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        long long ans[n + 1];\n        for (int i = n; i >= 1; i--) {\n            ans[i] = lcm(a[i], b[i]);\n        }\n        bool ch = 1;\n        if(ans[1] != a[1]) ch = 0;\n        if(ans[n] != b[n]) ch = 0;\n        for (int i = 2; i <= n; i++) {\n            if (__gcd(a[i &mdash; 1], ans[i]) != a[i]) {\n                ch = 0;\n            }\n        }\n        for (int i = n &mdash; 1; i >= 1; i--) {\n            if (__gcd(b[i + 1], ans[i]) != b[i]) {\n                ch = 0;\n            }\n        }\n        if (ch) {\n            cout << \"YES\" << \"\\n\";\n        } else {\n            cout << \"NO\" << \"\\n\";\n        }\n    }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126F": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126F",
    "problem_title": "2126F - 1-1-1, Free Tree!",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\nint n;\nint col[B];\nlong long costt = 0;\nvector <pair <int,int> > reb[B];\nbool was[B];\nmap <int,long long> cnt[B];\nint pred[B];\nlong long zn[B];\nvoid dfs(int v) {\n  was[v] = true;\n  for(auto u:reb[v]) {\n    if(was[u.first]) {\n      pred[v] = u.first;\n      continue;\n    }\n    if(col[v] != col[u.first]) costt+=u.second;\n    dfs(u.first);\n    zn[u.first] = u.second;\n    cnt[v][col[u.first]]+=zn[u.first];\n  }\n}\nvoid update(int v,int x) {\n  if(v != 1) {\n    cnt[pred[v]][col[v]]-=zn[v];\n    if(col[pred[v]] == col[v]) costt+=zn[v];\n    cnt[pred[v]][x]+=zn[v];\n    if(col[pred[v]] == x) costt-=zn[v];\n  }\n  else {\n      \n  }\n  costt+=cnt[v][col[v]];\n  costt-=cnt[v][x];\n  col[v] = x;\n}\nvoid clr() {\n  for(int i = 1;i <= n;i++) {\n    reb[i].clear();\n    was[i] = false;\n    cnt[i].clear();\n    zn[i] = 0;\n  }\n  costt = 0;\n}\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int q;\n    cin >> n >> q;\n    for(int i = 1; i <= n; i++) cin >> col[i];\n    for(int i = 1; i < n; i++) {\n      int u, v, c;\n      cin >> u >> v >> c;\n      reb[v].push_back({u,c});\n      reb[u].push_back({v,c});\n    }\n    dfs(1);\n    while(q--) {\n      int pos,x;\n      cin >> pos >> x;\n      update(pos,x);\n      cout << costt << \"\\n\";\n    }\n    clr();\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\nint n;\nint col[B];\nlong long costt = 0;\nvector <pair <int,int> > reb[B];\nbool was[B];\nmap <int,long long> cnt[B];\nint pred[B];\nlong long zn[B];\nvoid dfs(int v) {\n  was[v] = true;\n  for(auto u:reb[v]) {\n    if(was[u.first]) {\n      pred[v] = u.first;\n      continue;\n    }\n    if(col[v] != col[u.first]) costt+=u.second;\n    dfs(u.first);\n    zn[u.first] = u.second;\n    cnt[v][col[u.first]]+=zn[u.first];\n  }\n}\nvoid update(int v,int x) {\n  if(v != 1) {\n    cnt[pred[v]][col[v]]-=zn[v];\n    if(col[pred[v]] == col[v]) costt+=zn[v];\n    cnt[pred[v]][x]+=zn[v];\n    if(col[pred[v]] == x) costt-=zn[v];\n  }\n  else {\n      \n  }\n  costt+=cnt[v][col[v]];\n  costt-=cnt[v][x];\n  col[v] = x;\n}\nvoid clr() {\n  for(int i = 1;i <= n;i++) {\n    reb[i].clear();\n    was[i] = false;\n    cnt[i].clear();\n    zn[i] = 0;\n  }\n  costt = 0;\n}\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int q;\n    cin >> n >> q;\n    for(int i = 1; i <= n; i++) cin >> col[i];\n    for(int i = 1; i < n; i++) {\n      int u, v, c;\n      cin >> u >> v >> c;\n      reb[v].push_back({u,c});\n      reb[u].push_back({v,c});\n    }\n    dfs(1);\n    while(q--) {\n      int pos,x;\n      cin >> pos >> x;\n      update(pos,x);\n      cout << costt << \"\\n\";\n    }\n    clr();\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126G1": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126G1",
    "problem_title": "2126G1 - Big Wins! (easy version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    for(int i = 1;i <= 100;i++) {\n      int b[n + 1] = {};\n      for(int j = 1;j <= n;j++) {\n        if(a[j] >= i) b[j] = 1;\n        else b[j] = -1;\n      }\n      int pref[n + 1] = {};\n      for(int j = 1; j <= n; j++) {\n        pref[j] = pref[j - 1] + b[j]; \n      }\n      int prefmn[n + 2] = {},suffmx[n + 1] = {};\n      prefmn[0] = 0,suffmx[n] = pref[n];\n      for(int j = 1; j <= n; j++) {\n        prefmn[j] = min(prefmn[j - 1],pref[j]);\n      }\n      for(int j = n - 1; j >= 1; j--) {\n        suffmx[j] = max(suffmx[j + 1],pref[j]);\n      }\n      for(int j = 1; j <= n; j++) {\n        if(prefmn[j - 1] <= pref[j] || pref[j - 1] <= suffmx[j]) {\n          ans = max(ans,i - a[j]);\n        }\n      }\n    } \n    cout << ans << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    for(int i = 1;i <= 100;i++) {\n      int b[n + 1] = {};\n      for(int j = 1;j <= n;j++) {\n        if(a[j] >= i) b[j] = 1;\n        else b[j] = -1;\n      }\n      int pref[n + 1] = {};\n      for(int j = 1; j <= n; j++) {\n        pref[j] = pref[j - 1] + b[j]; \n      }\n      int prefmn[n + 2] = {},suffmx[n + 1] = {};\n      prefmn[0] = 0,suffmx[n] = pref[n];\n      for(int j = 1; j <= n; j++) {\n        prefmn[j] = min(prefmn[j - 1],pref[j]);\n      }\n      for(int j = n - 1; j >= 1; j--) {\n        suffmx[j] = max(suffmx[j + 1],pref[j]);\n      }\n      for(int j = 1; j <= n; j++) {\n        if(prefmn[j - 1] <= pref[j] || pref[j - 1] <= suffmx[j]) {\n          ans = max(ans,i - a[j]);\n        }\n      }\n    } \n    cout << ans << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126G2": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126G2",
    "problem_title": "G2. Big Wins! (hard version)",
    "time_limit": "4 seconds",
    "memory_limit": "256 megabytes",
    "statement": "This is the hard version of the problem. The difference between the versions is that in this version $$$a_i \\leq n$$$.You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$.Your task is to find a subarray $$$a[l, r]$$$ (a continuous sequence of elements $$$a_l, a_{l + 1}, \\dots, a_r$$$) for which the value of the expression $$$\\text{med}(a[l, r]) - \\min(a[l, r])$$$ is maximized.Here:$$$\\text{med}$$$ is the median of the subarray, that is, the element at position $$$\\left\\lceil \\frac{k + 1}{2} \\right\\rceil$$$ after sorting the subarray, where $$$k$$$ is its length;$$$\\min$$$ is the minimum element of this subarray.For example, consider the array $$$a=[1, 4, 1, 5, 3, 3]$$$ and choose the subarray $$$a[2, 5] = [4, 1, 5, 3]$$$. In sorted form, it looks like $$$[1, 3, 4, 5]$$$.$$$\\text{med}(a[2, 5]) = 4$$$, since $$$\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil = $$$ the third element in the sorted subarray is $$$4$$$;$$$\\min(a[2, 5]) = 1$$$, since the minimum element is $$$1$$$.In this example, the value $$$\\text{med} - \\min = 4 - 1 = 3$$$.\n\nInputThe first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the array.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.\n\nOutputFor each test case, output one integer — the maximum possible value of $$$\\text{med} - \\min$$$ among all subarrays of the array.",
    "sample_inputs": [
      "553 2 5 3 144 1 1 376 1 3 4 6 2 744 2 3 151 2 3 4 5"
    ],
    "sample_outputs": [
      "3\n3\n5\n2\n2"
    ],
    "notes": "NoteIn the first example, consider the array: $$$a=[3,\\ 2,\\ 5,\\ 3,\\ 1]$$$ you can choose the subarray $$$a[2,\\ 3]$$$, that is, the elements $$$[2,\\ 5]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[2,\\ 5]$$$, $$$\\text{med} = 5$$$.The minimum element of the subarray: $$$\\min = 2$$$.Therefore, $$$\\text{med} - \\min = 5 - 2 = 3$$$, which is the maximum answer.In the second test, the array: $$$a=[4,\\ 1,\\ 1,\\ 3]$$$ you can choose the subarray $$$a[1,\\ 2]$$$, that is, the elements $$$[4,\\ 1]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[1,\\ 4]$$$, $$$\\text{med} = 4$$$.The minimum element of the subarray: $$$\\min = 1$$$.Therefore, $$$\\text{med} - \\min = 4 - 1 = 3$$$.It can be proven that both of these subarrays are optimal and yield the maximum value of the expression $$$\\text{med} - \\min$$$.",
    "tags": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dsu",
      "trees",
      "two pointers",
      "*2400"
    ],
    "url": "https://codeforces.com/contest/2126/problem/G2",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint a[200005 + 2];\narray<int, 4> t[800005];\narray<int, 4> merge(array<int, 4>a, array<int, 4>b) {\n    int ans = max(a[0], b[0]);\n    int mxpref = max(a[1], a[3] + b[1]);\n    int mxsuff = max(b[2], a[2] + b[3]);\n    ans = max({ans, mxpref, mxsuff});\n    int sum = a[3] + b[3];\n    return {ans, mxpref, mxsuff, sum};\n}\nvoid update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n        t[v] = {max(val, 0), max(val, 0), max(val, 0), val};\n    } else {\n        int tm = (tl + tr) >> 1;\n        if (pos <= tm) {\n            update(v * 2, tl, tm, pos, val);\n        } else {\n            update(v * 2 + 1, tm + 1, tr, pos, val);\n        }\n        t[v] = merge(t[v * 2], t[v * 2 + 1]);\n    }\n}\narray<int, 4> get(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n        return t[v];\n    } else if (l > r) {\n        return {0, 0, 0, 0};\n    } else {\n        int tm = (tl + tr) >> 1;\n        return merge(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n}\nint solve(int n, vector<int>A) {\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n        m = max(m, a[i]);\n    }\n    vector<int>ind[m + 1];\n    for (int i = 1; i <= n; i++) {\n        ind[a[i]].push_back(i);\n    }\n    stack<int>s;\n    s.push(0);\n    a[0] = -INT_MAX;\n    int l[n + 1];\n    for (int i = 1; i <= n; i++) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        l[i] = s.top() + 1;\n        s.push(i);\n    }\n    a[n + 1] = -INT_MAX;\n    s.push(n + 1);\n    int r[n + 1];\n    for (int i = n; i >= 1; i--) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        r[i] = s.top() &mdash; 1;\n        s.push(i);\n    }\n    int med = 1;\n    for (int i = 1; i <= n; i++) {\n        update(1, 1, n, i, 1);\n    }\n    for (auto u : ind[1]) {\n        update(1, 1, n, u, -1);\n    }\n    int ans = 0;\n    for (int mn = 1; mn <= m; mn++) {\n        for (auto u : ind[mn]) {\n            int lg = l[u], rg = r[u];\n            while (med < m && get(1, 1, n, lg, u &mdash; 1)[2] + get(1, 1, n, u + 1, rg)[1] + (a[u] < (med) ? -1 : 1) >= 0) {\n                med++;\n                for (auto u : ind[med]) {\n                    update(1, 1, n, u, -1);\n                }\n            }\n        }\n        // cout << med << ' ' << mn << endl;\n        ans = max(ans, med &mdash; mn);\n    }\n    return ans;\n}\nint solveslow(int n, vector<int>A) {\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        vector<int>v;\n        for (int j = i; j <= n; j++) {\n            v.push_back(a[j]);\n            sort(v.begin(), v.end());\n            mx = max(mx, v[v.size() / 2] &mdash; v[0]);\n        }\n    }\n    return mx;\n}\nint rnd() {\n    return (rand() + rand() * RAND_MAX);\n}\nmain() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while(tt--) {\n        int n;\n        cin >> n;\n        vector<int>v;\n        for (int i = 1; i <= n; i++) {\n            int x;\n            cin >> x;\n            v.push_back(x);\n        }\n        cout << solve(n, v) << endl;\n        // cout << solveslow(n, v) << endl;\n        for(int i = 0;i <= n*4;i++) {\n            t[i][0] = 0;\n            t[i][1] = 0;\n            t[i][2] = 0;\n            t[i][3] = 0;\n        }\n    }\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint a[200005 + 2];\narray<int, 4> t[800005];\narray<int, 4> merge(array<int, 4>a, array<int, 4>b) {\n    int ans = max(a[0], b[0]);\n    int mxpref = max(a[1], a[3] + b[1]);\n    int mxsuff = max(b[2], a[2] + b[3]);\n    ans = max({ans, mxpref, mxsuff});\n    int sum = a[3] + b[3];\n    return {ans, mxpref, mxsuff, sum};\n}\nvoid update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n        t[v] = {max(val, 0), max(val, 0), max(val, 0), val};\n    } else {\n        int tm = (tl + tr) >> 1;\n        if (pos <= tm) {\n            update(v * 2, tl, tm, pos, val);\n        } else {\n            update(v * 2 + 1, tm + 1, tr, pos, val);\n        }\n        t[v] = merge(t[v * 2], t[v * 2 + 1]);\n    }\n}\narray<int, 4> get(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n        return t[v];\n    } else if (l > r) {\n        return {0, 0, 0, 0};\n    } else {\n        int tm = (tl + tr) >> 1;\n        return merge(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n}\nint solve(int n, vector<int>A) {\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n        m = max(m, a[i]);\n    }\n    vector<int>ind[m + 1];\n    for (int i = 1; i <= n; i++) {\n        ind[a[i]].push_back(i);\n    }\n    stack<int>s;\n    s.push(0);\n    a[0] = -INT_MAX;\n    int l[n + 1];\n    for (int i = 1; i <= n; i++) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        l[i] = s.top() + 1;\n        s.push(i);\n    }\n    a[n + 1] = -INT_MAX;\n    s.push(n + 1);\n    int r[n + 1];\n    for (int i = n; i >= 1; i--) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        r[i] = s.top() &mdash; 1;\n        s.push(i);\n    }\n    int med = 1;\n    for (int i = 1; i <= n; i++) {\n        update(1, 1, n, i, 1);\n    }\n    for (auto u : ind[1]) {\n        update(1, 1, n, u, -1);\n    }\n    int ans = 0;\n    for (int mn = 1; mn <= m; mn++) {\n        for (auto u : ind[mn]) {\n            int lg = l[u], rg = r[u];\n            while (med < m && get(1, 1, n, lg, u &mdash; 1)[2] + get(1, 1, n, u + 1, rg)[1] + (a[u] < (med) ? -1 : 1) >= 0) {\n                med++;\n                for (auto u : ind[med]) {\n                    update(1, 1, n, u, -1);\n                }\n            }\n        }\n        // cout << med << ' ' << mn << endl;\n        ans = max(ans, med &mdash; mn);\n    }\n    return ans;\n}\nint solveslow(int n, vector<int>A) {\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        vector<int>v;\n        for (int j = i; j <= n; j++) {\n            v.push_back(a[j]);\n            sort(v.begin(), v.end());\n            mx = max(mx, v[v.size() / 2] &mdash; v[0]);\n        }\n    }\n    return mx;\n}\nint rnd() {\n    return (rand() + rand() * RAND_MAX);\n}\nmain() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while(tt--) {\n        int n;\n        cin >> n;\n        vector<int>v;\n        for (int i = 1; i <= n; i++) {\n            int x;\n            cin >> x;\n            v.push_back(x);\n        }\n        cout << solve(n, v) << endl;\n        // cout << solveslow(n, v) << endl;\n        for(int i = 0;i <= n*4;i++) {\n            t[i][0] = 0;\n            t[i][1] = 0;\n            t[i][2] = 0;\n            t[i][3] = 0;\n        }\n    }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "problemG2": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "problemG2",
    "problem_title": "G2. Big Wins! (hard version)",
    "time_limit": "4 seconds",
    "memory_limit": "256 megabytes",
    "statement": "This is the hard version of the problem. The difference between the versions is that in this version $$$a_i \\leq n$$$.You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$.Your task is to find a subarray $$$a[l, r]$$$ (a continuous sequence of elements $$$a_l, a_{l + 1}, \\dots, a_r$$$) for which the value of the expression $$$\\text{med}(a[l, r]) - \\min(a[l, r])$$$ is maximized.Here:$$$\\text{med}$$$ is the median of the subarray, that is, the element at position $$$\\left\\lceil \\frac{k + 1}{2} \\right\\rceil$$$ after sorting the subarray, where $$$k$$$ is its length;$$$\\min$$$ is the minimum element of this subarray.For example, consider the array $$$a=[1, 4, 1, 5, 3, 3]$$$ and choose the subarray $$$a[2, 5] = [4, 1, 5, 3]$$$. In sorted form, it looks like $$$[1, 3, 4, 5]$$$.$$$\\text{med}(a[2, 5]) = 4$$$, since $$$\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil = $$$ the third element in the sorted subarray is $$$4$$$;$$$\\min(a[2, 5]) = 1$$$, since the minimum element is $$$1$$$.In this example, the value $$$\\text{med} - \\min = 4 - 1 = 3$$$.\n\nInputThe first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the array.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.\n\nOutputFor each test case, output one integer — the maximum possible value of $$$\\text{med} - \\min$$$ among all subarrays of the array.",
    "sample_inputs": [
      "553 2 5 3 144 1 1 376 1 3 4 6 2 744 2 3 151 2 3 4 5"
    ],
    "sample_outputs": [
      "3\n3\n5\n2\n2"
    ],
    "notes": "NoteIn the first example, consider the array: $$$a=[3,\\ 2,\\ 5,\\ 3,\\ 1]$$$ you can choose the subarray $$$a[2,\\ 3]$$$, that is, the elements $$$[2,\\ 5]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[2,\\ 5]$$$, $$$\\text{med} = 5$$$.The minimum element of the subarray: $$$\\min = 2$$$.Therefore, $$$\\text{med} - \\min = 5 - 2 = 3$$$, which is the maximum answer.In the second test, the array: $$$a=[4,\\ 1,\\ 1,\\ 3]$$$ you can choose the subarray $$$a[1,\\ 2]$$$, that is, the elements $$$[4,\\ 1]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[1,\\ 4]$$$, $$$\\text{med} = 4$$$.The minimum element of the subarray: $$$\\min = 1$$$.Therefore, $$$\\text{med} - \\min = 4 - 1 = 3$$$.It can be proven that both of these subarrays are optimal and yield the maximum value of the expression $$$\\text{med} - \\min$$$.",
    "tags": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dsu",
      "trees",
      "two pointers",
      "*2400"
    ],
    "url": "https://codeforces.com/contest/2126/problem/G2",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [],
    "tutorials": [],
    "editorials": []
  }
}