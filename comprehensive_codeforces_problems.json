{
  "2128A": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128A",
    "problem_title": "2128A - Центр переработки",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's say a bag is expensive if $$$a_i > c$$$ and free if $$$a_i \\leq c$$$.First, observe that as long as there is at least one free bag remaining, we should destroy a free bag. We will perform all expensive destructions at the end. The goal is to perform as much free destructions as possible.When there are multiple free bags, which one to choose? The bigger a bag is, the less time you have to destroy it before it becomes expensive. Hence, at each second, you should destroy the biggest remaining free bag.This process can be naively simulated in $$$\\mathcal{O}(n^2)$$$, which was sufficient under given constraints. If you sort the array beforehand and keep the current multiplier in a separate variable (instead of multiplying all weights), it can be done in $$$\\mathcal{O}(n \\log n)$$$ time.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199790",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n\n\n\n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128B": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128B",
    "problem_title": "2128B - Процесс на Деке",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Instead of taking either the leftmost or rightmost element, think about taking either the minimum or maximum element.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "It's possible to ensure that $$$q_1 < q_2 > q_3 < q_4 > q_5 \\ldots$$$",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let's number turns from $$$1$$$ to $$$n$$$. On odd turns, we take the minimum element and on even turns, we take the maximum element. We claim that $$$q_1 < q_2 > q_3 < q_4 > q_5 \\ldots$$$ (which is actually stronger than what the statement asked).Proof: consider taking the minimum on an odd turn : $$$q_i = \\min(p_l, p_r)$$$ where $$$l, r$$$ were the endpoints of the remaining array at turn $$$i$$$. Suppose without loss of generality the minimum was on the left, i.e. $$$q_i = p_l < p_r$$$. Then at the next turn, $$$p_r$$$ is still available:  $$$q_{i+1} = \\max(p_{l+1}, p_r) \\geq p_r > p_l = q_i$$$For example, if the remaining array at an odd turn is $$$[5, ?, \\ldots, 10]$$$, we take the minimum $$$5$$$, and then no matter what the $$$?$$$ is, we take at least $$$10$$$ which is greater than $$$5$$$. This proves $$$q_i < q_{i+1}$$$ when $$$i$$$ is odd. Similarly, we can prove $$$q_i > q_{i+1}$$$ when $$$i$$$ is even.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199677",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128C": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128C",
    "problem_title": "2128C - Самый левый меньший",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "Try to come up with a sufficient condition first, then prove it's necessary. Doing some examples with $$$n = 3$$$ might be useful.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let $$$m_i = \\min(b_1, \\ldots, b_{i-1})$$$ for every $$$2 \\leq i \\leq n$$$, which can be computed in linear time. We claim we can achieve $$$a = b$$$ if and only if $$$b_i - m_i < m_i$$$ for every $$$2 \\leq i \\leq n$$$.Proof that it's sufficient: we can build the array from left to right. For every $$$i$$$, if $$$b_i < m_i$$$ then we directly add $$$b_i$$$. Otherwise, we first add $$$b_i - m_i$$$, then $$$m_i$$$.Proof that it's necessary: suppose we managed to reach $$$b$$$. At every step, $$$a_i \\leq b_i$$$ for every $$$i$$$. Consider the last operation $$$x$$$ that incremented $$$a_i$$$. Then, by the definition of $$$i$$$, we must have  $$$a_i < x \\leq \\min(a_1, \\ldots, a_{i-1}) \\leq \\min(b_1, \\ldots, b_{i-1}).$$$Hence, $$$b_i = a_i + x \\leq 2x-1 \\leq 2m_i - 1$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199604",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128E1": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128E1",
    "problem_title": "2128E1 - Подмедианы (легкая версия)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "You can use binary search on the answer. Why ?",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "Let's start with a, perhaps, more natural task: finding whether or not $$$v$$$ is a submedian. To do so, we create an array $$$\\text{big}$$$ such that $$$\\text{big}[i] = 1 \\text{ if } \\text{a}[i] \\geq v \\text{ else } -1$$$We also create an array $$$\\text{small}$$$ such that $$$\\text{small}[i] = 1 \\text{ if } \\text{a}[i] \\leq v \\text{ else } -1$$$Knowing whether v is a submedian or not requires using both $$$\\mathrm{big}$$$ and $$$\\mathrm{small}$$$ ; when you want to know if the largest submedian is larger than or equal to v, do you actually need both arrays?",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Solve the relaxed problem where we only consider the first three constraints (and neglect the constraint on $$$\\mathrm{small}$$$) i.e finding the largest $$$v$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$",
        "codes": []
      },
      {
        "title": "hint4",
        "text": "Use binary search and prefix sums to rewrite the constraint on $$$\\text{big}$$$",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "Is the resulting value a submedian ?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "First, note that the predicate ``there exists a submedian $$$\\geq v$$$'' is monotonic. That is, if there exists a submedian $$$\\geq v$$$, then for all $$$v' < v$$$, there exists a submedian $$$\\geq v$$$. Thus, we can binary search to find the largest $$$v$$$ such that there exists a submedian $$$\\geq v$$$. Such a $$$v$$$ will be the largest submedian.Now, what is left is to check is, for a fixed $$$v$$$, whether or not there exists a submedian $$$\\geq v$$$. Let's start with a, perhaps, more natural task: finding whether or not $$$v$$$ is a submedian. To do so, we create an array $$$\\text{big}$$$ such that $$$\\text{big}[i] = 1 \\text{ if } \\text{a}[i] \\geq v \\text{ else } -1$$$We also create an array $$$\\text{small}$$$ such that $$$\\text{small}[i] = 1 \\text{ if } \\text{a}[i] \\leq v \\text{ else } -1$$$Using these notations, $$$v$$$ is a submedian iff there exists $$$(l, r)$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ $$$\\text{small}[l] + \\dots + \\text{small}[r] \\geq 0$$$ Let's try to solve a relaxed problem where we only consider the first three constraints (and neglect the constraint on $$$\\text{small}$$$ i.e finding the largest $$$v$$$ such that:  $$$1 \\leq l \\leq r \\leq n$$$, $$$r - l + 1 \\geq k$$$, $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ Such a problem is standard and can be easily solved in $$$\\mathcal{O}(n \\log n)$$$ by binary search and prefix sums. Indeed, for a fixed $$$v$$$, we can iterate over the value of $$$r$$$. Now: $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ iff $$$\\text{pref}[r] - \\text{pref}[l-1] \\geq 0$$$ i.e $$$\\text{pref}[r] \\geq \\text{pref}[l-1]$$$ so taking $$$l$$$ that minimizes $$$\\text{pref}[l-1]$$$ is optimal. Thus, it is enough to maintain such an $$$l$$$ in constant time (when you increase $$$r$$$, there is only one new candidate for $$$l$$$).Now, I claim that the value of $$$v$$$ we get happens to be the largest submedian. Indeed, if it doesn't satisfy $$$\\text{small}[l] + \\dots + \\text{small}[r] \\geq 0$$$, then $$$v + 1$$$ would still satisfy $$$\\text{big}[l] + \\dots + \\text{big}[r] \\geq 0$$$ which contradicts the maximality of $$$v$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199376",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128E2": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128E2",
    "problem_title": "2128E2 - Подмедианы (сложная версия)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "The set of submedians is a range. Try to prove it.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "For $$$l_1 \\leq r_1$$$ and $$$l_2, r_2$$$ such that $$$|l_1 - l_2| + |r_1 - r_2| \\leq 1$$$, both subarrays share at least one median. How to prove it ? Knowing this fact, how to prove Hint 1 ?",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Find a discretely ``continuous'' path from the subarray of the minimum submedian, to the subarray of the maximum submedian",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Read the editorial of E1 first.In such problems, it can be useful to try an easier version, for example, finding maximal/minimal values (which is why the subtask is helpful).Now, one can observe that if $$$x \\leq y$$$ are submedians, then any $$$z$$$ such that $$$x \\leq z \\leq y$$$ is also a submedian ! One can prove this using the intermediate value theorem. Let's fix $$$x \\leq z \\leq y$$$ and $$$[l_1, r_1]$$$ (resp. $$$[l_2, r_2]$$$) be a range where $$$x$$$ (resp. $$$y$$$) is a submedian. wlog, assume $$$l_1 < l_2$$$. Start by sweeping $$$r_1$$$ to $$$l_2$$$. Then $$$r_1$$$ to $$$r_2$$$. And finally, $$$l_1$$$ to $$$l_2$$$. Then one of the ranges that we covered has submedian $$$z$$$. Intuitively, when incrementing one of the ends of a range, the +1/-1 in the arrays big and small are not changing that much (the norm 1 distance is bounded by 2) so we can think of using the intermediate value theorem (see proof below). Also, note that at any time, the covered range is of length at least $$$k$$$.Thus, it is enough to find the smallest and largest submedians (using the solution of E1) and maintain the set of submedians while sweeping. One way to do that is to use a fenwick tree to simulate an ordered set (or you can also use two range sum point update queries to simulate the \\text{big} and \\text{small} arrays). Alternatively, you can use two sets (one with the lower half of the values of the current range, and one with the upper half). For each $$$[l, r]$$$ that our algorithm covers, we consider the point $$$(|{i \\in [l,r] \\mid a[i] \\geq z}| - |{i \\in [l,r] \\mid a[i] < z}|, |{i \\in [l,r] \\mid a[i] \\leq z}| - |{i \\in [l,r] \\mid a[i] > z}|)$$$ where $$$|A|$$$ is the cardinal of set $$$A$$$. Essentially, you can think of this point as an encoding of both conditions on small and big for $$$z$$$ to be a submedian.Note that, when moving one end of the range, each coordinate of the point changes by at most 1 (in absolute value). Also note that, by a simple computation, the sum of both coordinates is positive (it is equal to twice the number of $$$i$$$ such that $$$a[i] = z$$$).I claim that one of these points will have positive coordinates (thus, $$$z$$$ will be a submedian). Indeed: our path starts at a point with (negative first coordinate, positive second coordinate) and ends at a point with (positive first coordinate, negative second coordinate). Each move allows moving to a point at distance at most 2. However, you can see on the drawing below that one must pass through points with positive coordinates to achieve this (otherwise, you would be stuck in (negative first coordinate, positive second coordinate)).In red, the area with points such that $$$x+y \\geq 0$$$, below the green line are forbidden points. The blue points are our starting and ending points. Finally, the arrows are the possible moves after incrementing/decrementing one end of the range.",
        "codes": []
      },
      {
        "title": "code",
        "text": "Fenwick tree solution: 331199080 Two sets solution: 331198693",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128F": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128F",
    "problem_title": "2128F - Строгий треугольник",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Hint1aSay an edge is green if its weight is $$$l_i$$$ and red if its weight is $$$r_i$$$. If the answer is YES, prove there exists a solution that colors a path from $$$1$$$ to $$$n$$$ in green and the rest of the edges in red. Hint1bConsider an arbitrary solution $$$w$$$ and let $$$P$$$ be the shortest path from $$$1$$$ to $$$n$$$ with respect to $$$w$$$. Decreasing the weight of an edge in $$$P$$$ will decrease $$$d(1, n)$$$ by exactly one and will decrease $$$d(1, k) + d(k, n)$$$ by at most one. Increasing the weight of an edge outside $$$P$$$ will not increase $$$d(1, n)$$$ and will not decrease $$$d(1, k) + d(k, n)$$$. By repeating these operations, we can make $$$P$$$ green and the rest red.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "Hint2aLet $$$P$$$ be the chosen green path. Find a necessary condition for the corresponding weight assignment to be correct. Then, prove if it's sufficient. Hint2bThe condition is $$$d_L(u, v) < d_R(u, k) + d_R(k, v)$$$ for all $$$u, v \\in P$$$. Hint2cIt's obviously necessary; otherwise, $$$1 \\rightarrow_L u \\rightarrow_R k \\rightarrow_R v \\rightarrow_L n$$$ would have length $$$d(1, n)$$$. Conversely, if there exists a $$$1-n$$$ shortest path going through $$$k$$$, if you consider the last node in $$$P$$$ you visited before reaching $$$k$$$ and the first node in $$$P$$$ you visited after reaching $$$k$$$, this pair of nodes will violate the condition.",
        "codes": []
      },
      {
        "title": "hint3",
        "text": "Try to build a correct path using a Dijkstra-like algorithm. It might be helpful to have an intuitive understanding of the condition found in the previous hint in order to quantify with a single integer how good the current path is. Imagine you're a robber going from $$$1$$$ to $$$n$$$ and you don't want to be caught by cops.",
        "codes": []
      },
      {
        "title": "hint4",
        "text": "Imagine nodes are cities, $$$k$$$ is a police station, and you're some robber. Traversing the $$$i$$$-th edge takes $$$l_i$$$ seconds for the robber, and $$$r_i$$$ seconds for the citizens and the cops.Each time you go through a city, the citizens of this city will run to the police station to warn the cops. Once the cops are warned, they start dispatching in all directions as fast as they can to catch up to you.",
        "codes": []
      },
      {
        "title": "hint5",
        "text": "The current danger can be represented by an integer timer $$$x$$$. If $$$x < 0$$$, it means the cops will be warned in $$$-x$$$ seconds. If $$$x \\geq 0$$$, it means the cops have been warned since $$$0$$$ seconds. It's the only information you need to remember.",
        "codes": []
      },
      {
        "title": "hint6",
        "text": "Try to find for each node $$$u$$$ what is the corresponding minimum timer $$$t_u$$$. As the robber runs through the graph, the timer always increases, so you can do this with Dijkstra.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Please read all the hints first.We first make a classical Dijkstra from $$$k$$$ with $$$r$$$-weighted edges. Let $$$d_u$$$ be the distance between $$$u$$$ and $$$k$$$ for citizens/cops.We then make a modified Dijkstra, starting from the situation $$$(1, t_1)$$$ with $$$t_1 = -d_1$$$ (meaning the cops will be warned in $$$d_1$$$ seconds).When you traverse the $$$i$$$-th edge to go from $$$(u, t)$$$ to $$$v$$$, the new timer will be  $$$t' = \\max(t + l_i, -d_v).$$$We have $$$t' \\geq t+l_i$$$ because the previous timer continued to advance while the robber was traversing the edge, and $$$t' \\geq -d_v$$$ because a new citizen started running from $$$v$$$ to the police station.Each time, we take the situation with the minimum timer from the priority queue. If the node has already been processed, or if $$$d_u \\leq t_u$$$ (meaning the cops can catch up to the robber in $$$v$$$), the situation is skipped. The answer is YES if and only if we processed the node $$$n$$$.The time complexity is $$$\\mathcal{O}((n + m) \\log (n+m))$$$.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331198575",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2128D": {
    "contest_title": "Codeforces Round 1039 (Div. 2)",
    "problem_id": "2128D",
    "problem_title": "D. Sum of LDS",
    "time_limit": "2 seconds",
    "memory_limit": "256 megabytes",
    "statement": "You're given a permutation$$$^{\\text{∗}}$$$ $$$p_1, \\ldots, p_n$$$ such that $$$\\max(p_i, p_{i+1}) > p_{i+2}$$$ for all $$$1 \\leq i \\leq n-2$$$.Compute the sum of the length of the longest decreasing subsequence$$$^{\\text{†}}$$$ of the subarray $$$[p_l, p_{l+1}, \\ldots, p_r]$$$ over all pairs $$$1 \\leq l \\leq r \\leq n$$$.$$$^{\\text{∗}}$$$A permutation of length $$$n$$$ is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array), and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).$$$^{\\text{†}}$$$Given an array $$$b$$$ of size $$$|b|$$$, a decreasing subsequence of length $$$k$$$ is a sequence of indices $$$i_1, \\ldots, i_k$$$ such that:$$$1 \\leq i_1 < i_2 < \\ldots < i_k \\leq |b|$$$$$$b_{i_1} > b_{i_2} > \\ldots > b_{i_k}$$$\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10\\,000$$$). The description of the test cases follows.The first line of each test case contains a single integer $$$n$$$ ($$$3 \\leq n \\leq 500\\,000$$$).The second line of each test case contains $$$n$$$ integers $$$p_1, p_2, \\ldots, p_n$$$ ($$$1 \\le p_i \\le n$$$, $$$p_i$$$ are pairwise distinct).It is guaranteed that $$$\\max(p_i, p_{i+1}) > p_{i+2}$$$ for all $$$1 \\leq i \\leq n-2$$$.The sum of $$$n$$$ over all test cases does not exceed $$$500\\,000$$$.\n\nOutputFor each test case, output the sum over all subarrays of the length of its longest decreasing subsequence.",
    "sample_inputs": [
      "433 2 144 3 1 266 1 5 2 4 332 3 1"
    ],
    "sample_outputs": [
      "10\n17\n40\n8"
    ],
    "notes": "NoteFor any array $$$a$$$, we define $$$\\text{LDS}(a)$$$ as the length of the longest decreasing subsequence of $$$a$$$.In the first test case, all subarrays are decreasing.In the second one, we have$$$\\text{LDS}([4]) = \\text{LDS}([3]) = \\text{LDS}([1]) = \\text{LDS}([2]) = 1$$$$$$\\text{LDS}([4,3]) = \\text{LDS}([3,1]) = 2, \\text{LDS}([1, 2]) = 1$$$$$$\\text{LDS}([4,3,1]) = 3, \\text{LDS}([3,1,2]) = 2$$$$$$\\text{LDS}([4,3,1,2]) = 3$$$So the answer is $$$1+1+1+1+2+2+1+3+2+3=17$$$.",
    "tags": [
      "brute force",
      "combinatorics",
      "dp",
      "greedy",
      "math",
      "*1600"
    ],
    "url": "https://codeforces.com/problemset/problem/2128/D",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round #1039 — Editorial",
          "url": "/blog/entry/145080",
          "full_url": "https://codeforces.com/blog/entry/145080"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint1",
        "text": "Let $$$b_i = \\max(a_i, a_{i+1})$$$, show that $$$b_1 \\geq b_2 \\geq \\ldots \\geq b_{n-1}$$$.",
        "codes": []
      },
      {
        "title": "hint2",
        "text": "If $$$a_i < a_{i+1}$$$, show that $$$a_{i+1} > \\max(a_{i+2}, a_{i+3}, \\ldots a_{n})$$$.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "Let $$${i_1, \\ldots, i_m}$$$ be the set of $$$i \\in [1, n]$$$ such that $$$a_i > a_{i+1}$$$. Let us show that the sequence $$$(i_1, \\ldots, i_m)$$$ is an LDS:  It is a decreasing subsequence: let $$$k \\in [1, m -1]$$$. If $$$i_{k+1} = i_{k}+1$$$, then $$$a_{i_k} > a_{(i_k) + 1} = a_{i_{k+1}}$$$. Else, we have $$$a_{(i_k) + 2} < \\max(a_{i_k}, a_{(i_k)+1})$$$, but $$$i_k + 1$$$ is such that $$$a_{i_{k}+2} \\geq a_{i_{k+1}}$$$, so $$$a_{(i_k) + 2} < a_{i_k}$$$. We have also $$$a_{i_k + 1} < a_{i_k}$$$ by definition so we can easily prove by induction on $$$j > 0$$$ that $$$a_{i_k + j} < a_{i_k}$$$ where it makes sense. It's optimal : let $$$E$$$ be the set of indexes taken by a LDS. For each i such that $$$a_i \\leq a_{i+1}$$$, at least one of the elements of $$${i, i+1}$$$ does not belong to $$$E$$$. Now, these sets are disjoint : if $$$a_i < a_{i+1}$$$ we cannot have $$$a_{i+2} < a_{i+1}$$$ (otherwise the condition $$$\\max(a_i, a_{i+1}) > a_{i+2}$$$ is not met. So $$$|E| \\leq m$$$. To calculate the sum of the LDS of the sub-arrays, it is therefore sufficient to count for each $$$i$$$ such that $$$a_i < a_{i+1}$$$ the number of sub-arrays $$$a[l,r]$$$ which contain $$$i$$$ and $$$i + 1$$$. It's $$$(i+1) \\cdot (n - i - 1)$$$ for $$$0$$$-indexation : a necessary and sufficient condition is that $$$l \\leq i$$$ and $$$r \\geq i + 1$$$.Note that there also exists a dp approach, see this comment.",
        "codes": []
      },
      {
        "title": "code",
        "text": "331199533",
        "codes": []
      },
      {
        "title": "rate the problem",
        "text": "Amazing \n\n    \n\n\n\n\n\n\nGood \n\n    \n\n\n\n\n\n\nOk \n\n    \n\n\n\n\n\n\nBad \n\n    \n\n\n\n\n\n\nTerrible",
        "codes": []
      }
    ],
    "tutorials": [],
    "editorials": []
  },
  "2126A": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126A",
    "problem_title": "2126A - Only One Digit",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int x;\n    cin >> x;\n    int mn = 9;\n    while(x > 0) {\n      mn = min(mn, x % 10);\n      x/=10;\n    }\n    cout << mn << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int x;\n    cin >> x;\n    int mn = 9;\n    while(x > 0) {\n      mn = min(mn, x % 10);\n      x/=10;\n    }\n    cout << mn << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126B": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126B",
    "problem_title": "2126B - No Casino in the Mountains",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    int cnt = 0;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] == 1) {\n        ans+=(cnt + 1)/(k + 1);\n        cnt = 0;\n        continue;\n      }\n      else {\n        cnt++;\n      }\n    }\n    ans+=(cnt + 1)/(k + 1);\n    cout << ans << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    int cnt = 0;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] == 1) {\n        ans+=(cnt + 1)/(k + 1);\n        cnt = 0;\n        continue;\n      }\n      else {\n        cnt++;\n      }\n    }\n    ans+=(cnt + 1)/(k + 1);\n    cout << ans << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126C": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126C",
    "problem_title": "2126C - I Will Definitely Make It",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,p;\n    cin >> n >> p;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int cur = a[p];\n    int dist = a[p];\n    sort(a + 1,a + n + 1);\n    bool ans = true;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] < cur) continue;\n      if(a[i] &mdash; cur > dist) {\n        ans = false;\n      }\n      cur = a[i];\n    }\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,p;\n    cin >> n >> p;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int cur = a[p];\n    int dist = a[p];\n    sort(a + 1,a + n + 1);\n    bool ans = true;\n    for(int i = 1;i <= n;i++) {\n      if(a[i] < cur) continue;\n      if(a[i] &mdash; cur > dist) {\n        ans = false;\n      }\n      cur = a[i];\n    }\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126D": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126D",
    "problem_title": "2126D - This Is the Last Time",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    pair <int,pair <int,int> > p[n + 1];\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[ыi].second.first >> p[i].second.second;\n    sort(p + 1,p + n + 1);\n    int cur = k;\n    for(int i = 1;i <= n;i++) {\n      if(p[i].first > cur) break;\n      cur = max(cur,p[i].second.second);\n    }\n    cout << cur << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n,k;\n    cin >> n >> k;\n    pair <int,pair <int,int> > p[n + 1];\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[ыi].second.first >> p[i].second.second;\n    sort(p + 1,p + n + 1);\n    int cur = k;\n    for(int i = 1;i <= n;i++) {\n      if(p[i].first > cur) break;\n      cur = max(cur,p[i].second.second);\n    }\n    cout << cur << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126E": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126E",
    "problem_title": "2126E - G-C-D, Unlucky!",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nmain() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long a[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        long long b[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        long long ans[n + 1];\n        for (int i = n; i >= 1; i--) {\n            ans[i] = lcm(a[i], b[i]);\n        }\n        bool ch = 1;\n        if(ans[1] != a[1]) ch = 0;\n        if(ans[n] != b[n]) ch = 0;\n        for (int i = 2; i <= n; i++) {\n            if (__gcd(a[i &mdash; 1], ans[i]) != a[i]) {\n                ch = 0;\n            }\n        }\n        for (int i = n &mdash; 1; i >= 1; i--) {\n            if (__gcd(b[i + 1], ans[i]) != b[i]) {\n                ch = 0;\n            }\n        }\n        if (ch) {\n            cout << \"YES\" << \"\\n\";\n        } else {\n            cout << \"NO\" << \"\\n\";\n        }\n    }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nmain() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long a[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        long long b[n + 1];\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        long long ans[n + 1];\n        for (int i = n; i >= 1; i--) {\n            ans[i] = lcm(a[i], b[i]);\n        }\n        bool ch = 1;\n        if(ans[1] != a[1]) ch = 0;\n        if(ans[n] != b[n]) ch = 0;\n        for (int i = 2; i <= n; i++) {\n            if (__gcd(a[i &mdash; 1], ans[i]) != a[i]) {\n                ch = 0;\n            }\n        }\n        for (int i = n &mdash; 1; i >= 1; i--) {\n            if (__gcd(b[i + 1], ans[i]) != b[i]) {\n                ch = 0;\n            }\n        }\n        if (ch) {\n            cout << \"YES\" << \"\\n\";\n        } else {\n            cout << \"NO\" << \"\\n\";\n        }\n    }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126F": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126F",
    "problem_title": "2126F - 1-1-1, Free Tree!",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\nint n;\nint col[B];\nlong long costt = 0;\nvector <pair <int,int> > reb[B];\nbool was[B];\nmap <int,long long> cnt[B];\nint pred[B];\nlong long zn[B];\nvoid dfs(int v) {\n  was[v] = true;\n  for(auto u:reb[v]) {\n    if(was[u.first]) {\n      pred[v] = u.first;\n      continue;\n    }\n    if(col[v] != col[u.first]) costt+=u.second;\n    dfs(u.first);\n    zn[u.first] = u.second;\n    cnt[v][col[u.first]]+=zn[u.first];\n  }\n}\nvoid update(int v,int x) {\n  if(v != 1) {\n    cnt[pred[v]][col[v]]-=zn[v];\n    if(col[pred[v]] == col[v]) costt+=zn[v];\n    cnt[pred[v]][x]+=zn[v];\n    if(col[pred[v]] == x) costt-=zn[v];\n  }\n  else {\n      \n  }\n  costt+=cnt[v][col[v]];\n  costt-=cnt[v][x];\n  col[v] = x;\n}\nvoid clr() {\n  for(int i = 1;i <= n;i++) {\n    reb[i].clear();\n    was[i] = false;\n    cnt[i].clear();\n    zn[i] = 0;\n  }\n  costt = 0;\n}\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int q;\n    cin >> n >> q;\n    for(int i = 1; i <= n; i++) cin >> col[i];\n    for(int i = 1; i < n; i++) {\n      int u, v, c;\n      cin >> u >> v >> c;\n      reb[v].push_back({u,c});\n      reb[u].push_back({v,c});\n    }\n    dfs(1);\n    while(q--) {\n      int pos,x;\n      cin >> pos >> x;\n      update(pos,x);\n      cout << costt << \"\\n\";\n    }\n    clr();\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\nint n;\nint col[B];\nlong long costt = 0;\nvector <pair <int,int> > reb[B];\nbool was[B];\nmap <int,long long> cnt[B];\nint pred[B];\nlong long zn[B];\nvoid dfs(int v) {\n  was[v] = true;\n  for(auto u:reb[v]) {\n    if(was[u.first]) {\n      pred[v] = u.first;\n      continue;\n    }\n    if(col[v] != col[u.first]) costt+=u.second;\n    dfs(u.first);\n    zn[u.first] = u.second;\n    cnt[v][col[u.first]]+=zn[u.first];\n  }\n}\nvoid update(int v,int x) {\n  if(v != 1) {\n    cnt[pred[v]][col[v]]-=zn[v];\n    if(col[pred[v]] == col[v]) costt+=zn[v];\n    cnt[pred[v]][x]+=zn[v];\n    if(col[pred[v]] == x) costt-=zn[v];\n  }\n  else {\n      \n  }\n  costt+=cnt[v][col[v]];\n  costt-=cnt[v][x];\n  col[v] = x;\n}\nvoid clr() {\n  for(int i = 1;i <= n;i++) {\n    reb[i].clear();\n    was[i] = false;\n    cnt[i].clear();\n    zn[i] = 0;\n  }\n  costt = 0;\n}\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int q;\n    cin >> n >> q;\n    for(int i = 1; i <= n; i++) cin >> col[i];\n    for(int i = 1; i < n; i++) {\n      int u, v, c;\n      cin >> u >> v >> c;\n      reb[v].push_back({u,c});\n      reb[u].push_back({v,c});\n    }\n    dfs(1);\n    while(q--) {\n      int pos,x;\n      cin >> pos >> x;\n      update(pos,x);\n      cout << costt << \"\\n\";\n    }\n    clr();\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126G1": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126G1",
    "problem_title": "2126G1 - Big Wins! (easy version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    for(int i = 1;i <= 100;i++) {\n      int b[n + 1] = {};\n      for(int j = 1;j <= n;j++) {\n        if(a[j] >= i) b[j] = 1;\n        else b[j] = -1;\n      }\n      int pref[n + 1] = {};\n      for(int j = 1; j <= n; j++) {\n        pref[j] = pref[j - 1] + b[j]; \n      }\n      int prefmn[n + 2] = {},suffmx[n + 1] = {};\n      prefmn[0] = 0,suffmx[n] = pref[n];\n      for(int j = 1; j <= n; j++) {\n        prefmn[j] = min(prefmn[j - 1],pref[j]);\n      }\n      for(int j = n - 1; j >= 1; j--) {\n        suffmx[j] = max(suffmx[j + 1],pref[j]);\n      }\n      for(int j = 1; j <= n; j++) {\n        if(prefmn[j - 1] <= pref[j] || pref[j - 1] <= suffmx[j]) {\n          ans = max(ans,i - a[j]);\n        }\n      }\n    } \n    cout << ans << endl;\n  }\n}",
        "codes": [
          "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 2e5 + 100;\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for(int i = 1;i <= n;i++) cin >> a[i];\n    int ans = 0;\n    for(int i = 1;i <= 100;i++) {\n      int b[n + 1] = {};\n      for(int j = 1;j <= n;j++) {\n        if(a[j] >= i) b[j] = 1;\n        else b[j] = -1;\n      }\n      int pref[n + 1] = {};\n      for(int j = 1; j <= n; j++) {\n        pref[j] = pref[j - 1] + b[j]; \n      }\n      int prefmn[n + 2] = {},suffmx[n + 1] = {};\n      prefmn[0] = 0,suffmx[n] = pref[n];\n      for(int j = 1; j <= n; j++) {\n        prefmn[j] = min(prefmn[j - 1],pref[j]);\n      }\n      for(int j = n - 1; j >= 1; j--) {\n        suffmx[j] = max(suffmx[j + 1],pref[j]);\n      }\n      for(int j = 1; j <= n; j++) {\n        if(prefmn[j - 1] <= pref[j] || pref[j - 1] <= suffmx[j]) {\n          ans = max(ans,i - a[j]);\n        }\n      }\n    } \n    cout << ans << endl;\n  }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "2126G2": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "2126G2",
    "problem_title": "G2. Big Wins! (hard version)",
    "time_limit": "4 seconds",
    "memory_limit": "256 megabytes",
    "statement": "This is the hard version of the problem. The difference between the versions is that in this version $$$a_i \\leq n$$$.You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$.Your task is to find a subarray $$$a[l, r]$$$ (a continuous sequence of elements $$$a_l, a_{l + 1}, \\dots, a_r$$$) for which the value of the expression $$$\\text{med}(a[l, r]) - \\min(a[l, r])$$$ is maximized.Here:$$$\\text{med}$$$ is the median of the subarray, that is, the element at position $$$\\left\\lceil \\frac{k + 1}{2} \\right\\rceil$$$ after sorting the subarray, where $$$k$$$ is its length;$$$\\min$$$ is the minimum element of this subarray.For example, consider the array $$$a=[1, 4, 1, 5, 3, 3]$$$ and choose the subarray $$$a[2, 5] = [4, 1, 5, 3]$$$. In sorted form, it looks like $$$[1, 3, 4, 5]$$$.$$$\\text{med}(a[2, 5]) = 4$$$, since $$$\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil = $$$ the third element in the sorted subarray is $$$4$$$;$$$\\min(a[2, 5]) = 1$$$, since the minimum element is $$$1$$$.In this example, the value $$$\\text{med} - \\min = 4 - 1 = 3$$$.\n\nInputThe first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the array.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.\n\nOutputFor each test case, output one integer — the maximum possible value of $$$\\text{med} - \\min$$$ among all subarrays of the array.",
    "sample_inputs": [
      "553 2 5 3 144 1 1 376 1 3 4 6 2 744 2 3 151 2 3 4 5"
    ],
    "sample_outputs": [
      "3\n3\n5\n2\n2"
    ],
    "notes": "NoteIn the first example, consider the array: $$$a=[3,\\ 2,\\ 5,\\ 3,\\ 1]$$$ you can choose the subarray $$$a[2,\\ 3]$$$, that is, the elements $$$[2,\\ 5]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[2,\\ 5]$$$, $$$\\text{med} = 5$$$.The minimum element of the subarray: $$$\\min = 2$$$.Therefore, $$$\\text{med} - \\min = 5 - 2 = 3$$$, which is the maximum answer.In the second test, the array: $$$a=[4,\\ 1,\\ 1,\\ 3]$$$ you can choose the subarray $$$a[1,\\ 2]$$$, that is, the elements $$$[4,\\ 1]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[1,\\ 4]$$$, $$$\\text{med} = 4$$$.The minimum element of the subarray: $$$\\min = 1$$$.Therefore, $$$\\text{med} - \\min = 4 - 1 = 3$$$.It can be proven that both of these subarrays are optimal and yield the maximum value of the expression $$$\\text{med} - \\min$$$.",
    "tags": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dsu",
      "trees",
      "two pointers",
      "*2400"
    ],
    "url": "https://codeforces.com/contest/2126/problem/G2",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint a[200005 + 2];\narray<int, 4> t[800005];\narray<int, 4> merge(array<int, 4>a, array<int, 4>b) {\n    int ans = max(a[0], b[0]);\n    int mxpref = max(a[1], a[3] + b[1]);\n    int mxsuff = max(b[2], a[2] + b[3]);\n    ans = max({ans, mxpref, mxsuff});\n    int sum = a[3] + b[3];\n    return {ans, mxpref, mxsuff, sum};\n}\nvoid update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n        t[v] = {max(val, 0), max(val, 0), max(val, 0), val};\n    } else {\n        int tm = (tl + tr) >> 1;\n        if (pos <= tm) {\n            update(v * 2, tl, tm, pos, val);\n        } else {\n            update(v * 2 + 1, tm + 1, tr, pos, val);\n        }\n        t[v] = merge(t[v * 2], t[v * 2 + 1]);\n    }\n}\narray<int, 4> get(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n        return t[v];\n    } else if (l > r) {\n        return {0, 0, 0, 0};\n    } else {\n        int tm = (tl + tr) >> 1;\n        return merge(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n}\nint solve(int n, vector<int>A) {\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n        m = max(m, a[i]);\n    }\n    vector<int>ind[m + 1];\n    for (int i = 1; i <= n; i++) {\n        ind[a[i]].push_back(i);\n    }\n    stack<int>s;\n    s.push(0);\n    a[0] = -INT_MAX;\n    int l[n + 1];\n    for (int i = 1; i <= n; i++) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        l[i] = s.top() + 1;\n        s.push(i);\n    }\n    a[n + 1] = -INT_MAX;\n    s.push(n + 1);\n    int r[n + 1];\n    for (int i = n; i >= 1; i--) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        r[i] = s.top() &mdash; 1;\n        s.push(i);\n    }\n    int med = 1;\n    for (int i = 1; i <= n; i++) {\n        update(1, 1, n, i, 1);\n    }\n    for (auto u : ind[1]) {\n        update(1, 1, n, u, -1);\n    }\n    int ans = 0;\n    for (int mn = 1; mn <= m; mn++) {\n        for (auto u : ind[mn]) {\n            int lg = l[u], rg = r[u];\n            while (med < m && get(1, 1, n, lg, u &mdash; 1)[2] + get(1, 1, n, u + 1, rg)[1] + (a[u] < (med) ? -1 : 1) >= 0) {\n                med++;\n                for (auto u : ind[med]) {\n                    update(1, 1, n, u, -1);\n                }\n            }\n        }\n        // cout << med << ' ' << mn << endl;\n        ans = max(ans, med &mdash; mn);\n    }\n    return ans;\n}\nint solveslow(int n, vector<int>A) {\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        vector<int>v;\n        for (int j = i; j <= n; j++) {\n            v.push_back(a[j]);\n            sort(v.begin(), v.end());\n            mx = max(mx, v[v.size() / 2] &mdash; v[0]);\n        }\n    }\n    return mx;\n}\nint rnd() {\n    return (rand() + rand() * RAND_MAX);\n}\nmain() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while(tt--) {\n        int n;\n        cin >> n;\n        vector<int>v;\n        for (int i = 1; i <= n; i++) {\n            int x;\n            cin >> x;\n            v.push_back(x);\n        }\n        cout << solve(n, v) << endl;\n        // cout << solveslow(n, v) << endl;\n        for(int i = 0;i <= n*4;i++) {\n            t[i][0] = 0;\n            t[i][1] = 0;\n            t[i][2] = 0;\n            t[i][3] = 0;\n        }\n    }\n}",
        "codes": [
          "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint a[200005 + 2];\narray<int, 4> t[800005];\narray<int, 4> merge(array<int, 4>a, array<int, 4>b) {\n    int ans = max(a[0], b[0]);\n    int mxpref = max(a[1], a[3] + b[1]);\n    int mxsuff = max(b[2], a[2] + b[3]);\n    ans = max({ans, mxpref, mxsuff});\n    int sum = a[3] + b[3];\n    return {ans, mxpref, mxsuff, sum};\n}\nvoid update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n        t[v] = {max(val, 0), max(val, 0), max(val, 0), val};\n    } else {\n        int tm = (tl + tr) >> 1;\n        if (pos <= tm) {\n            update(v * 2, tl, tm, pos, val);\n        } else {\n            update(v * 2 + 1, tm + 1, tr, pos, val);\n        }\n        t[v] = merge(t[v * 2], t[v * 2 + 1]);\n    }\n}\narray<int, 4> get(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n        return t[v];\n    } else if (l > r) {\n        return {0, 0, 0, 0};\n    } else {\n        int tm = (tl + tr) >> 1;\n        return merge(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n}\nint solve(int n, vector<int>A) {\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n        m = max(m, a[i]);\n    }\n    vector<int>ind[m + 1];\n    for (int i = 1; i <= n; i++) {\n        ind[a[i]].push_back(i);\n    }\n    stack<int>s;\n    s.push(0);\n    a[0] = -INT_MAX;\n    int l[n + 1];\n    for (int i = 1; i <= n; i++) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        l[i] = s.top() + 1;\n        s.push(i);\n    }\n    a[n + 1] = -INT_MAX;\n    s.push(n + 1);\n    int r[n + 1];\n    for (int i = n; i >= 1; i--) {\n        while (a[s.top()] >= a[i]) {\n            s.pop();\n        }\n        r[i] = s.top() &mdash; 1;\n        s.push(i);\n    }\n    int med = 1;\n    for (int i = 1; i <= n; i++) {\n        update(1, 1, n, i, 1);\n    }\n    for (auto u : ind[1]) {\n        update(1, 1, n, u, -1);\n    }\n    int ans = 0;\n    for (int mn = 1; mn <= m; mn++) {\n        for (auto u : ind[mn]) {\n            int lg = l[u], rg = r[u];\n            while (med < m && get(1, 1, n, lg, u &mdash; 1)[2] + get(1, 1, n, u + 1, rg)[1] + (a[u] < (med) ? -1 : 1) >= 0) {\n                med++;\n                for (auto u : ind[med]) {\n                    update(1, 1, n, u, -1);\n                }\n            }\n        }\n        // cout << med << ' ' << mn << endl;\n        ans = max(ans, med &mdash; mn);\n    }\n    return ans;\n}\nint solveslow(int n, vector<int>A) {\n    for (int i = 1; i <= n; i++) {\n        a[i] = A[i &mdash; 1];\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        vector<int>v;\n        for (int j = i; j <= n; j++) {\n            v.push_back(a[j]);\n            sort(v.begin(), v.end());\n            mx = max(mx, v[v.size() / 2] &mdash; v[0]);\n        }\n    }\n    return mx;\n}\nint rnd() {\n    return (rand() + rand() * RAND_MAX);\n}\nmain() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while(tt--) {\n        int n;\n        cin >> n;\n        vector<int>v;\n        for (int i = 1; i <= n; i++) {\n            int x;\n            cin >> x;\n            v.push_back(x);\n        }\n        cout << solve(n, v) << endl;\n        // cout << solveslow(n, v) << endl;\n        for(int i = 0;i <= n*4;i++) {\n            t[i][0] = 0;\n            t[i][1] = 0;\n            t[i][2] = 0;\n            t[i][3] = 0;\n        }\n    }\n}"
        ]
      }
    ],
    "tutorials": [
      {
        "title": "tutorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ],
    "editorials": []
  },
  "problemG2": {
    "contest_title": "Codeforces Round 1037 (Div. 3)",
    "problem_id": "problemG2",
    "problem_title": "G2. Big Wins! (hard version)",
    "time_limit": "4 seconds",
    "memory_limit": "256 megabytes",
    "statement": "This is the hard version of the problem. The difference between the versions is that in this version $$$a_i \\leq n$$$.You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$.Your task is to find a subarray $$$a[l, r]$$$ (a continuous sequence of elements $$$a_l, a_{l + 1}, \\dots, a_r$$$) for which the value of the expression $$$\\text{med}(a[l, r]) - \\min(a[l, r])$$$ is maximized.Here:$$$\\text{med}$$$ is the median of the subarray, that is, the element at position $$$\\left\\lceil \\frac{k + 1}{2} \\right\\rceil$$$ after sorting the subarray, where $$$k$$$ is its length;$$$\\min$$$ is the minimum element of this subarray.For example, consider the array $$$a=[1, 4, 1, 5, 3, 3]$$$ and choose the subarray $$$a[2, 5] = [4, 1, 5, 3]$$$. In sorted form, it looks like $$$[1, 3, 4, 5]$$$.$$$\\text{med}(a[2, 5]) = 4$$$, since $$$\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil = $$$ the third element in the sorted subarray is $$$4$$$;$$$\\min(a[2, 5]) = 1$$$, since the minimum element is $$$1$$$.In this example, the value $$$\\text{med} - \\min = 4 - 1 = 3$$$.\n\nInputThe first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the array.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.\n\nOutputFor each test case, output one integer — the maximum possible value of $$$\\text{med} - \\min$$$ among all subarrays of the array.",
    "sample_inputs": [
      "553 2 5 3 144 1 1 376 1 3 4 6 2 744 2 3 151 2 3 4 5"
    ],
    "sample_outputs": [
      "3\n3\n5\n2\n2"
    ],
    "notes": "NoteIn the first example, consider the array: $$$a=[3,\\ 2,\\ 5,\\ 3,\\ 1]$$$ you can choose the subarray $$$a[2,\\ 3]$$$, that is, the elements $$$[2,\\ 5]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[2,\\ 5]$$$, $$$\\text{med} = 5$$$.The minimum element of the subarray: $$$\\min = 2$$$.Therefore, $$$\\text{med} - \\min = 5 - 2 = 3$$$, which is the maximum answer.In the second test, the array: $$$a=[4,\\ 1,\\ 1,\\ 3]$$$ you can choose the subarray $$$a[1,\\ 2]$$$, that is, the elements $$$[4,\\ 1]$$$.The length of the subarray is $$$2$$$.The median is the element at position $$$\\left\\lceil \\dfrac{3}{2} \\right\\rceil = 2$$$ in the sorted subarray. After sorting, we get $$$[1,\\ 4]$$$, $$$\\text{med} = 4$$$.The minimum element of the subarray: $$$\\min = 1$$$.Therefore, $$$\\text{med} - \\min = 4 - 1 = 3$$$.It can be proven that both of these subarrays are optimal and yield the maximum value of the expression $$$\\text{med} - \\min$$$.",
    "tags": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dsu",
      "trees",
      "two pointers",
      "*2400"
    ],
    "url": "https://codeforces.com/contest/2126/problem/G2",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "144845",
          "url": "/blog/entry/144845",
          "full_url": "https://codeforces.com/blog/entry/144845"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [],
    "tutorials": [],
    "editorials": []
  },
  "2129E": {
    "contest_title": "Codeforces Round 1040 (Div. 1)",
    "problem_id": "2129E",
    "problem_title": "E. Induced Subgraph Queries",
    "time_limit": "5 seconds",
    "memory_limit": "512 megabytes",
    "statement": "You are given an unweighted, undirected graph $$$G$$$ with $$$n$$$ nodes and $$$m$$$ edges. The graph $$$G$$$ contains no self-loops or multiple edges.We denote the node set of $$$G$$$ as $$$V$$$. For any node subset $$$V' \\subseteq V$$$, the corresponding induced subgraph, denoted by $$$G[V']$$$, is defined as follows:$$$G[V']$$$ is the graph whose node set is $$$V'$$$, and whose edge set consists of all edges in $$$G$$$ with both endpoints in $$$V'$$$.Your task is to answer $$$q$$$ queries. Each query provides three integers $$$l$$$, $$$r$$$, and $$$k$$$. Denoting $$$V'=\\{l,l+1,\\ldots,r\\}$$$, you need to find the $$$k$$$-th smallest value among $$$f(l,G[V'])$$$, $$$f(l+1,G[V'])$$$, $$$\\ldots$$$ , $$$f(r,G[V'])$$$ (i.e., the $$$k$$$-th value in increasing order; repeated values are counted multiple times).Here, $$$f(u,G[V'])=\\bigoplus_{(u,v)\\in G[V']}v$$$. In other words, it is thebitwise XORvalue of the labels of all adjacent nodes of node $$$u$$$ in graph $$$G[V']$$$.You might want to read the notes for a better understanding.\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 1.5 \\cdot 10^4$$$). The description of the test cases follows.Each test case begins with two integers $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 1.5 \\cdot 10^5$$$, $$$1 \\leq m \\leq 1.5 \\cdot 10^5$$$) — the number of nodes and edges, respectively.The next $$$m$$$ lines each contain two integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\leq u_i, v_i \\leq n$$$, $$$u_i \\neq v_i$$$), representing an undirected edge between nodes $$$u_i$$$ and $$$v_i$$$.The next line contains a single integer $$$q$$$ ($$$1 \\leq q \\leq 1.5 \\cdot 10^5$$$) — the number of queries.Each of the next $$$q$$$ lines contains three integers $$$l$$$, $$$r$$$, and $$$k$$$ ($$$1 \\leq l \\leq r \\leq n$$$, $$$1 \\le k \\le r-l+1$$$), defining a query about the induced subgraph $$$G[\\{l,\\ldots,r\\}]$$$.It is guaranteed that the graph contains no self-loops or multiple edges.It is guaranteed that the sum of $$$n$$$,$$$m$$$, and $$$q$$$ over all test cases does not exceed $$$1.5 \\cdot 10^5$$$, respectively.\n\nOutputFor each test case, output $$$q$$$ integers, representing the answer for each query.",
    "sample_inputs": [
      "24 51 31 42 32 43 431 2 21 3 12 4 32 12 131 1 12 2 11 2 2"
    ],
    "sample_outputs": [
      "0\n3\n7\n0\n0\n2"
    ],
    "notes": "NoteIn the first test case, the input graph $$$G$$$ is the one in the following picture.The given graph $$$G$$$.In the first query, the induced subgraph $$$G[\\{1,2\\}]$$$ is the one in the following picture. We can see that nodes $$$1$$$ and $$$2$$$ have no adjacent nodes. Thus, $$$f(1,G[\\{1,2\\}])=f(2,G[\\{1,2\\}])=0$$$. The $$$2$$$-nd smallest value is $$$0$$$.$$$G[\\{1,2\\}]$$$.In the second query, the induced subgraph $$$G[\\{1,2,3\\}]$$$ is the one in the following picture. We can see that $$$f(1,G[\\{1,2,3\\}])=3$$$, $$$f(2,G[\\{1,2,3\\}])=3$$$, and $$$f(3,G[\\{1,2,3\\}])=1 \\oplus 2=3$$$. The $$$1$$$-st smallest value is $$$3$$$.$$$G[\\{1,2,3\\}]$$$.In the third query, the induced subgraph $$$G[\\{2,3,4\\}]$$$ is the one in the following picture. We can see that $$$f(2,G[\\{2,3,4\\}])=3 \\oplus 4=7$$$, $$$f(3,G[\\{2,3,4\\}])=2 \\oplus 4=6$$$, and $$$f(4,G[\\{2,3,4\\}])=2 \\oplus 3=1$$$. The $$$3$$$-rd smallest value is $$$7$$$.$$$G[\\{2,3,4\\}]$$$.",
    "tags": [
      "data structures",
      "graphs",
      "sortings",
      "*3000"
    ],
    "url": "https://codeforces.com/problemset/problem/2129/E",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial(en)",
          "title": "Codeforces Round 1040 (Div. 1, Div. 2) Editorial",
          "url": "/blog/entry/145152",
          "full_url": "https://codeforces.com/blog/entry/145152"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [],
    "tutorials": [],
    "editorials": []
  },
  "2132B": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132B",
    "problem_title": "2132B - The Secret Number",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint",
        "text": "If Vadim appends $$$k$$$ zeros to the number $$$x$$$, what will be the ratio between $$$n$$$ and $$$x$$$? Answer$$$n = x \\cdot (10^k + 1)$$$",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long r;\n        cin >> r;\n        \n        long long d = 11;\n        vector <long long> ans;\n        while (r >= d) {\n            if (r % d == 0)\n                ans.push_back(r / d);\n            d = (d - 1) * 10 + 1;\n        }\n        \n        cout << (int)ans.size() << '\\n';\n        for (int i = (int)ans.size() - 1; i >= 0; --i)\n            cout << ans[i] << ' ';\n        cout << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long r;\n        cin >> r;\n        \n        long long d = 11;\n        vector <long long> ans;\n        while (r >= d) {\n            if (r % d == 0)\n                ans.push_back(r / d);\n            d = (d - 1) * 10 + 1;\n        }\n        \n        cout << (int)ans.size() << '\\n';\n        for (int i = (int)ans.size() - 1; i >= 0; --i)\n            cout << ans[i] << ' ';\n        cout << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132C1": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132C1",
    "problem_title": "2132C1 - The Cunning Seller (easy version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Does it make sense to use the same type of deal more than 2 times?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "The solution with the minimum number of deals is unique.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "Ternary numeral system.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n;\n        cin >> n;\n        long long min_k = 0;\n        long long min_cost = 0;\n        int sz = 0;\n        while (n) {\n            min_k += n % 3;\n            min_cost += (n % 3) * cost[sz];\n            n /= 3;\n            sz++;\n        }\n        cout << min_cost << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n;\n        cin >> n;\n        long long min_k = 0;\n        long long min_cost = 0;\n        int sz = 0;\n        while (n) {\n            min_k += n % 3;\n            min_cost += (n % 3) * cost[sz];\n            n /= 3;\n            sz++;\n        }\n        cout << min_cost << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132C2": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132C2",
    "problem_title": "2132C2 - The Cunning Seller (hard version)",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "What is more profitable: 3 deals for $$$3^x$$$ watermelons each, or 1 deal for $$$3^{x+1}$$$ watermelons?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Recall the solution to problem C1.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n, k;\n        cin >> n >> k;\n        vector <long long> tr;\n        long long min_k = 0;\n        while (n) {\n            tr.push_back(n % 3);\n            min_k += n % 3;\n            n /= 3;\n        }\n        if (min_k > k) {\n            cout << -1 << '\\n';\n            continue;\n        }\n        k -= min_k;\n        k /= 2;\n        for (int i = (int)tr.size() - 1; i >= 1; --i) {\n            if (tr[i] <= k) {\n                tr[i - 1] += 3 * tr[i];\n                k -= tr[i];\n                tr[i] = 0;\n            } else {\n                tr[i - 1] += k * 3;\n                tr[i] -= k;\n                break;\n            }\n        }\n        ll an = 0;\n        for (int i = (int)tr.size() - 1; i >= 0; --i)\n            an += cost[i] * tr[i];\n        cout << an << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    vector <long long> cost;\n    long long c = 3;\n    long long cnt = 1;\n    for (int i = 0; i < 21; ++i) {\n        cost.push_back(c);\n        c = 3 * c + cnt;\n        cnt *= 3;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n, k;\n        cin >> n >> k;\n        vector <long long> tr;\n        long long min_k = 0;\n        while (n) {\n            tr.push_back(n % 3);\n            min_k += n % 3;\n            n /= 3;\n        }\n        if (min_k > k) {\n            cout << -1 << '\\n';\n            continue;\n        }\n        k -= min_k;\n        k /= 2;\n        for (int i = (int)tr.size() - 1; i >= 1; --i) {\n            if (tr[i] <= k) {\n                tr[i - 1] += 3 * tr[i];\n                k -= tr[i];\n                tr[i] = 0;\n            } else {\n                tr[i - 1] += k * 3;\n                tr[i] -= k;\n                break;\n            }\n        }\n        ll an = 0;\n        for (int i = (int)tr.size() - 1; i >= 0; --i)\n            an += cost[i] * tr[i];\n        cout << an << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132D": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132D",
    "problem_title": "2132D - From 1 to Infinity",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Find out which number the $$$k$$$-th digit belongs to in the infinite sequence. Let this number be $$$n$$$. Instead of analyzing the sequence, we can calculate the sum of the sums of the digits of all integers from $$$0$$$ to $$$n - 1$$$ and add to this the sum of the required digits of the number $$$n$$$.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "Mentally add leading zeros to all numbers from $$$0$$$ to $$$n - 1$$$ so that their lengths become the same. The sum of the sums of the digits will not change, but it will be more convenient to determine the formulas in this case.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long k;\n        cin >> k;\n        long long cur = 9, len = 1;\n        while (k - cur * len > 0) {\n            k -= cur * len;\n            cur *= 10;\n            len++;\n        }\n        string s = to_string(cur / 9 + (k - 1) / len);\n        long long ans = 0;\n        for (int i = 0; i < (k - 1) % len + 1; i++)\n            ans += s[i] - '0';\n        long long pr_s = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int curd = s[i] - '0';\n            if (curd)\n                ans += curd * (len - 1) * cur / 2 + curd * (2 * pr_s + curd - 1) / 2 * cur / 9;\n            cur /= 10, len--;\n            pr_s += curd;\n        }\n        cout << ans << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long k;\n        cin >> k;\n        long long cur = 9, len = 1;\n        while (k - cur * len > 0) {\n            k -= cur * len;\n            cur *= 10;\n            len++;\n        }\n        string s = to_string(cur / 9 + (k - 1) / len);\n        long long ans = 0;\n        for (int i = 0; i < (k - 1) % len + 1; i++)\n            ans += s[i] - '0';\n        long long pr_s = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int curd = s[i] - '0';\n            if (curd)\n                ans += curd * (len - 1) * cur / 2 + curd * (2 * pr_s + curd - 1) / 2 * cur / 9;\n            cur /= 10, len--;\n            pr_s += curd;\n        }\n        cout << ans << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132E": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132E",
    "problem_title": "2132E - Arithmetics Competition",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "If we know how many specific cards Vadim should take, and how many should take Kostya (for example when $$$x + y = z$$$). How can we then obtain the maximum possible sum?",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "We need to quickly compute the sum of the $$$x$$$ maximum elements in array $$$a$$$ and the sum of the $$$y$$$ maximum elements in array $$$b$$$. What should we do to be able to compute this for arbitrary $$$x$$$ and $$$y$$$ in $$$O(1)$$$?",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "How can we solve this problem if $$$x = n$$$ and $$$y = m$$$ — that is, each person can choose any number of cards, as long as their total is $$$z$$$?",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "If $$$x = n$$$ and $$$y = m$$$, then the optimal set of $$$z$$$ cards consists of $$$x'$$$ maximum cards from Vadim and $$$y'$$$ maximum cards from Kostya (where $$$x' + y' = z$$$). How should we adjust this optimal answer if the optimal number for Vadim or Kostya exceeds their limits (that is, if $$$x < x'$$$ or $$$y < y'$$$)?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution 1",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n\n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n\n    vector <pair <int, int>> ans(n + m + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i < ans.size(); i++) {\n        if (l < n && r < m) {\n            if (a[l] < b[r])\n                r++;\n            else\n                l++;\n        }\n        else if (l == n)\n            r++;\n        else if (r == m)\n            l++;\n        ans[i] = { l, r };\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        l = ans[z].first, r = ans[z].second;\n        if (l > x)\n            cout << pa[x] + pb[z - x] << '\\n';\n        else if (r > y)\n            cout << pa[z - y] + pb[y] << '\\n';\n        else\n            cout << pa[l] + pb[r] << '\\n';\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n\n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n\n    vector <pair <int, int>> ans(n + m + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i < ans.size(); i++) {\n        if (l < n && r < m) {\n            if (a[l] < b[r])\n                r++;\n            else\n                l++;\n        }\n        else if (l == n)\n            r++;\n        else if (r == m)\n            l++;\n        ans[i] = { l, r };\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        l = ans[z].first, r = ans[z].second;\n        if (l > x)\n            cout << pa[x] + pb[z - x] << '\\n';\n        else if (r > y)\n            cout << pa[z - y] + pb[y] << '\\n';\n        else\n            cout << pa[l] + pb[r] << '\\n';\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      },
      {
        "title": "solution 2",
        "text": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n \n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n \n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n \n        int l = max(0, z - y);\n        int r = min(z, x);\n        while (l + 2 < r) {\n            int m1 = (l + l + r) / 3;\n            int m2 = (l + r + r) / 3;\n            if (pa[m1] + pb[z - m1] > pa[m2] + pb[z - m2]) {\n                r = m2;\n            } else {\n                l = m1;\n            }\n        }\n \n        long long s = 0;\n        for (int i = l; i <= r; i++)\n            s = max(s, pa[i] + pb[z - i]);\n \n        cout << s << '\\n';\n    }\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector <int> a(n), b(m);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    sort(a.rbegin(), a.rend());\n    sort(b.rbegin(), b.rend());\n \n    vector <long long> pa(n + 1), pb(m + 1);\n    for (int i = 0; i < n; i++)\n        pa[i + 1] = pa[i] + a[i];\n    for (int i = 0; i < m; i++)\n        pb[i + 1] = pb[i] + b[i];\n \n    for (int i = 0; i < q; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n \n        int l = max(0, z - y);\n        int r = min(z, x);\n        while (l + 2 < r) {\n            int m1 = (l + l + r) / 3;\n            int m2 = (l + r + r) / 3;\n            if (pa[m1] + pb[z - m1] > pa[m2] + pb[z - m2]) {\n                r = m2;\n            } else {\n                l = m1;\n            }\n        }\n \n        long long s = 0;\n        for (int i = l; i <= r; i++)\n            s = max(s, pa[i] + pb[z - i]);\n \n        cout << s << '\\n';\n    }\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132F": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132F",
    "problem_title": "2132F - Rada and the Chamomile Valley",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "Recall or learn what bridges are and understand how this is related to the lanes that lie on all paths from $$$1$$$ to $$$n$$$.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "How to find all the bridges that lie on every path from $$$1$$$ to $$$n$$$?",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "Solve the problem for the case where $$$n = q$$$ and $$$c_i = i$$$.",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "How to find the nearest vertex from a given set of vertices $$$S$$$ for each vertex?",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvector <vector <int>> g;\nvector <bool> used;\nvector <int> d, h;\nvector <pair <int, int>> edges;\nvector <int> cut, path;\nint mark = 1;\n\nvoid dfs(int v, int p, int n) {\n    used[v] = true;\n    d[v] = h[v] = (p == -1 ? 0 : d[p] + 1);\n    if (v == n) mark = 0;\n    for (auto e : g[v]) {\n        int to = edges[e].first + edges[e].second - v;\n        if (to == p) continue;\n        if (used[to])\n            h[v] = min(h[v], d[to]);\n        else {\n            path[e] ^= mark;\n            dfs(to, v, n);\n            path[e] ^= mark;\n            h[v] = min(h[v], h[to]);\n            if (h[to] > d[v]) cut[e] = 1;\n        }\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        g.assign(n + 1, {});\n        used.assign(n + 1, false);\n        d.assign(n + 1, 0);\n        h.assign(n + 1, 0);\n        edges = {};\n        cut.assign(m, false);\n        path.assign(m, false);\n        mark = 1;\n        for (int i = 0; i < m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            edges.push_back({a, b});\n            g[a].push_back(i);\n            g[b].push_back(i);\n        }\n        \n        dfs(1, -1, n);\n        \n        vector <int> ans(n + 1, n + m);\n        vector <int> dist(n + 1, n + m);\n        queue <int> q;\n        for (int i = 0; i < m; ++i) {\n            if (cut[i] && path[i]) {\n                ans[edges[i].first] = min(ans[edges[i].first], i + 1);\n                ans[edges[i].second] = min(ans[edges[i].second], i + 1);\n                if (dist[edges[i].first]) {\n                    dist[edges[i].first] = 0;\n                    q.push(edges[i].first);\n                }\n                if (dist[edges[i].second]) {\n                    dist[edges[i].second] = 0;\n                    q.push(edges[i].second);\n                }\n            }\n        }\n        \n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (auto e : g[v]) {\n                int to = edges[e].first + edges[e].second - v;\n                if (dist[to] > dist[v] + 1) {\n                    dist[to] = dist[v] + 1;\n                    ans[to] = ans[v];\n                    q.push(to);\n                }\n                else if (dist[to] == dist[v] + 1)\n                    ans[to] = min(ans[to], ans[v]);\n            }\n        }\n        \n        int Q;\n        cin >> Q;\n        while (Q--) {\n            int v;\n            cin >> v;\n            if (ans[v] == n + m) cout << -1;\n            else cout << ans[v];\n            if (t || Q) cout << '\\n';\n        }\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvector <vector <int>> g;\nvector <bool> used;\nvector <int> d, h;\nvector <pair <int, int>> edges;\nvector <int> cut, path;\nint mark = 1;\n\nvoid dfs(int v, int p, int n) {\n    used[v] = true;\n    d[v] = h[v] = (p == -1 ? 0 : d[p] + 1);\n    if (v == n) mark = 0;\n    for (auto e : g[v]) {\n        int to = edges[e].first + edges[e].second - v;\n        if (to == p) continue;\n        if (used[to])\n            h[v] = min(h[v], d[to]);\n        else {\n            path[e] ^= mark;\n            dfs(to, v, n);\n            path[e] ^= mark;\n            h[v] = min(h[v], h[to]);\n            if (h[to] > d[v]) cut[e] = 1;\n        }\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        g.assign(n + 1, {});\n        used.assign(n + 1, false);\n        d.assign(n + 1, 0);\n        h.assign(n + 1, 0);\n        edges = {};\n        cut.assign(m, false);\n        path.assign(m, false);\n        mark = 1;\n        for (int i = 0; i < m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            edges.push_back({a, b});\n            g[a].push_back(i);\n            g[b].push_back(i);\n        }\n        \n        dfs(1, -1, n);\n        \n        vector <int> ans(n + 1, n + m);\n        vector <int> dist(n + 1, n + m);\n        queue <int> q;\n        for (int i = 0; i < m; ++i) {\n            if (cut[i] && path[i]) {\n                ans[edges[i].first] = min(ans[edges[i].first], i + 1);\n                ans[edges[i].second] = min(ans[edges[i].second], i + 1);\n                if (dist[edges[i].first]) {\n                    dist[edges[i].first] = 0;\n                    q.push(edges[i].first);\n                }\n                if (dist[edges[i].second]) {\n                    dist[edges[i].second] = 0;\n                    q.push(edges[i].second);\n                }\n            }\n        }\n        \n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (auto e : g[v]) {\n                int to = edges[e].first + edges[e].second - v;\n                if (dist[to] > dist[v] + 1) {\n                    dist[to] = dist[v] + 1;\n                    ans[to] = ans[v];\n                    q.push(to);\n                }\n                else if (dist[to] == dist[v] + 1)\n                    ans[to] = min(ans[to], ans[v]);\n            }\n        }\n        \n        int Q;\n        cin >> Q;\n        while (Q--) {\n            int v;\n            cin >> v;\n            if (ans[v] == n + m) cout << -1;\n            else cout << ans[v];\n            if (t || Q) cout << '\\n';\n        }\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132G": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132G",
    "problem_title": "2132G - Famous Choreographer",
    "time_limit": "",
    "memory_limit": "",
    "statement": "",
    "sample_inputs": [],
    "sample_outputs": [],
    "notes": "",
    "tags": [],
    "url": "",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [
      {
        "title": "hint 1",
        "text": "There is no point in adding new symbols both above and below the original table simultaneously. Similarly, there is no point in adding symbols both to the left and to the right of the table at the same time.",
        "codes": []
      },
      {
        "title": "hint 2",
        "text": "The center of the optimal answer table lies within the original one.",
        "codes": []
      },
      {
        "title": "hint 3",
        "text": "We do not need to construct the answer; it is sufficient to check that an answer exists for the current center. Think about how to do this.",
        "codes": []
      },
      {
        "title": "hint 4",
        "text": "An answer exists for the current center if the subtable, which is the intersection of the original table and the one rotated around the center by $$$180^{\\circ}$$$, becomes identical to the original when rotated by $$$180^{\\circ}$$$. This subtable must contain at least one of the corners of the original table.",
        "codes": []
      },
      {
        "title": "hint 5",
        "text": "The checking of centers can be replaced by the checking of subtables that contain at least one of the corners of the original table.",
        "codes": []
      },
      {
        "title": "hint 6",
        "text": "To check the subtables to see if they become identical to the original when rotated by $$$180^{\\circ}$$$, we can use hashing.",
        "codes": []
      }
    ],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MOD = 998244353;\nconst int P[2] = { 107, 61 };\nint BP[2];\n\nlong long bin_pow(long long a, int n) {\n    long long ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % MOD;\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return ret;\n}\n\ninline int add(int a, int b) {\n    int res = a + b;\n    if (res >= MOD) return res - MOD;\n    return res;\n}\n\ninline int sub(int a, int b) {\n    int res = a - b;\n    if (res < 0) return res + MOD;\n    return res;\n}\n\ninline int mult(int a, int b) {\n    long long res = (long long)a * b;\n    if (res >= MOD) return res % MOD;\n    return res;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    BP[0] = bin_pow(P[0], MOD - 2);\n    BP[1] = bin_pow(P[1], MOD - 2);\n    vector <int> pows[2];\n    vector <int> bpows[2];\n    for (int j = 0; j < 2; j++) {\n        pows[j].resize(1e6, 1);\n        bpows[j].resize(1e6, 1);\n        for (int i = 1; i < 1e6; i++) {\n            pows[j][i] = mult(pows[j][i - 1], P[j]);\n            bpows[j][i] = mult(bpows[j][i - 1], BP[j]);\n        }\n    }\n    \n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector <string> f(n);\n        for (int i = 0; i < n; i++)\n            cin >> f[i];\n        \n        vector <vector <int>> hash(n + 2, vector <int> (m + 2, 0));\n        vector <vector <int>> bhash(n + 2, vector <int> (m + 2, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][i - 1], pows[1][j - 1]));\n                hash[i][j] = add(sub(add(hash[i - 1][j], hash[i][j - 1]), hash[i - 1][j - 1]), cur);\n            }\n        }\n        for (int i = n; i >= 1; i--) {\n            for (int j = m; j >= 1; j--) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][n - i], pows[1][m - j]));\n                bhash[i][j] = add(sub(add(bhash[i + 1][j], bhash[i][j + 1]), bhash[i + 1][j + 1]), cur);\n            }\n        }\n        \n        auto isp = [&](int x1, int y1, int x2, int y2) {\n            int hsh = add(sub(sub(hash[x2][y2], hash[x1-1][y2]), hash[x2][y1-1]), hash[x1-1][y1-1]);\n            int bhsh = add(sub(sub(bhash[x1][y1], bhash[x2+1][y1]), bhash[x1][y2+1]), bhash[x2+1][y2+1]);\n            hsh = mult(hsh, mult(bpows[0][x1 - 1], bpows[1][y1 - 1]));\n            bhsh = mult(bhsh, mult(bpows[0][n - x2], bpows[1][m - y2]));\n            return hsh == bhsh;\n        };\n        \n        int mn = n * m * 4;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (isp(1, 1, i, j)) mn = min(mn, (2 * n - i) * (2 * m - j));\n                if (isp(1, j, i, m)) mn = min(mn, (2 * n - i) * (m + j - 1));\n                if (isp(i, 1, n, j)) mn = min(mn, (n + i - 1) * (2 * m - j));\n                if (isp(i, j, n, m)) mn = min(mn, (n + i - 1) * (m + j - 1));\n            }\n        }\n        \n        cout << mn - m * n << '\\n';\n    }\n    \n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MOD = 998244353;\nconst int P[2] = { 107, 61 };\nint BP[2];\n\nlong long bin_pow(long long a, int n) {\n    long long ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % MOD;\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return ret;\n}\n\ninline int add(int a, int b) {\n    int res = a + b;\n    if (res >= MOD) return res - MOD;\n    return res;\n}\n\ninline int sub(int a, int b) {\n    int res = a - b;\n    if (res < 0) return res + MOD;\n    return res;\n}\n\ninline int mult(int a, int b) {\n    long long res = (long long)a * b;\n    if (res >= MOD) return res % MOD;\n    return res;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    BP[0] = bin_pow(P[0], MOD - 2);\n    BP[1] = bin_pow(P[1], MOD - 2);\n    vector <int> pows[2];\n    vector <int> bpows[2];\n    for (int j = 0; j < 2; j++) {\n        pows[j].resize(1e6, 1);\n        bpows[j].resize(1e6, 1);\n        for (int i = 1; i < 1e6; i++) {\n            pows[j][i] = mult(pows[j][i - 1], P[j]);\n            bpows[j][i] = mult(bpows[j][i - 1], BP[j]);\n        }\n    }\n    \n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector <string> f(n);\n        for (int i = 0; i < n; i++)\n            cin >> f[i];\n        \n        vector <vector <int>> hash(n + 2, vector <int> (m + 2, 0));\n        vector <vector <int>> bhash(n + 2, vector <int> (m + 2, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][i - 1], pows[1][j - 1]));\n                hash[i][j] = add(sub(add(hash[i - 1][j], hash[i][j - 1]), hash[i - 1][j - 1]), cur);\n            }\n        }\n        for (int i = n; i >= 1; i--) {\n            for (int j = m; j >= 1; j--) {\n                int cur = mult((f[i - 1][j - 1] - 'a' + 1), mult(pows[0][n - i], pows[1][m - j]));\n                bhash[i][j] = add(sub(add(bhash[i + 1][j], bhash[i][j + 1]), bhash[i + 1][j + 1]), cur);\n            }\n        }\n        \n        auto isp = [&](int x1, int y1, int x2, int y2) {\n            int hsh = add(sub(sub(hash[x2][y2], hash[x1-1][y2]), hash[x2][y1-1]), hash[x1-1][y1-1]);\n            int bhsh = add(sub(sub(bhash[x1][y1], bhash[x2+1][y1]), bhash[x1][y2+1]), bhash[x2+1][y2+1]);\n            hsh = mult(hsh, mult(bpows[0][x1 - 1], bpows[1][y1 - 1]));\n            bhsh = mult(bhsh, mult(bpows[0][n - x2], bpows[1][m - y2]));\n            return hsh == bhsh;\n        };\n        \n        int mn = n * m * 4;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (isp(1, 1, i, j)) mn = min(mn, (2 * n - i) * (2 * m - j));\n                if (isp(1, j, i, m)) mn = min(mn, (2 * n - i) * (m + j - 1));\n                if (isp(i, 1, n, j)) mn = min(mn, (n + i - 1) * (2 * m - j));\n                if (isp(i, j, n, m)) mn = min(mn, (n + i - 1) * (m + j - 1));\n            }\n        }\n        \n        cout << mn - m * n << '\\n';\n    }\n    \n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2132A": {
    "contest_title": "Codeforces Round 1043 (Div. 3)",
    "problem_id": "2132A",
    "problem_title": "A. Homework",
    "time_limit": "1 second",
    "memory_limit": "256 megabytes",
    "statement": "Vlad and Dima have been assigned a task in school for their English class. They were given two strings $$$a$$$ and $$$b$$$ and asked to append all characters from $$$b$$$ to string $$$a$$$ in any order. The guys decided to divide the work between themselves and, after lengthy negotiations, determined who would add each character from string $$$b$$$ to $$$a$$$.Due to his peculiarities, Vlad can only add characters to the beginning of the word, while Dima can only add them to the end. They add characters in the order they appear in string $$$b$$$. Your task is to determine what string Vlad and Dima will end up with.\n\nInputEach test consists of several test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The description of the test cases follows.The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 10$$$) — the length of the string $$$a$$$.The second line contains the string $$$a$$$, consisting of lowercase letters of the English alphabet.The third line contains an integer $$$m$$$ ($$$1 \\le m \\le 10$$$) — the length of the strings $$$b$$$ and $$$c$$$.The fourth line contains the string $$$b$$$, consisting of lowercase letters of the English alphabet.The fifth line contains the string $$$c$$$, consisting of the characters'V'and'D'— the distribution of the characters of string $$$b$$$ between Dima and Vlad. If $$$c_i$$$ ='V', then the $$$i$$$-th letter is added by Vlad; otherwise, it is added by Dima.\n\nOutputFor each test case, output the string that will result from Dima and Vlad's work.",
    "sample_inputs": [
      "42ot2adDV3efo7rdcoecsDVDVDVD3aca4bbaaDVDV3biz4abonVVDD"
    ],
    "sample_outputs": [
      "dota\ncodeforces\nabacaba\nbabizon"
    ],
    "notes": "NoteIn the first test case, there is initially a string $$$ot$$$. Then Dima appends the character $$$a$$$ to the end of the string, resulting in $$$ota$$$, and Vlad appends the last character, resulting in $$$dota$$$.In the second test case, the string will change as follows: $$$efo \\rightarrow efor \\rightarrow defor \\rightarrow deforc \\rightarrow odeforc \\rightarrow odeforce \\rightarrow codeforce \\rightarrow codeforces$$$In the third test case: $$$aca \\rightarrow acab \\rightarrow bacab \\rightarrow bacaba \\rightarrow abacaba$$$In the fourth test case: $$$biz \\rightarrow abiz \\rightarrow babiz \\rightarrow babizo \\rightarrow babizon$$$",
    "tags": [
      "brute force",
      "implementation",
      "strings",
      "*800"
    ],
    "url": "https://codeforces.com/problemset/problem/2132/A",
    "tutorial_info": {
      "has_tutorial": true,
      "tutorial_links": [
        {
          "text": "Tutorial",
          "title": "Codeforces Round 1043 (Div. 3) Editorial",
          "url": "/blog/entry/145692",
          "full_url": "https://codeforces.com/blog/entry/145692"
        }
      ],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [
      {
        "title": "solution",
        "text": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve() {\n    string a, b, c;\n    int n, m;\n    cin >> n >> a;\n    cin >> m >> b >> c;\n    string add_left = \"\";\n    for (int i = 0; i < m; ++i) {\n        if (c[i] == 'V') {\n            add_left += b[i];\n        } else {\n            a += b[i];\n        }\n    }\n    reverse(add_left.begin(), add_left.end());\n    cout << add_left + a << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}",
        "codes": [
          "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve() {\n    string a, b, c;\n    int n, m;\n    cin >> n >> a;\n    cin >> m >> b >> c;\n    string add_left = \"\";\n    for (int i = 0; i < m; ++i) {\n        if (c[i] == 'V') {\n            add_left += b[i];\n        } else {\n            a += b[i];\n        }\n    }\n    reverse(add_left.begin(), add_left.end());\n    cout << add_left + a << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        ]
      }
    ],
    "tutorials": [],
    "editorials": [
      {
        "title": "editorial",
        "text": "Tutorial is loading...",
        "codes": []
      }
    ]
  },
  "2138C1": {
    "contest_title": "Codeforces Round 1048 (Div. 1)",
    "problem_id": "2138C1",
    "problem_title": "C1. Maple and Tree Beauty (Easy Version)",
    "time_limit": "3 seconds",
    "memory_limit": "1024 megabytes",
    "statement": "This is the easy version of the problem. The difference between the versions is that in this version, the constraints on $$$t$$$ and $$$n$$$ are smaller. You can hack only if you solved all versions of this problem.Maple is given a rooted tree consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$, where the root has index $$$1$$$. Each vertex of the tree is labeled either zero or one. Unfortunately, Maple forgot how the vertices are labeled and only remembers that there are exactly $$$k$$$ zeros and $$$n - k$$$ ones.For each vertex, we define thenameof the vertex as the binary string formed by concatenating the labels of the vertices from the root to the vertex. More formally, $$$\\text{name}_1 = \\text{label}_1$$$ and $$$\\text{name}_u = \\text{name}_{p_u} + \\text{label}_u$$$ for all $$$2\\le u\\le n$$$, where $$$p_u$$$ is the parent of vertex $$$u$$$ and $$$+$$$ represents string concatenation.Thebeautyof the tree is equal to the length of the longest common subsequence$$$^{\\text{∗}}$$$ of the names of all theleaves$$$^{\\text{†}}$$$. Your task is to determine the maximum beauty among all labelings of the tree with exactly $$$k$$$ zeros and $$$n - k$$$ ones.$$$^{\\text{∗}}$$$A sequence $$$a$$$ is a subsequence of a sequence $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by the deletion of several (possibly, zero or all) element from arbitrary positions.  The longest common subsequence of strings $$$s_1, s_2, \\ldots s_m$$$ is the longest string that is a subsequence of all of $$$s_1, s_2, \\ldots, s_m$$$.$$$^{\\text{†}}$$$A leaf is any vertex without children.\n\nInputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 50$$$). The description of the test cases follows.The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\leq n \\leq 1000$$$, $$$0 \\leq k \\leq n$$$) — the number of vertices and the number of vertices labeled with zero, respectively.The second line contains $$$n - 1$$$ integers $$$p_2, p_3, \\ldots, p_{n}$$$ ($$$1 \\leq p_i \\le i - 1$$$) — the parent of vertex $$$i$$$.Note that there areno constraintson the sum of $$$n$$$ over all test cases.\n\nOutputFor each test case, output a single integer representing the maximum beauty among all labelings of the tree with exactly $$$k$$$ zeros and $$$n - k$$$ ones.",
    "sample_inputs": [
      "57 31 1 2 2 3 37 21 1 2 3 1 15 01 2 3 45 21 1 1 15 41 1 1 1",
      "52 012 113 01 13 11 23 11 1"
    ],
    "sample_outputs": [
      "3\n2\n5\n1\n2",
      "2\n2\n2\n3\n2"
    ],
    "notes": "NoteIn the first test case, the maximum beauty is $$$3$$$, when the vertices are labeled with $$$[0, 0, 0, 1, 1, 1, 1]$$$, and the longest common subsequence is001.In the second test case, the maximum beauty is $$$2$$$, when the vertices are labeled with $$$[1, 0, 0, 1, 1, 1, 1]$$$, and the longest common subsequence is11.",
    "tags": [],
    "url": "https://codeforces.com/problemset/problem/2138/C1",
    "tutorial_info": {
      "has_tutorial": false,
      "tutorial_links": [],
      "announcement_links": []
    },
    "hints": [],
    "solutions": [],
    "tutorials": [],
    "editorials": []
  }
}